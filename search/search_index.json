{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the EMR Containers Best Practices Guide. The primary goal of this project is to offer a set of best practices and templates to get started with Amazon EMR on EKS . We publish this guide on GitHub so we could iterate the content quickly, provide timely and effective recommendations for variety of concerns, and easily incorporate suggestions from the broader community. Amazon EMR on EKS Workshop \u00b6 If you are interested in step by step tutorials that leverage the best practices contained in this guide, please visit the Amazon EMR on EKS Workshop. Contributing \u00b6 We encourage you to contribute to these guides. If you have implemented a practice that has proven to be effective, please share it with us by opening an issue or a pull request. Similarly, if you discover an error or flaw in the guide, please submit a pull request to correct it.","title":"Introduction"},{"location":"#amazon-emr-on-eks-workshop","text":"If you are interested in step by step tutorials that leverage the best practices contained in this guide, please visit the Amazon EMR on EKS Workshop.","title":"Amazon EMR on EKS Workshop"},{"location":"#contributing","text":"We encourage you to contribute to these guides. If you have implemented a practice that has proven to be effective, please share it with us by opening an issue or a pull request. Similarly, if you discover an error or flaw in the guide, please submit a pull request to correct it.","title":"Contributing"},{"location":"best-practices-and-recommendations/eks-best-practices/","text":"EKS Best Practices and Recommendations \u00b6 Amazon EMR on EKS team has run scale tests on EKS cluster and has compiled a list of recommendations. The purpose of this document is to share our recommendations for running large scale EKS clusters supporting EMR on EKS. Amazon VPC CNI Best practices \u00b6 Recommendation 1: Improve IP Address Utilization \u00b6 EKS clusters can run out of IP addresses for pods when they reached between 400 and 500 nodes. With the default CNI settings, each node can request more IP addresses than is required. To ensure that you don\u2019t run out of IP addresses, there are two solutions: Set MINIMUM_IP_TARGET and WARM_IP_TARGET instead of the default setting of WARM_ENI_TARGET=1 . The values of these settings will depend on your instance type, expected pod density, and workload. More info about these CNI settings can be found here . The maximum number of IP addresses per node (and thus maximum number of pods per node) depends on instance type and can be looked up here . If you have found the right CNI settings as described above, the subnets created by eksctl still do not provide enough addresses (by default eksctl creates a \u201c/19\u201d subnet for each nodegroup, which contains ~8.1k addresses). You can configure CNI to take addresses from (larger) subnets that you create. For example, you could create a few \u201c/16\u201d subnets, which contain ~65k IP addresses per subnet. You should implement this option after you have configured the CNI settings as described in #1. To configure your pods to use IP addresses from larger manually-created subnets, use CNI custom networking (see below for more information): CNI custom networking By default, the CNI assigns the Pod\u2019s IP address from the worker node's primary elastic network interface's (ENI) security groups and subnet. If you don\u2019t have enough IP addresses in the worker node subnet, or prefer that the worker nodes and Pods reside in separate subnets to avoid IP address allocation conflicts between Pods and other resources in the VPC, you can use CNI custom networking . Enabling a custom network removes an available elastic network interface (and all of its available IP addresses for pods) from each worker node that uses it. The worker node's primary network interface is not used for pod placement when a custom network is enabled. If you want the CNI to assign IP addresses for Pods from a different subnet, you can set AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG environment variable to true . kubectl set env daemonset aws-node \\ -n kube-system AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG = true When AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true , the CNI will assign Pod IP address from a subnet defined in ENIConfig . The ENIConfig custom resource is used to define the subnet in which Pods will be scheduled. apiVersion : crd.k8s.amazonaws.com/v1alpha1 kind : ENIConfig metadata : name : us-west-2a spec : securityGroups : - sg-0dff111a1d11c1c11 subnet : subnet-011b111c1f11fdf11 You will need to create an ENIconfig custom resource for each subnet you want to use for Pod networking. The securityGroups field should have the ID of the security group attached to the worker nodes. The name field should be the name of the Availability Zone in your VPC. If you name your ENIConfig custom resources after each Availability Zone in your VPC, you can enable Kubernetes to automatically apply the corresponding ENIConfig for the worker node Availability Zone with the following command. kubectl set env daemonset aws-node \\ -n kube-system ENI_CONFIG_LABEL_DEF = failure-domain.beta.kubernetes.io/zone Note Upon creating the ENIconfig custom resources, you will need to create new worker nodes. The existing worker nodes and Pods will remain unaffected. Recommendation 2: Prevent EC2 VPC API throttling from AssignPrivateIpAddresses & AttachNetworkInterface \u00b6 Often EKS cluster scale-out time can increase because the CNI is being throttled by the EC2 VPC APIs. The following steps can be taken to prevent these issues: Use CNI version 1.8.0 or later as it reduces the calls to EC2 VPC APIs than earlier versions. Configure the MINIMUM_IP_TARGET and WARM_IP_TARGET parameters instead of the default parameter of WARM_ENI_TARGET=1 . Only those IP addresses that are necessary are requested from EC2. The values of these settings will depend on your instance type and expected pod density. More info about these settings here . Request an API limit increase on the EC2 VPC APIs that are getting throttled. This option should be considered only after steps 1 & 2 have been done. Other Recommendations for Amazon VPC CNI \u00b6 Plan for growth \u00b6 Size the subnets you will use for Pod networking for growth. If you have insufficient IP addresses available in the subnet that the CNI uses, your pods will not get an IP address. The pods will remain in the pending state until an IP address becomes available. This may impact application autoscaling and compromise its availability. Monitor IP address inventory \u00b6 You can monitor the IP addresses inventory of subnets using the CNI Metrics Helper , and set CloudWatch alarms to get notified if a subnet is running out of IP addresses. SNAT setting \u00b6 Source Network Address Translation (source-nat or SNAT) allows traffic from a private network to go out to the internet. Virtual machines launched on a private network can get to the internet by going through a gateway capable of performing SNAT. If your Pods with private IP address need to communicate with other private IP address spaces (for example, Direct Connect, VPC Peering or Transit VPC), then you should enable external SNAT in the CNI: kubectl set env daemonset \\ -n kube-system aws-node AWS_VPC_K8S_CNI_EXTERNALSNAT = true CoreDNS Best practices \u00b6 Prevent CoreDNS from being overwhelmed (UnknownHostException in spark jobs and other pods) \u00b6 CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can be a problem for workloads that do a lot of DNS lookups. One simple solution is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks. Monitor CoreDNS metrics \u00b6 CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can cause workloads to timeout with unknownHostException as spark-executors will do a lot of DNS lookups which registering themselves to spark-driver. One simple solution to fix this is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks. Cluster Autoscaler Best practices \u00b6 Increase cluster-autoscaler memory to avoid unnecessary exceptions \u00b6 Cluster-autoscaler can require a lot of memory to run because it stores a lot of information about the state of the cluster, such as data about every pod and every node. If the cluster-autoscaler has insufficient memory, it can lead to the cluster-autoscaler crashing. Ensure that you provide the cluster-autoscaler deployment more memory, e.g., 1Gi memory instead of the default 300Mi. Useful information about configuring the cluster-autoscaler for improved scalability and performance can be found here Avoid job failures when Cluster Autoscaler attempts scale-in \u00b6 Cluster Autoscaler will attempt scale-in action for any under utilized instance within your EKScluster. When scale-in action is performed, all pods from that instance is relocated to another node. This could cause disruption for critical workloads. For example, if driver pod is restarted, the entire job needs to restart. For this reason, we recommend using Kubernetes annotations on all critical pods (especially driver pods) and for cluster autoscaler deployment. Please see here for more info cluster-autoscaler.kubernetes.io/safe-to-evict=false Configure overprovisioning with Cluster Autoscaler for higher priority jobs \u00b6 If the required resources is not available in the cluster, pods go into pending state. Cluster Autoscaler uses this metric to scale out the cluster and this activity can be time consuming (several minutes) for higher priority jobs. In order to minimize time required for scaling, we recommend overprovisioning resources. You can launch pause pods(dummy workloads which sleeps until it receives SIGINT or SIGTERM) with negative priority to reserve EC2 capacity. Once the higher priority jobs are scheduled, these pause pods are preempted to make room for high priority pods which in turn scales out additional capacity as a buffer. You need to be aware that this is a trade-off as it adds slightly higher cost while minimizing scheduling latency. You can read more about over provisioning best practice here . EKS Control Plane Best practices \u00b6 API server overwhelmed \u00b6 System pods, workload pods, and external systems can make many calls to the Kubernetes API server. This can decrease performance and also increase EMR on EKS job failures. There are multiple ways to avoid API server availability issues including but not limited to: By default, the EKS API servers are automatically scaled to meet your workload demand. If you see increased latencies, please contact AWS via a support ticket and work with engineering team to resolve the issue. Consider reducing the scan interval of cluster-autoscaler from the 10 second default value. Each time the cluster-autoscaler runs, it makes many calls to the API server. However, this will result in the cluster scaling-out less frequently and in larger steps (and same with scaling back in when load is reduced). More information can be found about the cluster-autoscaler here . This is not recommended if you need jobs to start ASAP. If you are running your own deployment of fluentd, an increased load on the APIserver can be observed. Consider using fluent-bit instead which makes fewer calls to the API server. More info can be found here Monitor Control Plane Metrics \u00b6 Monitoring Kubernetes API metrics can give you insights into control plane performance and identify issues. An unhealthy control plane can compromise the availability of the workloads running inside the cluster. For example, poorly written controllers can overload the API servers, affecting your application's availability. Kubernetes exposes control plane metrics at the /metrics endpoint. You can view the metrics exposed using kubectl : kubectl get --raw /metrics These metrics are represented in a Prometheus text format . You can use Prometheus to collect and store these metrics. In May 2020, CloudWatch added support for monitoring Prometheus metrics in CloudWatch Container Insights. So you can also use Amazon CloudWatch to monitor the EKS control plane. You can follow the Tutorial for Adding a New Prometheus Scrape Target: Prometheus KPI Server Metrics to collect metrics and create CloudWatch dashboard to monitor your cluster\u2019s control plane. You can also find Kubernetes API server metrics here . For example, apiserver_request_duration_seconds can indicate how long API requests are taking to run. Consider monitoring these control plane metrics: API Server \u00b6 Metric Description apiserver_request_total Counter of apiserver requests broken out for each verb, dry run value, group, version, resource, scope, component, client, and HTTP response contentType and code. apiserver_request_duration_seconds* Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope, and component. rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. apiserver_admission_controller_admission_duration_seconds Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host. etcd \u00b6 Metric Description etcd_request_duration_seconds Etcd request latency in seconds for each operation and object type. You can visualize and monitor these Kubernetes API server requests, latency and etcD metrics on Grafana via Grafana dashboard 12006 .","title":"EKS Best Practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#eks-best-practices-and-recommendations","text":"Amazon EMR on EKS team has run scale tests on EKS cluster and has compiled a list of recommendations. The purpose of this document is to share our recommendations for running large scale EKS clusters supporting EMR on EKS.","title":"EKS Best Practices and Recommendations"},{"location":"best-practices-and-recommendations/eks-best-practices/#amazon-vpc-cni-best-practices","text":"","title":"Amazon VPC CNI Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-1-improve-ip-address-utilization","text":"EKS clusters can run out of IP addresses for pods when they reached between 400 and 500 nodes. With the default CNI settings, each node can request more IP addresses than is required. To ensure that you don\u2019t run out of IP addresses, there are two solutions: Set MINIMUM_IP_TARGET and WARM_IP_TARGET instead of the default setting of WARM_ENI_TARGET=1 . The values of these settings will depend on your instance type, expected pod density, and workload. More info about these CNI settings can be found here . The maximum number of IP addresses per node (and thus maximum number of pods per node) depends on instance type and can be looked up here . If you have found the right CNI settings as described above, the subnets created by eksctl still do not provide enough addresses (by default eksctl creates a \u201c/19\u201d subnet for each nodegroup, which contains ~8.1k addresses). You can configure CNI to take addresses from (larger) subnets that you create. For example, you could create a few \u201c/16\u201d subnets, which contain ~65k IP addresses per subnet. You should implement this option after you have configured the CNI settings as described in #1. To configure your pods to use IP addresses from larger manually-created subnets, use CNI custom networking (see below for more information): CNI custom networking By default, the CNI assigns the Pod\u2019s IP address from the worker node's primary elastic network interface's (ENI) security groups and subnet. If you don\u2019t have enough IP addresses in the worker node subnet, or prefer that the worker nodes and Pods reside in separate subnets to avoid IP address allocation conflicts between Pods and other resources in the VPC, you can use CNI custom networking . Enabling a custom network removes an available elastic network interface (and all of its available IP addresses for pods) from each worker node that uses it. The worker node's primary network interface is not used for pod placement when a custom network is enabled. If you want the CNI to assign IP addresses for Pods from a different subnet, you can set AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG environment variable to true . kubectl set env daemonset aws-node \\ -n kube-system AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG = true When AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true , the CNI will assign Pod IP address from a subnet defined in ENIConfig . The ENIConfig custom resource is used to define the subnet in which Pods will be scheduled. apiVersion : crd.k8s.amazonaws.com/v1alpha1 kind : ENIConfig metadata : name : us-west-2a spec : securityGroups : - sg-0dff111a1d11c1c11 subnet : subnet-011b111c1f11fdf11 You will need to create an ENIconfig custom resource for each subnet you want to use for Pod networking. The securityGroups field should have the ID of the security group attached to the worker nodes. The name field should be the name of the Availability Zone in your VPC. If you name your ENIConfig custom resources after each Availability Zone in your VPC, you can enable Kubernetes to automatically apply the corresponding ENIConfig for the worker node Availability Zone with the following command. kubectl set env daemonset aws-node \\ -n kube-system ENI_CONFIG_LABEL_DEF = failure-domain.beta.kubernetes.io/zone Note Upon creating the ENIconfig custom resources, you will need to create new worker nodes. The existing worker nodes and Pods will remain unaffected.","title":"Recommendation 1: Improve IP Address Utilization"},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-2-prevent-ec2-vpc-api-throttling-from-assignprivateipaddresses-attachnetworkinterface","text":"Often EKS cluster scale-out time can increase because the CNI is being throttled by the EC2 VPC APIs. The following steps can be taken to prevent these issues: Use CNI version 1.8.0 or later as it reduces the calls to EC2 VPC APIs than earlier versions. Configure the MINIMUM_IP_TARGET and WARM_IP_TARGET parameters instead of the default parameter of WARM_ENI_TARGET=1 . Only those IP addresses that are necessary are requested from EC2. The values of these settings will depend on your instance type and expected pod density. More info about these settings here . Request an API limit increase on the EC2 VPC APIs that are getting throttled. This option should be considered only after steps 1 & 2 have been done.","title":"Recommendation 2: Prevent EC2 VPC API throttling from AssignPrivateIpAddresses &amp; AttachNetworkInterface"},{"location":"best-practices-and-recommendations/eks-best-practices/#other-recommendations-for-amazon-vpc-cni","text":"","title":"Other Recommendations for Amazon VPC CNI"},{"location":"best-practices-and-recommendations/eks-best-practices/#plan-for-growth","text":"Size the subnets you will use for Pod networking for growth. If you have insufficient IP addresses available in the subnet that the CNI uses, your pods will not get an IP address. The pods will remain in the pending state until an IP address becomes available. This may impact application autoscaling and compromise its availability.","title":"Plan for growth"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-ip-address-inventory","text":"You can monitor the IP addresses inventory of subnets using the CNI Metrics Helper , and set CloudWatch alarms to get notified if a subnet is running out of IP addresses.","title":"Monitor IP address inventory"},{"location":"best-practices-and-recommendations/eks-best-practices/#snat-setting","text":"Source Network Address Translation (source-nat or SNAT) allows traffic from a private network to go out to the internet. Virtual machines launched on a private network can get to the internet by going through a gateway capable of performing SNAT. If your Pods with private IP address need to communicate with other private IP address spaces (for example, Direct Connect, VPC Peering or Transit VPC), then you should enable external SNAT in the CNI: kubectl set env daemonset \\ -n kube-system aws-node AWS_VPC_K8S_CNI_EXTERNALSNAT = true","title":"SNAT setting"},{"location":"best-practices-and-recommendations/eks-best-practices/#coredns-best-practices","text":"","title":"CoreDNS Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#prevent-coredns-from-being-overwhelmed-unknownhostexception-in-spark-jobs-and-other-pods","text":"CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can be a problem for workloads that do a lot of DNS lookups. One simple solution is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.","title":"Prevent CoreDNS from being overwhelmed (UnknownHostException in spark jobs and other pods)"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-coredns-metrics","text":"CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can cause workloads to timeout with unknownHostException as spark-executors will do a lot of DNS lookups which registering themselves to spark-driver. One simple solution to fix this is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.","title":"Monitor CoreDNS metrics"},{"location":"best-practices-and-recommendations/eks-best-practices/#cluster-autoscaler-best-practices","text":"","title":"Cluster Autoscaler Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#increase-cluster-autoscaler-memory-to-avoid-unnecessary-exceptions","text":"Cluster-autoscaler can require a lot of memory to run because it stores a lot of information about the state of the cluster, such as data about every pod and every node. If the cluster-autoscaler has insufficient memory, it can lead to the cluster-autoscaler crashing. Ensure that you provide the cluster-autoscaler deployment more memory, e.g., 1Gi memory instead of the default 300Mi. Useful information about configuring the cluster-autoscaler for improved scalability and performance can be found here","title":"Increase cluster-autoscaler memory to avoid unnecessary exceptions"},{"location":"best-practices-and-recommendations/eks-best-practices/#avoid-job-failures-when-cluster-autoscaler-attempts-scale-in","text":"Cluster Autoscaler will attempt scale-in action for any under utilized instance within your EKScluster. When scale-in action is performed, all pods from that instance is relocated to another node. This could cause disruption for critical workloads. For example, if driver pod is restarted, the entire job needs to restart. For this reason, we recommend using Kubernetes annotations on all critical pods (especially driver pods) and for cluster autoscaler deployment. Please see here for more info cluster-autoscaler.kubernetes.io/safe-to-evict=false","title":"Avoid job failures when Cluster Autoscaler attempts scale-in"},{"location":"best-practices-and-recommendations/eks-best-practices/#configure-overprovisioning-with-cluster-autoscaler-for-higher-priority-jobs","text":"If the required resources is not available in the cluster, pods go into pending state. Cluster Autoscaler uses this metric to scale out the cluster and this activity can be time consuming (several minutes) for higher priority jobs. In order to minimize time required for scaling, we recommend overprovisioning resources. You can launch pause pods(dummy workloads which sleeps until it receives SIGINT or SIGTERM) with negative priority to reserve EC2 capacity. Once the higher priority jobs are scheduled, these pause pods are preempted to make room for high priority pods which in turn scales out additional capacity as a buffer. You need to be aware that this is a trade-off as it adds slightly higher cost while minimizing scheduling latency. You can read more about over provisioning best practice here .","title":"Configure overprovisioning with Cluster Autoscaler for higher priority jobs"},{"location":"best-practices-and-recommendations/eks-best-practices/#eks-control-plane-best-practices","text":"","title":"EKS Control Plane Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server-overwhelmed","text":"System pods, workload pods, and external systems can make many calls to the Kubernetes API server. This can decrease performance and also increase EMR on EKS job failures. There are multiple ways to avoid API server availability issues including but not limited to: By default, the EKS API servers are automatically scaled to meet your workload demand. If you see increased latencies, please contact AWS via a support ticket and work with engineering team to resolve the issue. Consider reducing the scan interval of cluster-autoscaler from the 10 second default value. Each time the cluster-autoscaler runs, it makes many calls to the API server. However, this will result in the cluster scaling-out less frequently and in larger steps (and same with scaling back in when load is reduced). More information can be found about the cluster-autoscaler here . This is not recommended if you need jobs to start ASAP. If you are running your own deployment of fluentd, an increased load on the APIserver can be observed. Consider using fluent-bit instead which makes fewer calls to the API server. More info can be found here","title":"API server overwhelmed"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-control-plane-metrics","text":"Monitoring Kubernetes API metrics can give you insights into control plane performance and identify issues. An unhealthy control plane can compromise the availability of the workloads running inside the cluster. For example, poorly written controllers can overload the API servers, affecting your application's availability. Kubernetes exposes control plane metrics at the /metrics endpoint. You can view the metrics exposed using kubectl : kubectl get --raw /metrics These metrics are represented in a Prometheus text format . You can use Prometheus to collect and store these metrics. In May 2020, CloudWatch added support for monitoring Prometheus metrics in CloudWatch Container Insights. So you can also use Amazon CloudWatch to monitor the EKS control plane. You can follow the Tutorial for Adding a New Prometheus Scrape Target: Prometheus KPI Server Metrics to collect metrics and create CloudWatch dashboard to monitor your cluster\u2019s control plane. You can also find Kubernetes API server metrics here . For example, apiserver_request_duration_seconds can indicate how long API requests are taking to run. Consider monitoring these control plane metrics:","title":"Monitor Control Plane Metrics"},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server","text":"Metric Description apiserver_request_total Counter of apiserver requests broken out for each verb, dry run value, group, version, resource, scope, component, client, and HTTP response contentType and code. apiserver_request_duration_seconds* Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope, and component. rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. apiserver_admission_controller_admission_duration_seconds Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host.","title":"API Server"},{"location":"best-practices-and-recommendations/eks-best-practices/#etcd","text":"Metric Description etcd_request_duration_seconds Etcd request latency in seconds for each operation and object type. You can visualize and monitor these Kubernetes API server requests, latency and etcD metrics on Grafana via Grafana dashboard 12006 .","title":"etcd"},{"location":"cost-optimization/docs/","text":"","title":"Index"},{"location":"cost-optimization/docs/cost-optimization/","text":"Cost Optimization using EC2 Spot Instances \u00b6 EC2 Spot Best Practices \u00b6 Amazon EMR on Amazon EKS enables you to submit Apache Spark jobs on demand on Amazon Elastic Kubernetes Service (EKS) without provisioning dedicated EMR clusters. With EMR on EKS, you can consolidate analytical workloads with your other Kubernetes-based applications on the same Amazon EKS cluster to improve resource utilization and simplify infrastructure management. Cost Optimization of the underlying infrastructure is often the key requirement for our customers, and this can be achieved by using Amazon EC2 Spot Instances . Spot Instances are spare EC2 capacity and is available at up to 90% discount compared to On-Demand Instance prices. If EC2 needs capacity back for On-Demand Instance usage, Spot Instances can be interrupted. Handling interruptions to build resilient workloads is simple and there are best practices to manage interruption by automation or AWS services like EKS. This document will describe how to architect with EC2 spot best practices and apply to EMR on EKS jobs. We will also cover Spark features related to EC2 Spot when you run EMR on EKS jobs EC2 Spot Capacity Provisioning \u00b6 EMR on EKS runs open-source big data framework like Spark on Amazon EKS, so basically when you are run on Spot instances you are, provisioning capacity for the underlying EKS cluster. The key point to remember when you are using Spot instances is instance diversification . There are three ways that EC2 Spot capacity can be provisioned in an EKS cluster. EKS Managed Nodegroup: We highly recommend to use Managed Nodegroup for provisioning Spot instances. This requires significantly less operational effort when compared to self-managed nodegroups. The Spot instance interruption is handled proactively using the Instance Rebalancing Recommendation and Spot best practice of using Capacity Optimized Allocation strategy is adopted by default along with other useful features. If you are planning to scale your cluster then Cluster Autoscaler can be used but keep in mind, one caveat with this approach is to maintain same vCPU to memory ratio for nodes defined in a nodegroup. Karpenter: An open-source node provisioning tool for Kubernetes which works seamlessly with EMR on EKS. Karpenter can help to improve the efficiency and cost of running workloads. It provisions nodes based on pod resource requirements. The key advantage of Karpenter is flexibility not only in terms of EC2 pricing (Spot/On-Demand) but it also aligns with the Spot best practice of instance diversification, and uses capacity optimized prioritized allocation strategy; more details can be found in this workshop . Karpenter will also be useful to scale the infrastructure which will be further discussed under the scaling section below. Self-Managed Nodegroup: EMR on EKS clusters can also run on self-managed nodegroups on EKS. You need to manage the Spot instance lifecycle if there is an interruption by installing an open-source tool named AWS Node Termination Handler . AWS Node Termination Handler ensures that the Kubernetes control plane responds appropriately to events that can cause your EC2 instance to become unavailable, such as EC2 maintenance events , EC2 Spot interruptions , ASG Scale-In , ASG AZ Rebalance , and EC2 Instance Termination via the API or Console. Please remember you need to manage all the software updates manually if you plan to use this. When you are using dynamic allocation the nodegroups needs to autoscale, and if you are using cluster autoscaler then you need to maintain the vCPU to memory ratio for nodes defined in a nodegroup. Spot Interruption and Spark \u00b6 EC2 Spot instances are suitable for flexible and fault tolerant workloads. Spark is a semi-resilient by design because if the executor fails, new executors are spun up by the driver to continue the job. However, if the driver fails, the entire job fails. For added resiliency, EMR of EKS retries up to 5 times for driver pods so that the k8s can find suitable host and job starts successfully. If k8s fails to find a host, job is cancelled after 15 min timeout. If driver pod fails for other reasons, job is cancelled with an error message for troubleshooting. Hence, we recommend to run Spark driver on On-Demand instances and executors on Spot instances to cost optimize the workloads. You can use PodTemplates to configure this scheduling constraint. NodeSelector can be used as the node selection constraint to run executors on Spot instances as in the example below. This is simple to use and works well with Karpenter too. The pod template for this would look like apiVersion : v1 kind : Pod spec : nodeSelector : eks.amazonaws.com/capacityType : SPOT containers : - name : spark-kubernetes-executor Node affinity can also be used here, this allows for more flexibility for the constraints defined. We recommend to use \u2018hard affinity\u2019 as highlighted in the code below for this purpose. For jobs which have strict SLA and are not suitable to run on Spot we suggest to use NoSchedule taint effect to ensure no Pods are scheduled. The key thing to note here is that the bulk of the compute required in a Spark job runs on executors and if they can be run on EC2 Spot instances you can benefit from the steep discount available with Spot instances. apiVersion : v1 kind : Pod metadata : labels : spark-role : driver namespace : emr-eks-workshop-namespace spec : affinity : nodeAffinity : requiredDuringSchedulingIgnoredDuringExecution : nodeSelectorTerms : - matchExpressions : - key : 'eks.amazonaws.com/capacityType' operator : In values : - ON_DEMAND apiVersion : v1 kind : Pod metadata : labels : spark-role : executor namespace : emr-eks-workshop-namespace spec : affinity : nodeAffinity : requiredDuringSchedulingIgnoredDuringExecution : nodeSelectorTerms : - matchExpressions : - key : 'eks.amazonaws.com/capacityType' operator : In values : - SPOT When Spot instances are interrupted the executors running on them may lose (if any) the shuffle and cached RDDs which would require re-computation. This requires more compute cycles to be spent which will impact the overall SLA of the EMR on EKS jobs. EMR on EKS has incorporated two new Spark features which can help to address these issues. In the following sections we will discuss them. Node Decommissioning: Node decommissioning is a Spark feature that enables the removal of an executor gracefully, by preserving its state before removing it and not scheduling any new jobs on it. This feature is particularly useful when the Spark executors are running on Spot instances, and the Spark executor node is interrupted via a \u2018rebalance recommendation\u2019 or \u2018instance termination\u2019 notice to reclaim the instance. Node decommission begins when a Spark executor node receives a Spot Interruption Notice or Spot Rebalance Recommendation signal. The executor node immediately starts the process of decommissioning by sending a message to the Spark driver. The driver will identify the RDD/Shuffle files that it needs to migrate off the executor node in question, and will try to identify another Executor node which can take over the execution. If an executor is identified, the RDD/Shuffle files are copied to the new executor and the job execution continues on the new executor. If all the executors are busy, the RDD/Shuffle files are copied to an external storage. The key advantage of this process is that it enables block and shuffle data of a Spark executor that receives EC2 Spot Interruption signal to be migrated, reducing the re-computation of the Spark tasks. The reduction in the re-computation for the interrupted Spark tasks improves the resiliency of the system and reduces overall execution time. We recommend to enable node decommissioning feature because it would help to reduce the overall compute cycles when there is a Spot interruption. This feature is available on Amazon EMR version 6.3 and above. To setup this feature, add this configuration to the Spark job under the executor section: \"spark.decommission.enabled\" : \"true\" \"spark.storage.decommission.rddBlocks.enabled\" : \"true\" \"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\" \"spark.storage.decommission.enabled\" : \"true\" \"spark.storage.decommission.fallbackStorage.path\" : \"s3://<<bucket>>\" The Spark executor logs sample shown below shows the process of decommission and sending message to the driver: 21 / 05 / 05 17 : 41 : 41 WARN KubernetesClusterSchedulerBackend$KubernetesDriverEndpoint : Received executor 7 decommissioned message 21 / 05 / 05 17 : 41 : 41 DEBUG TaskSetManager : Val id locality levels for TaskSet 2.0 : NO_PREF , ANY 21 / 05 / 05 17 : 41 : 41 INFO KubernetesClusterSchedulerBackend : Decommission executors : 7 21 / 05 / 05 17 : 41 : 41 DEBUG TaskSchedulerImpl : parentName : , name : TaskSet_2 .0 , run ningTasks : 10 21 / 05 / 05 17 : 41 : 41 INFO BlockManagerMasterEndpoint : Mark BlockManagers ( BlockManagerId ( 7 , 192.168.82.107 , 39007 , None )) as being decommissioning . 21 / 05 / 05 20 : 22 : 17 INFO CoarseGrainedExecutorBackend : Decommission executor 1. 21 / 05 / 05 20 : 22 : 17 INFO CoarseGrainedExecutorBackend : Will exit when finished decommissioning 21 / 05 / 05 20 : 22 : 17 INFO BlockManager : Starting block manager decommissioning process ... 21 / 05 / 05 20 : 22 : 17 DEBUG FileSystem : Looking for FS supporting s3a The Spark driver logs sample below shows the process of looking for an executor to migrate the shuffle data: 22 / 06 / 07 20 : 41 : 38 INFO ShuffleStatus : Updating map output for 46 to BlockManagerId ( 4 , 192.168.13.235 , 34737 , None ) 22 / 06 / 07 20 : 41 : 38 DEBUG BlockManagerMasterEndpoint : Received shuffle data block update for 0 46 , ignore . 22 / 06 / 07 20 : 41 : 38 DEBUG BlockManagerMasterEndpoint : Received shuffle index block update for 0 46 , updating . The Spark executor logs sample below shows the process of reusing the shuffle files: 22 / 06 / 07 20 : 42 : 50 INFO BasicExecutorFeatureStep : Adding decommission script to lifecycle 22 / 06 / 07 20 : 42 : 50 DEBUG ExecutorPodsAllocator : Requested executor with id 19 from Kubernetes . 22 / 06 / 07 20 : 42 : 50 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - bfd0a5813fd1b80f - exec - 19 , action ADDED 22 / 06 / 07 20 : 42 : 50 DEBUG BlockManagerMasterEndpoint : Received shuffle index block update for 0 52 , updating . 22 / 06 / 07 20 : 42 : 50 INFO ShuffleStatus : Recover 52 BlockManagerId ( fallback , remote, 7337, None) More details on this can be found here PVC Reuse: A PersistentVolume is a Kubernetes feature to provide persistent storage to container Pods running stateful workloads, and PersistentVolumeClaim (PVC) is to request the above storage in the container Pod for storage by a user. Apache Spark 3.1.0 introduced the ability to dynamically generate, mount, and remove Persistent Volume Claims, SPARK-25299 for Kubernetes workloads, which are basically volumes mounted into your Spark pods. This means Apache Spark does not have to pre-create the claims/volumes for the executors and delete it during the executor decommissioning. If a Spark executor is killed due to EC2 Spot interruption or any other failure then the PVC is not deleted but persisted and reattached to another executor. If there are shuffle files in that volume then they are reused. Previously if an external shuffle service process or node became unavailable, the executors were killed and all the shuffle blocks were lost, which needed to be recomputed. This feature is available on Amazon EMR version 6.8 and above. To setup this feature, you can add these lines to the executor configuration: \"spark.kubernetes.driver.ownPersistentVolumeClaim\" : \"true\" \"spark.kubernetes.driver.reusePersistentVolumeClaim\" : \"true One key benefit is that if any Executor running on EC2 Spot becomes unavailable, the new executor replacement can reuse the shuffle files from the PVC, avoiding recompute of the shuffle block. Dynamic PVC or persistence volume claim enables \u2018true\u2019 decoupling of data and processing when we are running Spark jobs on Kubernetes, as it can be used as a local storage to spill in-process files too. We recommend to enable PVC reuse feature because the time taken to resume the task when there is a Spot interruption is optimized as the files are used in-situ and there is no time required to move the files around. If one or more of the nodes which are running executors is interrupted the underlying pods gets deleted and the driver gets the update. Note the driver is the owner of the PVC of the executors and they are not deleted. 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 3 , action DELETED 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 6 , action MODIFIED 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 6 , action DELETED 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 3 , action MODIFIED The ExecutorPodsAllocator tries to allocate new executor pods to replace the ones killed due to interruption. During the allocation it tries to figure out how many of the existing PVC has some files and can be reused. Scaling EMR on EKS and EC2 Spot \u00b6 One of the key advantages of using Spot instances is it helps to increase the throughput of Big Data workloads at a fraction of the cost of On-Demand instances. There are spark workloads where there is a need to scale the \u2018number of executors\u2019 and the infrastructure dynamically. Scaling in a Spark process is done by spawning pod replicas and when they cannot be scheduled in the existing cluster the cluster need to be scaled up by adding more nodes. When you scale up using Spot instances you get the cost benefits of using the lowest price for EC2 Compute and thus increase the throughput of the job at a lower cost, as you can provision more compute capacity (at the same cost of On-Demand instances) to reduce the time taken to process large data sets. Dynamic Resource Allocation (DRA) enables the Spark driver to spawn the initial number of executors (pod replicas) and then scale up the number until the specified maximum number of executors is met to process the pending tasks. When the executors have no tasks running on them, they are terminated. This enables the nodes deployed in the Amazon EKS cluster to be better utilized while running multiple Spark jobs. DRA has mechanisms to dynamically adjust the resources your application occupies based on the workload. Idle executors are terminated when there are no pending tasks. This feature is available on Amazon EMR version 6.x. More details can be found here . Scaling of the infrastructure by adding more nodes can be achieved by using Cluster Autoscaler or Karpenter. Cluster Autoscaler: Cluster Autoscaler (CAS) is a Kubernetes open-source tool that automatically scale-out the size of the Kubernetes cluster when there are pending pods due to insufficient capacity on existing cluster, or scale-in when there are underutilized nodes in a cluster for extended period of time. The configuration below shows multiple Nodegroups with different vCPU and RAM configurations which adheres to the Spot best practice of diversification. Note each nodegroup has the same vCPU to memory ratio as discussed above. CAS works with EKS Managed and Self-Managed Nodegroups. Karpenter Karpenter is an open-source, flexible, high-performance auto-scaler built for Kubernetes. Karpenter automatically launches just the right compute resources to handle your cluster's applications. Karpenter observes aggregate resource requests of un-schedulable pods, computes and launches best-fit new capacity. The Provisioner CRD\u2019s configuration flexibility is very useful in adopting Spot best practices of diversification. It can include as many Spot Instance types as possible as we do not restrict specific instance types in the configuration. This approach is also future proof when AWS launches new instance types. It also manages Spot instance lifecycle management through Spot interruptions. We recommend to use Karpenter with Spot Instances as it has faster node scheduling with early pod binding and binpacking to optimize the resource utilization. An example of a Karpenter provisioner with Spot instances below. apiVersion : karpenter.sh/v1alpha5 kind : Provisioner metadata : name : default spec : labels : intent : apps requirements : - key : karpenter.sh/capacity-type operator : In values : [ \"spot\" ] - key : karpenter.k8s.aws/instance-size operator : NotIn values : [ nano , micro , small , medium , large ] limits : resources : cpu : 1000 memory : 1000Gi ttlSecondsAfterEmpty : 30 ttlSecondsUntilExpired : 2592000 providerRef : name : default EMR on EKS and EC2 Spot Instances: Best Practices \u00b6 To summarize here are our recommendations - Use EC2 Spot instances for Spark executors and On-Demand instances for drivers. - Diversify the instances types (Instance family and size) used in a cluster. - Use a single AZ to launch a cluster to save Inter-AZ data transfer cost. - Use Karpenter for capacity provisioning and scaling when running EMR on EKS jobs - If using EKS nodegroups use EKS Managed Nodegroups with Cluster Autoscaler. - If using EKS self-managed nodegroups use Capacity Optimized Allocation strategy with the nodegroup and AWS Node Termination Handler. - Use Node decommission/PVC Reuse features, they help to reduce the time taken to complete EMR on EKS jobs running on EC2 Spot. - Use Dynamic Resource Allocation, this feature is particularly useful if multiple applications share resources in your Spark cluster, and Spot helps to improve the throughput at a low cost. - Decouple Compute and Storage (S3 for Input/Output data). It allows independent scaling of processing and storage. There is low chance of losing data in case of a Spot interruption too. - Reduce Spark\u2019s Shuffle Size and Blast Radius. This allows to select more Spot instances for diversification and also reduces the time taken to recompute/move the shuffle files in case of an interruption. - Automate Spot Interruption handling using existing tools and services. Conclusion \u00b6 In this document, we covered best practices to cost effectively run EMR on EKS workloads using EC2 Spot Instances. We covered three key aspects of Provisioning, Interruption Handling and Scaling and the best practices under each of them. We hope this document provides prescriptive guidance on running EMR workload on EKS with significant cost savings by utilizing Spot instances.","title":"Cost Optimization using EC2 Spot Instances"},{"location":"cost-optimization/docs/cost-optimization/#cost-optimization-using-ec2-spot-instances","text":"","title":"Cost Optimization using EC2 Spot Instances"},{"location":"cost-optimization/docs/cost-optimization/#ec2-spot-best-practices","text":"Amazon EMR on Amazon EKS enables you to submit Apache Spark jobs on demand on Amazon Elastic Kubernetes Service (EKS) without provisioning dedicated EMR clusters. With EMR on EKS, you can consolidate analytical workloads with your other Kubernetes-based applications on the same Amazon EKS cluster to improve resource utilization and simplify infrastructure management. Cost Optimization of the underlying infrastructure is often the key requirement for our customers, and this can be achieved by using Amazon EC2 Spot Instances . Spot Instances are spare EC2 capacity and is available at up to 90% discount compared to On-Demand Instance prices. If EC2 needs capacity back for On-Demand Instance usage, Spot Instances can be interrupted. Handling interruptions to build resilient workloads is simple and there are best practices to manage interruption by automation or AWS services like EKS. This document will describe how to architect with EC2 spot best practices and apply to EMR on EKS jobs. We will also cover Spark features related to EC2 Spot when you run EMR on EKS jobs","title":"EC2 Spot Best Practices"},{"location":"cost-optimization/docs/cost-optimization/#ec2-spot-capacity-provisioning","text":"EMR on EKS runs open-source big data framework like Spark on Amazon EKS, so basically when you are run on Spot instances you are, provisioning capacity for the underlying EKS cluster. The key point to remember when you are using Spot instances is instance diversification . There are three ways that EC2 Spot capacity can be provisioned in an EKS cluster. EKS Managed Nodegroup: We highly recommend to use Managed Nodegroup for provisioning Spot instances. This requires significantly less operational effort when compared to self-managed nodegroups. The Spot instance interruption is handled proactively using the Instance Rebalancing Recommendation and Spot best practice of using Capacity Optimized Allocation strategy is adopted by default along with other useful features. If you are planning to scale your cluster then Cluster Autoscaler can be used but keep in mind, one caveat with this approach is to maintain same vCPU to memory ratio for nodes defined in a nodegroup. Karpenter: An open-source node provisioning tool for Kubernetes which works seamlessly with EMR on EKS. Karpenter can help to improve the efficiency and cost of running workloads. It provisions nodes based on pod resource requirements. The key advantage of Karpenter is flexibility not only in terms of EC2 pricing (Spot/On-Demand) but it also aligns with the Spot best practice of instance diversification, and uses capacity optimized prioritized allocation strategy; more details can be found in this workshop . Karpenter will also be useful to scale the infrastructure which will be further discussed under the scaling section below. Self-Managed Nodegroup: EMR on EKS clusters can also run on self-managed nodegroups on EKS. You need to manage the Spot instance lifecycle if there is an interruption by installing an open-source tool named AWS Node Termination Handler . AWS Node Termination Handler ensures that the Kubernetes control plane responds appropriately to events that can cause your EC2 instance to become unavailable, such as EC2 maintenance events , EC2 Spot interruptions , ASG Scale-In , ASG AZ Rebalance , and EC2 Instance Termination via the API or Console. Please remember you need to manage all the software updates manually if you plan to use this. When you are using dynamic allocation the nodegroups needs to autoscale, and if you are using cluster autoscaler then you need to maintain the vCPU to memory ratio for nodes defined in a nodegroup.","title":"EC2 Spot Capacity Provisioning"},{"location":"cost-optimization/docs/cost-optimization/#spot-interruption-and-spark","text":"EC2 Spot instances are suitable for flexible and fault tolerant workloads. Spark is a semi-resilient by design because if the executor fails, new executors are spun up by the driver to continue the job. However, if the driver fails, the entire job fails. For added resiliency, EMR of EKS retries up to 5 times for driver pods so that the k8s can find suitable host and job starts successfully. If k8s fails to find a host, job is cancelled after 15 min timeout. If driver pod fails for other reasons, job is cancelled with an error message for troubleshooting. Hence, we recommend to run Spark driver on On-Demand instances and executors on Spot instances to cost optimize the workloads. You can use PodTemplates to configure this scheduling constraint. NodeSelector can be used as the node selection constraint to run executors on Spot instances as in the example below. This is simple to use and works well with Karpenter too. The pod template for this would look like apiVersion : v1 kind : Pod spec : nodeSelector : eks.amazonaws.com/capacityType : SPOT containers : - name : spark-kubernetes-executor Node affinity can also be used here, this allows for more flexibility for the constraints defined. We recommend to use \u2018hard affinity\u2019 as highlighted in the code below for this purpose. For jobs which have strict SLA and are not suitable to run on Spot we suggest to use NoSchedule taint effect to ensure no Pods are scheduled. The key thing to note here is that the bulk of the compute required in a Spark job runs on executors and if they can be run on EC2 Spot instances you can benefit from the steep discount available with Spot instances. apiVersion : v1 kind : Pod metadata : labels : spark-role : driver namespace : emr-eks-workshop-namespace spec : affinity : nodeAffinity : requiredDuringSchedulingIgnoredDuringExecution : nodeSelectorTerms : - matchExpressions : - key : 'eks.amazonaws.com/capacityType' operator : In values : - ON_DEMAND apiVersion : v1 kind : Pod metadata : labels : spark-role : executor namespace : emr-eks-workshop-namespace spec : affinity : nodeAffinity : requiredDuringSchedulingIgnoredDuringExecution : nodeSelectorTerms : - matchExpressions : - key : 'eks.amazonaws.com/capacityType' operator : In values : - SPOT When Spot instances are interrupted the executors running on them may lose (if any) the shuffle and cached RDDs which would require re-computation. This requires more compute cycles to be spent which will impact the overall SLA of the EMR on EKS jobs. EMR on EKS has incorporated two new Spark features which can help to address these issues. In the following sections we will discuss them. Node Decommissioning: Node decommissioning is a Spark feature that enables the removal of an executor gracefully, by preserving its state before removing it and not scheduling any new jobs on it. This feature is particularly useful when the Spark executors are running on Spot instances, and the Spark executor node is interrupted via a \u2018rebalance recommendation\u2019 or \u2018instance termination\u2019 notice to reclaim the instance. Node decommission begins when a Spark executor node receives a Spot Interruption Notice or Spot Rebalance Recommendation signal. The executor node immediately starts the process of decommissioning by sending a message to the Spark driver. The driver will identify the RDD/Shuffle files that it needs to migrate off the executor node in question, and will try to identify another Executor node which can take over the execution. If an executor is identified, the RDD/Shuffle files are copied to the new executor and the job execution continues on the new executor. If all the executors are busy, the RDD/Shuffle files are copied to an external storage. The key advantage of this process is that it enables block and shuffle data of a Spark executor that receives EC2 Spot Interruption signal to be migrated, reducing the re-computation of the Spark tasks. The reduction in the re-computation for the interrupted Spark tasks improves the resiliency of the system and reduces overall execution time. We recommend to enable node decommissioning feature because it would help to reduce the overall compute cycles when there is a Spot interruption. This feature is available on Amazon EMR version 6.3 and above. To setup this feature, add this configuration to the Spark job under the executor section: \"spark.decommission.enabled\" : \"true\" \"spark.storage.decommission.rddBlocks.enabled\" : \"true\" \"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\" \"spark.storage.decommission.enabled\" : \"true\" \"spark.storage.decommission.fallbackStorage.path\" : \"s3://<<bucket>>\" The Spark executor logs sample shown below shows the process of decommission and sending message to the driver: 21 / 05 / 05 17 : 41 : 41 WARN KubernetesClusterSchedulerBackend$KubernetesDriverEndpoint : Received executor 7 decommissioned message 21 / 05 / 05 17 : 41 : 41 DEBUG TaskSetManager : Val id locality levels for TaskSet 2.0 : NO_PREF , ANY 21 / 05 / 05 17 : 41 : 41 INFO KubernetesClusterSchedulerBackend : Decommission executors : 7 21 / 05 / 05 17 : 41 : 41 DEBUG TaskSchedulerImpl : parentName : , name : TaskSet_2 .0 , run ningTasks : 10 21 / 05 / 05 17 : 41 : 41 INFO BlockManagerMasterEndpoint : Mark BlockManagers ( BlockManagerId ( 7 , 192.168.82.107 , 39007 , None )) as being decommissioning . 21 / 05 / 05 20 : 22 : 17 INFO CoarseGrainedExecutorBackend : Decommission executor 1. 21 / 05 / 05 20 : 22 : 17 INFO CoarseGrainedExecutorBackend : Will exit when finished decommissioning 21 / 05 / 05 20 : 22 : 17 INFO BlockManager : Starting block manager decommissioning process ... 21 / 05 / 05 20 : 22 : 17 DEBUG FileSystem : Looking for FS supporting s3a The Spark driver logs sample below shows the process of looking for an executor to migrate the shuffle data: 22 / 06 / 07 20 : 41 : 38 INFO ShuffleStatus : Updating map output for 46 to BlockManagerId ( 4 , 192.168.13.235 , 34737 , None ) 22 / 06 / 07 20 : 41 : 38 DEBUG BlockManagerMasterEndpoint : Received shuffle data block update for 0 46 , ignore . 22 / 06 / 07 20 : 41 : 38 DEBUG BlockManagerMasterEndpoint : Received shuffle index block update for 0 46 , updating . The Spark executor logs sample below shows the process of reusing the shuffle files: 22 / 06 / 07 20 : 42 : 50 INFO BasicExecutorFeatureStep : Adding decommission script to lifecycle 22 / 06 / 07 20 : 42 : 50 DEBUG ExecutorPodsAllocator : Requested executor with id 19 from Kubernetes . 22 / 06 / 07 20 : 42 : 50 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - bfd0a5813fd1b80f - exec - 19 , action ADDED 22 / 06 / 07 20 : 42 : 50 DEBUG BlockManagerMasterEndpoint : Received shuffle index block update for 0 52 , updating . 22 / 06 / 07 20 : 42 : 50 INFO ShuffleStatus : Recover 52 BlockManagerId ( fallback , remote, 7337, None) More details on this can be found here PVC Reuse: A PersistentVolume is a Kubernetes feature to provide persistent storage to container Pods running stateful workloads, and PersistentVolumeClaim (PVC) is to request the above storage in the container Pod for storage by a user. Apache Spark 3.1.0 introduced the ability to dynamically generate, mount, and remove Persistent Volume Claims, SPARK-25299 for Kubernetes workloads, which are basically volumes mounted into your Spark pods. This means Apache Spark does not have to pre-create the claims/volumes for the executors and delete it during the executor decommissioning. If a Spark executor is killed due to EC2 Spot interruption or any other failure then the PVC is not deleted but persisted and reattached to another executor. If there are shuffle files in that volume then they are reused. Previously if an external shuffle service process or node became unavailable, the executors were killed and all the shuffle blocks were lost, which needed to be recomputed. This feature is available on Amazon EMR version 6.8 and above. To setup this feature, you can add these lines to the executor configuration: \"spark.kubernetes.driver.ownPersistentVolumeClaim\" : \"true\" \"spark.kubernetes.driver.reusePersistentVolumeClaim\" : \"true One key benefit is that if any Executor running on EC2 Spot becomes unavailable, the new executor replacement can reuse the shuffle files from the PVC, avoiding recompute of the shuffle block. Dynamic PVC or persistence volume claim enables \u2018true\u2019 decoupling of data and processing when we are running Spark jobs on Kubernetes, as it can be used as a local storage to spill in-process files too. We recommend to enable PVC reuse feature because the time taken to resume the task when there is a Spot interruption is optimized as the files are used in-situ and there is no time required to move the files around. If one or more of the nodes which are running executors is interrupted the underlying pods gets deleted and the driver gets the update. Note the driver is the owner of the PVC of the executors and they are not deleted. 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 3 , action DELETED 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 6 , action MODIFIED 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 6 , action DELETED 22 / 06 / 15 23 : 25 : 07 DEBUG ExecutorPodsWatchSnapshotSource : Received executor pod update for pod named amazon - reviews - word - count - 9 ee82b8169a75183 - exec - 3 , action MODIFIED The ExecutorPodsAllocator tries to allocate new executor pods to replace the ones killed due to interruption. During the allocation it tries to figure out how many of the existing PVC has some files and can be reused.","title":"Spot Interruption and Spark"},{"location":"cost-optimization/docs/cost-optimization/#scaling-emr-on-eks-and-ec2-spot","text":"One of the key advantages of using Spot instances is it helps to increase the throughput of Big Data workloads at a fraction of the cost of On-Demand instances. There are spark workloads where there is a need to scale the \u2018number of executors\u2019 and the infrastructure dynamically. Scaling in a Spark process is done by spawning pod replicas and when they cannot be scheduled in the existing cluster the cluster need to be scaled up by adding more nodes. When you scale up using Spot instances you get the cost benefits of using the lowest price for EC2 Compute and thus increase the throughput of the job at a lower cost, as you can provision more compute capacity (at the same cost of On-Demand instances) to reduce the time taken to process large data sets. Dynamic Resource Allocation (DRA) enables the Spark driver to spawn the initial number of executors (pod replicas) and then scale up the number until the specified maximum number of executors is met to process the pending tasks. When the executors have no tasks running on them, they are terminated. This enables the nodes deployed in the Amazon EKS cluster to be better utilized while running multiple Spark jobs. DRA has mechanisms to dynamically adjust the resources your application occupies based on the workload. Idle executors are terminated when there are no pending tasks. This feature is available on Amazon EMR version 6.x. More details can be found here . Scaling of the infrastructure by adding more nodes can be achieved by using Cluster Autoscaler or Karpenter. Cluster Autoscaler: Cluster Autoscaler (CAS) is a Kubernetes open-source tool that automatically scale-out the size of the Kubernetes cluster when there are pending pods due to insufficient capacity on existing cluster, or scale-in when there are underutilized nodes in a cluster for extended period of time. The configuration below shows multiple Nodegroups with different vCPU and RAM configurations which adheres to the Spot best practice of diversification. Note each nodegroup has the same vCPU to memory ratio as discussed above. CAS works with EKS Managed and Self-Managed Nodegroups. Karpenter Karpenter is an open-source, flexible, high-performance auto-scaler built for Kubernetes. Karpenter automatically launches just the right compute resources to handle your cluster's applications. Karpenter observes aggregate resource requests of un-schedulable pods, computes and launches best-fit new capacity. The Provisioner CRD\u2019s configuration flexibility is very useful in adopting Spot best practices of diversification. It can include as many Spot Instance types as possible as we do not restrict specific instance types in the configuration. This approach is also future proof when AWS launches new instance types. It also manages Spot instance lifecycle management through Spot interruptions. We recommend to use Karpenter with Spot Instances as it has faster node scheduling with early pod binding and binpacking to optimize the resource utilization. An example of a Karpenter provisioner with Spot instances below. apiVersion : karpenter.sh/v1alpha5 kind : Provisioner metadata : name : default spec : labels : intent : apps requirements : - key : karpenter.sh/capacity-type operator : In values : [ \"spot\" ] - key : karpenter.k8s.aws/instance-size operator : NotIn values : [ nano , micro , small , medium , large ] limits : resources : cpu : 1000 memory : 1000Gi ttlSecondsAfterEmpty : 30 ttlSecondsUntilExpired : 2592000 providerRef : name : default","title":"Scaling EMR on EKS and EC2 Spot"},{"location":"cost-optimization/docs/cost-optimization/#emr-on-eks-and-ec2-spot-instances-best-practices","text":"To summarize here are our recommendations - Use EC2 Spot instances for Spark executors and On-Demand instances for drivers. - Diversify the instances types (Instance family and size) used in a cluster. - Use a single AZ to launch a cluster to save Inter-AZ data transfer cost. - Use Karpenter for capacity provisioning and scaling when running EMR on EKS jobs - If using EKS nodegroups use EKS Managed Nodegroups with Cluster Autoscaler. - If using EKS self-managed nodegroups use Capacity Optimized Allocation strategy with the nodegroup and AWS Node Termination Handler. - Use Node decommission/PVC Reuse features, they help to reduce the time taken to complete EMR on EKS jobs running on EC2 Spot. - Use Dynamic Resource Allocation, this feature is particularly useful if multiple applications share resources in your Spark cluster, and Spot helps to improve the throughput at a low cost. - Decouple Compute and Storage (S3 for Input/Output data). It allows independent scaling of processing and storage. There is low chance of losing data in case of a Spot interruption too. - Reduce Spark\u2019s Shuffle Size and Blast Radius. This allows to select more Spot instances for diversification and also reduces the time taken to recompute/move the shuffle files in case of an interruption. - Automate Spot Interruption handling using existing tools and services.","title":"EMR on EKS and EC2 Spot Instances: Best Practices"},{"location":"cost-optimization/docs/cost-optimization/#conclusion","text":"In this document, we covered best practices to cost effectively run EMR on EKS workloads using EC2 Spot Instances. We covered three key aspects of Provisioning, Interruption Handling and Scaling and the best practices under each of them. We hope this document provides prescriptive guidance on running EMR workload on EKS with significant cost savings by utilizing Spot instances.","title":"Conclusion"},{"location":"cost-optimization/docs/node-decommission/","text":"Node Decommission \u00b6 This section shows how to use a Apache Spark feature that allows you to store the shuffle data and cached RDD blocks present on the terminating executors to peer executors before a Spot node gets decommissioned. Consequently, your job does not need to recalculate the shuffle and RDD blocks of the terminating executor that would otherwise be lost, thus allowing the job to have minimal delay in completion. This feature is supported for releases EMR 6.3.0+. How does it work? \u00b6 When spark.decommission.enabled is true, Spark will try its best to shutdown the executor gracefully. spark.storage.decommission.enabled will enable migrating data stored on the executor. Spark will try to migrate all the cached RDD blocks (controlled by spark.storage.decommission.rddBlocks.enabled ) and shuffle blocks ( controlled by spark.storage.decommission.shuffleBlocks.enabled ) from the decommissioning executor to all remote executors when spark decommission is enabled. Relevant Spark configurations for using node decommissioning in the jobs are Configuration Description Default Value spark.decommission.enabled Whether to enable decommissioning false spark.storage.decommission.enabled Whether to decommission the block manager when decommissioning executor false spark.storage.decommission.rddBlocks.enabled Whether to transfer RDD blocks during block manager decommissioning. false spark.storage.decommission.shuffleBlocks.enabled Whether to transfer shuffle blocks during block manager decommissioning. Requires a migratable shuffle resolver (like sort based shuffle) false spark.storage.decommission.maxReplicationFailuresPerBlock Maximum number of failures which can be handled for migrating shuffle blocks when block manager is decommissioning and trying to move its existing blocks. 3 spark.storage.decommission.shuffleBlocks.maxThreads Maximum number of threads to use in migrating shuffle files. 8 This feature can currently be enabled through a temporary workaround on EMR 6.3.0+ releases. To enable it, Spark\u2019s decom.sh file permission must be modified using a custom image . Once the code is fixed, the page will be updated. Dockerfile for custom image: FROM < release account id > . dkr . ecr . < aws region > . amazonaws . com / spark /< release > USER root WORKDIR / home / hadoop RUN chown hadoop: hadoop / usr / bin / decom . sh Setting decommission timeout: Each executor has to be decommissioned within a certain time limit controlled by the pod\u2019s terminationGracePeriodSeconds configuration. The default value is 30 secs but can be modified using a custom pod template . The pod template for this modification would look like apiVersion : v1 kind : Pod spec : terminationGracePeriodSeconds : < seconds > Note: terminationGracePeriodSeconds timeout should be lesser than spot instance timeout with around 5 seconds buffer kept aside for triggering the node termination Request: cat > spark - python - with - node - decommissioning . json << EOF { \"name\" : \"my-job-run-with-node-decommissioning\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.3.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.container.image\" : \"<account_id>.dkr.ecr.<region>.amazonaws.com/<custom_image_repo>\" , \"spark.executor.instances\" : \"5\" , \"spark.decommission.enabled\" : \"true\" , \"spark.storage.decommission.rddBlocks.enabled\" : \"true\" , \"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\" , \"spark.storage.decommission.enabled\" : \"true\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"<log group>\" , \"logStreamNamePrefix\" : \"<log-group-prefix>\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"<S3 URI>\" } } } } EOF Observed Behavior: When executors begin decommissioning, its shuffle data gets migrated to peer executors instead of recalculating the shuffle blocks again. If sending shuffle blocks to an executor fails, spark.storage.decommission.maxReplicationFailuresPerBlock will give the number of retries for migration. The driver log\u2019s stderr will see log lines Updating map output for <shuffle_id> to BlockManagerId(<executor_id>, <ip_address>, <port>, <topology_info>) denoting details about shuffle block \u2018s migration. This feature does not emit any other metrics for validation as of yet.","title":"Node Decommission"},{"location":"cost-optimization/docs/node-decommission/#node-decommission","text":"This section shows how to use a Apache Spark feature that allows you to store the shuffle data and cached RDD blocks present on the terminating executors to peer executors before a Spot node gets decommissioned. Consequently, your job does not need to recalculate the shuffle and RDD blocks of the terminating executor that would otherwise be lost, thus allowing the job to have minimal delay in completion. This feature is supported for releases EMR 6.3.0+.","title":"Node Decommission"},{"location":"cost-optimization/docs/node-decommission/#how-does-it-work","text":"When spark.decommission.enabled is true, Spark will try its best to shutdown the executor gracefully. spark.storage.decommission.enabled will enable migrating data stored on the executor. Spark will try to migrate all the cached RDD blocks (controlled by spark.storage.decommission.rddBlocks.enabled ) and shuffle blocks ( controlled by spark.storage.decommission.shuffleBlocks.enabled ) from the decommissioning executor to all remote executors when spark decommission is enabled. Relevant Spark configurations for using node decommissioning in the jobs are Configuration Description Default Value spark.decommission.enabled Whether to enable decommissioning false spark.storage.decommission.enabled Whether to decommission the block manager when decommissioning executor false spark.storage.decommission.rddBlocks.enabled Whether to transfer RDD blocks during block manager decommissioning. false spark.storage.decommission.shuffleBlocks.enabled Whether to transfer shuffle blocks during block manager decommissioning. Requires a migratable shuffle resolver (like sort based shuffle) false spark.storage.decommission.maxReplicationFailuresPerBlock Maximum number of failures which can be handled for migrating shuffle blocks when block manager is decommissioning and trying to move its existing blocks. 3 spark.storage.decommission.shuffleBlocks.maxThreads Maximum number of threads to use in migrating shuffle files. 8 This feature can currently be enabled through a temporary workaround on EMR 6.3.0+ releases. To enable it, Spark\u2019s decom.sh file permission must be modified using a custom image . Once the code is fixed, the page will be updated. Dockerfile for custom image: FROM < release account id > . dkr . ecr . < aws region > . amazonaws . com / spark /< release > USER root WORKDIR / home / hadoop RUN chown hadoop: hadoop / usr / bin / decom . sh Setting decommission timeout: Each executor has to be decommissioned within a certain time limit controlled by the pod\u2019s terminationGracePeriodSeconds configuration. The default value is 30 secs but can be modified using a custom pod template . The pod template for this modification would look like apiVersion : v1 kind : Pod spec : terminationGracePeriodSeconds : < seconds > Note: terminationGracePeriodSeconds timeout should be lesser than spot instance timeout with around 5 seconds buffer kept aside for triggering the node termination Request: cat > spark - python - with - node - decommissioning . json << EOF { \"name\" : \"my-job-run-with-node-decommissioning\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.3.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.container.image\" : \"<account_id>.dkr.ecr.<region>.amazonaws.com/<custom_image_repo>\" , \"spark.executor.instances\" : \"5\" , \"spark.decommission.enabled\" : \"true\" , \"spark.storage.decommission.rddBlocks.enabled\" : \"true\" , \"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\" , \"spark.storage.decommission.enabled\" : \"true\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"<log group>\" , \"logStreamNamePrefix\" : \"<log-group-prefix>\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"<S3 URI>\" } } } } EOF Observed Behavior: When executors begin decommissioning, its shuffle data gets migrated to peer executors instead of recalculating the shuffle blocks again. If sending shuffle blocks to an executor fails, spark.storage.decommission.maxReplicationFailuresPerBlock will give the number of retries for migration. The driver log\u2019s stderr will see log lines Updating map output for <shuffle_id> to BlockManagerId(<executor_id>, <ip_address>, <port>, <topology_info>) denoting details about shuffle block \u2018s migration. This feature does not emit any other metrics for validation as of yet.","title":"How does it work?"},{"location":"debugging/docs/","text":"","title":"Index"},{"location":"debugging/docs/change-log-level/","text":"Change Log level for Spark application on EMR on EKS \u00b6 To obtain more detail about their application or job submission, Spark application developers can change the log level of their job to different levels depending on their requirements. Spark uses apache log4j for logging. Change log level to DEBUG \u00b6 Using EMR classification \u00b6 Log level of spark applications can be changed using the EMR spark-log4j configuration classification. Request The pi.py application script is from the spark examples . EMR on EKS has included the example located at /usr/lib/spark/examples/src/main for you to try. spark-log4j classification can be used to configure values in log4j.properties for EMR releases 6.7.0 or lower , and log4j2.properties for EMR releases 6.8.0+ . cat > Spark-Python-in-s3-debug-log.json << EOF { \"name\": \"spark-python-in-s3-debug-log-classification\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"local:///usr/lib/spark/examples/src/main/python/pi.py\", \"entryPointArguments\": [ \"200\" ], \"sparkSubmitParameters\": \"--conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.memory=2G --conf spark.executor.instances=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"spark-log4j\", \"properties\": { \"log4j.rootCategory\":\"DEBUG, console\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json The above request will print DEBUG logs in the spark driver and executor containers. The generated logs will be pushed to S3 and AWS Cloudwatch logs as configured in the request. Starting from the version 3.3.0, Spark has been migrated from log4j1 to log4j2 . EMR on EKS allows you still write the log4j properties to the same \"classification\": \"spark-log4j\" , however it now needs to be log4j2.properties, such as { \"classification\": \"spark-log4j\", \"properties\": { \"rootLogger.level\" : \"DEBUG\" } } Custom log4j properties \u00b6 Download log4j properties from here . Edit log4j.properties with log level as required. Save the edited log4j.properties in a mounted volume. In this example log4j.properties is placed in a s3 bucket that is mapped to a FSx for Lustre filesystem . Request pi.py used in the below request payload is from spark examples cat > Spark - Python - in - s3 - debug - log . json << EOF { \"name\" : \"spark-python-in-s3-debug-log\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - s3 - debug - log . json Configurations of interest: Below configuration enables spark driver and executor to pickup the log4j configuration file from /var/data/ folder mounted to the driver and executor containers. For guide to mount FSx for Lustre to driver and executor containers - refer to EMR Containers integration with FSx for Lustre \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" ,","title":"Change Log Level"},{"location":"debugging/docs/change-log-level/#change-log-level-for-spark-application-on-emr-on-eks","text":"To obtain more detail about their application or job submission, Spark application developers can change the log level of their job to different levels depending on their requirements. Spark uses apache log4j for logging.","title":"Change Log level for Spark application on EMR on EKS"},{"location":"debugging/docs/change-log-level/#change-log-level-to-debug","text":"","title":"Change log level to DEBUG"},{"location":"debugging/docs/change-log-level/#using-emr-classification","text":"Log level of spark applications can be changed using the EMR spark-log4j configuration classification. Request The pi.py application script is from the spark examples . EMR on EKS has included the example located at /usr/lib/spark/examples/src/main for you to try. spark-log4j classification can be used to configure values in log4j.properties for EMR releases 6.7.0 or lower , and log4j2.properties for EMR releases 6.8.0+ . cat > Spark-Python-in-s3-debug-log.json << EOF { \"name\": \"spark-python-in-s3-debug-log-classification\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"local:///usr/lib/spark/examples/src/main/python/pi.py\", \"entryPointArguments\": [ \"200\" ], \"sparkSubmitParameters\": \"--conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.memory=2G --conf spark.executor.instances=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"spark-log4j\", \"properties\": { \"log4j.rootCategory\":\"DEBUG, console\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json The above request will print DEBUG logs in the spark driver and executor containers. The generated logs will be pushed to S3 and AWS Cloudwatch logs as configured in the request. Starting from the version 3.3.0, Spark has been migrated from log4j1 to log4j2 . EMR on EKS allows you still write the log4j properties to the same \"classification\": \"spark-log4j\" , however it now needs to be log4j2.properties, such as { \"classification\": \"spark-log4j\", \"properties\": { \"rootLogger.level\" : \"DEBUG\" } }","title":"Using EMR classification"},{"location":"debugging/docs/change-log-level/#custom-log4j-properties","text":"Download log4j properties from here . Edit log4j.properties with log level as required. Save the edited log4j.properties in a mounted volume. In this example log4j.properties is placed in a s3 bucket that is mapped to a FSx for Lustre filesystem . Request pi.py used in the below request payload is from spark examples cat > Spark - Python - in - s3 - debug - log . json << EOF { \"name\" : \"spark-python-in-s3-debug-log\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - s3 - debug - log . json Configurations of interest: Below configuration enables spark driver and executor to pickup the log4j configuration file from /var/data/ folder mounted to the driver and executor containers. For guide to mount FSx for Lustre to driver and executor containers - refer to EMR Containers integration with FSx for Lustre \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" ,","title":"Custom log4j properties"},{"location":"debugging/docs/connect-spark-ui/","text":"Connect to Spark UI running on the Driver Pod \u00b6 To obtain more detail about their application or monitor their job execution, Spark application developers can connect to Spark-UI running on the Driver Pod. Spark UI (Spark history server) is packaged with EMR on EKS out of the box. Alternatively, if you want to see Spark UI immediately after the driver is spun up, you can use the instructions in this page to connect. This page shows how to use kubectl port-forward to connect to the Job's Driver Pod running in a Kubernetes cluster. This type of connection is useful for debugging purposes. Pre-Requisites AWS cli should be installed \"kubectl\" should be installed If this is the first time you are connecting to your EKS cluster from your machine, you should run aws eks update-kubeconfig --name --region to download kubeconfig file and use correct context to talk to API server. Submitting the job to a virtual cluster \u00b6 Request cat >spark-python.json << EOF { \"name\": \"spark-python-in-s3\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=4 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python.json Once the job is submitted successfully, run kubectl get pods -n <virtual-cluster-k8s-namespace> -w command to watch all the pods, until you observe the driver pod is in the \"Running\" state. The Driver pod's name usually is in spark-<job-id>-driver format. Connecting to the Driver Pod \u00b6 Spark Driver Pod hosts Spark-UI on port 4040 . However the pod runs within the internal Kubernetes network. To get access to the internal Kubernetes resources, kubectl provides a tool (\"Port Forwarding\") that allows access from your localhost. To get access to the driver pod in your cluster: 1- Run kubectl port-forward <driver-pod-name> 4040:4040 The result should be the following: Forwarding from 127.0.0.1 : 28015 -> 27017 Forwarding from [ :: 1 ] : 28015 -> 27017 2- Open a browser and type http://localhost:4040 in the Address bar. You should be able to connect to the Spark UI:","title":"Connect to Spark UI"},{"location":"debugging/docs/connect-spark-ui/#connect-to-spark-ui-running-on-the-driver-pod","text":"To obtain more detail about their application or monitor their job execution, Spark application developers can connect to Spark-UI running on the Driver Pod. Spark UI (Spark history server) is packaged with EMR on EKS out of the box. Alternatively, if you want to see Spark UI immediately after the driver is spun up, you can use the instructions in this page to connect. This page shows how to use kubectl port-forward to connect to the Job's Driver Pod running in a Kubernetes cluster. This type of connection is useful for debugging purposes. Pre-Requisites AWS cli should be installed \"kubectl\" should be installed If this is the first time you are connecting to your EKS cluster from your machine, you should run aws eks update-kubeconfig --name --region to download kubeconfig file and use correct context to talk to API server.","title":"Connect to Spark UI running on the Driver Pod"},{"location":"debugging/docs/connect-spark-ui/#submitting-the-job-to-a-virtual-cluster","text":"Request cat >spark-python.json << EOF { \"name\": \"spark-python-in-s3\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=4 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python.json Once the job is submitted successfully, run kubectl get pods -n <virtual-cluster-k8s-namespace> -w command to watch all the pods, until you observe the driver pod is in the \"Running\" state. The Driver pod's name usually is in spark-<job-id>-driver format.","title":"Submitting the job to a virtual cluster"},{"location":"debugging/docs/connect-spark-ui/#connecting-to-the-driver-pod","text":"Spark Driver Pod hosts Spark-UI on port 4040 . However the pod runs within the internal Kubernetes network. To get access to the internal Kubernetes resources, kubectl provides a tool (\"Port Forwarding\") that allows access from your localhost. To get access to the driver pod in your cluster: 1- Run kubectl port-forward <driver-pod-name> 4040:4040 The result should be the following: Forwarding from 127.0.0.1 : 28015 -> 27017 Forwarding from [ :: 1 ] : 28015 -> 27017 2- Open a browser and type http://localhost:4040 in the Address bar. You should be able to connect to the Spark UI:","title":"Connecting to the Driver Pod"},{"location":"debugging/docs/self-hosted-shs/","text":"Self Hosted Spark History Server \u00b6 In this section, you will learn how to self host Spark History Server instead of using the Persistent App UI on the AWS Console. In your StartJobRun call for EMR on EKS, set the following conf. to point to an S3 bucket where you would like your event logs to go : spark.eventLog.dir and spark.eventLog.enabled as such: \"configurationOverrides\": { \"applicationConfiguration\": [{ \"classification\": \"spark-defaults\", \"properties\": { \"spark.eventLog.enabled\": \"true\", \"spark.eventLog.dir\": \"s3://your-bucket-here/some-directory\" ... Take note of the S3 bucket specified in #1, and use it in the instructions on step #3 wherever you are asked for path_to_eventlog and make sure it is prepended with s3a:// , not s3:// . An example is -Dspark.history.fs.logDirectory=s3a://path_to_eventlog . Follow instructions here to launch Spark History Server using a Docker image. After following the above steps, event logs should flow to the specified S3 bucket and the docker container should spin up Spark History Server (which will be available at 127.0.0.1:18080 ). This instance of Spark History Server will pick up and parse event logs from the S3 bucket specified.","title":"Self Hosted SHS"},{"location":"debugging/docs/self-hosted-shs/#self-hosted-spark-history-server","text":"In this section, you will learn how to self host Spark History Server instead of using the Persistent App UI on the AWS Console. In your StartJobRun call for EMR on EKS, set the following conf. to point to an S3 bucket where you would like your event logs to go : spark.eventLog.dir and spark.eventLog.enabled as such: \"configurationOverrides\": { \"applicationConfiguration\": [{ \"classification\": \"spark-defaults\", \"properties\": { \"spark.eventLog.enabled\": \"true\", \"spark.eventLog.dir\": \"s3://your-bucket-here/some-directory\" ... Take note of the S3 bucket specified in #1, and use it in the instructions on step #3 wherever you are asked for path_to_eventlog and make sure it is prepended with s3a:// , not s3:// . An example is -Dspark.history.fs.logDirectory=s3a://path_to_eventlog . Follow instructions here to launch Spark History Server using a Docker image. After following the above steps, event logs should flow to the specified S3 bucket and the docker container should spin up Spark History Server (which will be available at 127.0.0.1:18080 ). This instance of Spark History Server will pick up and parse event logs from the S3 bucket specified.","title":"Self Hosted Spark History Server"},{"location":"metastore-integrations/docs/","text":"","title":"Index"},{"location":"metastore-integrations/docs/aws-glue/","text":"EMR Containers integration with AWS Glue \u00b6 AWS Glue catalog in same account as EKS \u00b6 In the below example a Spark application will be configured to use AWS Glue data catalog as the hive metastore. gluequery.py cat > gluequery . py << EOF from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . appName ( \"Python Spark SQL Hive integration example\" ) \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"CREATE EXTERNAL TABLE `sparkemrnyc`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/trip-data.parquet/'\" ) spark . sql ( \"SELECT count(*) FROM sparkemrnyc\" ) . show () spark . stop () EOF LOCATION 's3://<s3 prefix>/trip-data.parquet/' Configure the above property to point to the S3 location containing the data. Request cat > Spark-Python-in-s3-awsglue-log.json << EOF { \"name\": \"spark-python-in-s3-awsglue-log\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-log.json Output from driver logs - Displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+ AWS Glue catalog in different account \u00b6 The Spark application is submitted to EMR Virtual cluster in Account A and is configured to connect to AWS Glue catalog in Account B. The IAM policy attached to the job execution role (\"executionRoleArn\": \"<execution-role-arn>\") is in Account A { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"glue:*\" ], \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } IAM policy attached to the AWS Glue catalog in Account B { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"<execution-role-arn>\" }, \"Action\" : \"glue:*\" , \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } Request cat > Spark-Python-in-s3-awsglue-crossaccount.json << EOF { \"name\": \"spark-python-in-s3-awsglue-crossaccount\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-crossaccount.json Configuration of interest To specify the accountID where the AWS Glue catalog is defined reference the following: Spark-Glue integration \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", Output from driver logs - displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+ Sync Hudi table with AWS Glue catalog \u00b6 In this example, a Spark application will be configured to use AWS Glue data catalog as the hive metastore. Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Glue catalog via the Hive Metastore Service (HMS) in hive sync mode. This example runs a Hudi ETL job with EMR on EKS, and interact with AWS Glue metaStore to create a Hudi table. It provides you the native and serverless capabilities to manage your technical metadata. Also you can query Hudi tables in Athena straigt away after the ETL job, which provides your end user an easy data access and shortens the time to insight. HudiEMRonEKS.py cat > HudiEMRonEKS . py << EOF import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) EOF NOTE: configure the warehouse dir property to point to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environament vairable. .config ( \"spark.sql.warehouse.dir\" , sys.argv [ 1 ] + \"/warehouse/\" ) Request export S3BUCKET = YOUR_S3_BUCKET_NAME aws emr - containers start - job - run \\ -- virtual - cluster - id $ VIRTUAL_CLUSTER_ID \\ -- name hudi - test1 \\ -- execution - role - arn $ EMR_ROLE_ARN \\ -- release - label emr - 6.3 . 0 - latest \\ -- job - driver '{ \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\" , \"entryPointArguments\" :[ \"s3://'$S3BUCKET'\" ], \"sparkSubmitParameters\" : \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\" }} ' \\ --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.serializer\" : \"org.apache.spark.serializer.KryoSerializer\" , \"spark.sql.hive.convertMetastoreParquet\" : \"false\" , \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" }} ], \"monitoringConfiguration\" : { \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\" }}} ' NOTE: To get a correct verison of hudi library, we directly download the jar from the maven repository with the synctax of \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar . Starting from EMR 6.5, the Hudi-spark3-bundle library will be included in EMR docker images.","title":"AWS Glue"},{"location":"metastore-integrations/docs/aws-glue/#emr-containers-integration-with-aws-glue","text":"","title":"EMR Containers integration with AWS Glue"},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-same-account-as-eks","text":"In the below example a Spark application will be configured to use AWS Glue data catalog as the hive metastore. gluequery.py cat > gluequery . py << EOF from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . appName ( \"Python Spark SQL Hive integration example\" ) \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"CREATE EXTERNAL TABLE `sparkemrnyc`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/trip-data.parquet/'\" ) spark . sql ( \"SELECT count(*) FROM sparkemrnyc\" ) . show () spark . stop () EOF LOCATION 's3://<s3 prefix>/trip-data.parquet/' Configure the above property to point to the S3 location containing the data. Request cat > Spark-Python-in-s3-awsglue-log.json << EOF { \"name\": \"spark-python-in-s3-awsglue-log\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-log.json Output from driver logs - Displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+","title":"AWS Glue catalog in same account as EKS"},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-different-account","text":"The Spark application is submitted to EMR Virtual cluster in Account A and is configured to connect to AWS Glue catalog in Account B. The IAM policy attached to the job execution role (\"executionRoleArn\": \"<execution-role-arn>\") is in Account A { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"glue:*\" ], \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } IAM policy attached to the AWS Glue catalog in Account B { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"<execution-role-arn>\" }, \"Action\" : \"glue:*\" , \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } Request cat > Spark-Python-in-s3-awsglue-crossaccount.json << EOF { \"name\": \"spark-python-in-s3-awsglue-crossaccount\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-crossaccount.json Configuration of interest To specify the accountID where the AWS Glue catalog is defined reference the following: Spark-Glue integration \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", Output from driver logs - displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+","title":"AWS Glue catalog in different account"},{"location":"metastore-integrations/docs/aws-glue/#sync-hudi-table-with-aws-glue-catalog","text":"In this example, a Spark application will be configured to use AWS Glue data catalog as the hive metastore. Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Glue catalog via the Hive Metastore Service (HMS) in hive sync mode. This example runs a Hudi ETL job with EMR on EKS, and interact with AWS Glue metaStore to create a Hudi table. It provides you the native and serverless capabilities to manage your technical metadata. Also you can query Hudi tables in Athena straigt away after the ETL job, which provides your end user an easy data access and shortens the time to insight. HudiEMRonEKS.py cat > HudiEMRonEKS . py << EOF import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) EOF NOTE: configure the warehouse dir property to point to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environament vairable. .config ( \"spark.sql.warehouse.dir\" , sys.argv [ 1 ] + \"/warehouse/\" ) Request export S3BUCKET = YOUR_S3_BUCKET_NAME aws emr - containers start - job - run \\ -- virtual - cluster - id $ VIRTUAL_CLUSTER_ID \\ -- name hudi - test1 \\ -- execution - role - arn $ EMR_ROLE_ARN \\ -- release - label emr - 6.3 . 0 - latest \\ -- job - driver '{ \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\" , \"entryPointArguments\" :[ \"s3://'$S3BUCKET'\" ], \"sparkSubmitParameters\" : \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\" }} ' \\ --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.serializer\" : \"org.apache.spark.serializer.KryoSerializer\" , \"spark.sql.hive.convertMetastoreParquet\" : \"false\" , \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" }} ], \"monitoringConfiguration\" : { \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\" }}} ' NOTE: To get a correct verison of hudi library, we directly download the jar from the maven repository with the synctax of \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar . Starting from EMR 6.5, the Hudi-spark3-bundle library will be included in EMR docker images.","title":"Sync Hudi table with AWS Glue catalog"},{"location":"metastore-integrations/docs/hive-metastore/","text":"EMR Containers integration with Hive Metastore \u00b6 For more details, check out the github repository , which includes CDK/CFN templates that help you to get started quickly. 1-Hive metastore Database through JDBC \u00b6 In this example, a Spark application is configured to connect to a Hive Metastore database provisioned with Amazon RDS Aurora MySql via a JDBC connection. The Amazon RDS and EKS cluster should be in same VPC or else the Spark job will not be able to connect to RDS. You directly pass in the JDBC credentials at the job/application level, which is a simple and quick solution to make a connection to the HMS. However, it is not recommended in a production environment. From the security perspective, the password management could be a risk since the JDBC credentials will appear in all of your job logs. Also engineers may be required to hold the password when it is not necessary. Request: cat > Spark-Python-in-s3-hms-jdbc.json << EOF { \"name\": \"spark-python-in-s3-hms-jdbc\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/hivejdbc.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL=<JDBC-Connection-string> --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-jdbc.json In this example we are connecting to mysql db, so mariadb-connector-java.jar needs to be passed with --jars option. If you are using postgres, Oracle or any other database, the appropriate connector jar needs to be included. Configuration of interest: --jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL**=<JDBC-Connection-string> hivejdbc.py from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE `ehmsdb`.`sparkemrnyc5`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT count(*) FROM ehmsdb.sparkemrnyc5 \" ) . show () spark . stop () The above job lists databases from a remote RDS Hive Metastore, creates a new table and then queries it. 2-Hive metastore thrift service through thrift:// protocol \u00b6 In this example, the spark application is configured to connect to an external Hive metastore thrift server. The thrift server is running on EMR on EC2's master node and AWS RDS Aurora is used as database for the Hive metastore. Running an EMR on EC2 cluster as a thrift server, simplify the application configuration and setup. You can start quickly with reduced engineering effort. However, your maintenance overhead may increase, since you will be monitoring two types of clusters, i.e. EMR on EC2 and EMR on EKS. thriftscript.py: hive.metastore.uris config needs to be set to read from external Hive metastore. The URI format looks like this: thrift://EMR_ON_EC2_MASTER_NODE_DNS_NAME:9083 from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . config ( \"hive.metastore.uris\" , \"<hive metastore thrift uri>\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE ehmsdb.`sparkemrnyc2`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT * FROM ehmsdb.sparkemrnyc2\" ) . show () spark . stop () Request: The below job lists databases from remote Hive Metastore, creates a new table and then queries it. cat > Spark-Python-in-s3-hms-thrift.json << EOF { \"name\": \"spark-python-in-s3-hms-thrift\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/thriftscript.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-thrift.json 3-Connect Hive metastore via thrift service hosted on EKS \u00b6 In this example, our Spark application connects to a standalone Hive metastore service (HMS) running in EKS. Running the standalone HMS in EKS unifies your analytics applications with other business critical apps in a single platform. It simplifies your solution architecture and infrastructure design. The helm chart solution includes autoscaling feature, so your EKS cluster can automatically expand or shrink when the HMS request volume changes. Also it follows the security best practice to manage JDBC credentials via AWS Secrets Manager. However, you will need a combination of analytics and k8s skills to maintain this solution. To install the HMS helm chart , simply replace the environment variables in values.yaml, then manually helm install via the command below. Otherwise, deploy the HMS via a CDK/CFN template with a security best practice. Check out the CDK project for more details. cd hive-emr-on-eks/hive-metastore-chart sed -i '' -e 's/{RDS_JDBC_URL}/\"jdbc:mysql:\\/\\/' $YOUR_HOST_NAME ':3306\\/' $YOUR_DB_NAME '?createDatabaseIfNotExist=true\"/g' values.yaml sed -i '' -e 's/{RDS_USERNAME}/' $YOUR_USER_NAME '/g' values.yaml sed -i '' -e 's/{RDS_PASSWORD}/' $YOUR_PASSWORD '/g' values.yaml sed -i '' -e 's/{S3BUCKET}/s3:\\/\\/' $YOUR_S3BUCKET '/g' values.yaml helm repo add hive-metastore https://aws-samples.github.io/hive-metastore-chart helm install hive hive-metastore/hive-metastore -f values.yaml --namespace = emr --debug hivethrift_eks.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . config ( \"hive.metastore.uris\" , \"thrift://\" + environ [ 'HIVE_METASTORE_SERVICE_HOST' ] + \":9083\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview3\" ) spark . sql ( \"CREATE EXTERNAL TABLE IF NOT EXISTS `demo`.`amazonreview3`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview3\" ) . show () spark . stop () An environment variable HIVE_METASTORE_SERVICE_HOST appears in your Spark application pods automatically, once the standalone HMS is up running in EKS. You can directly set the hive.metastore.uris to thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\" . Can set the spark.sql.warehouse.dir property to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environment variable. Request: #!/bin/bash aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name spark-hive-via-thrift \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.2.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}' 4-Run thrift service as a sidecar in Spark Driver's pod \u00b6 This advanced solution runs the standalone HMS thrift service inside a Spark driver as a sidecar. It means each Spark job will have its dedicated thrift server. The benefit of the design is HMS is no long a single point of failure, since each Spark application has its own HMS. Also it is no long a long running service, i.e. it spins up when your Spark job starts, then terminates when your job is done. The sidecar follows the security best practice via leveraging Secrets Manager to extract JDBC crednetials. However, the maintenance of the sidecar increases because you now need to manage the hms sidecar, custom configmaps and sidecar pod templates. Also this solution requires combination skills of analytics and k8s. The CDK/CFN template is available to simplify the installation against a new EKS cluster. If you have an existing EKS cluster, the prerequisite details can be found in the github repository sidecar_hivethrift_eks.py: import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview4\" ) spark . sql ( \"CREATE EXTERNAL TABLE `demo`.`amazonreview4`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview4\" ) . show () spark . stop () Request: Now that the HMS is running inside your Spark driver, it share common attributes such as the network config, the spark.hive.metastore.uris can set to \"thrift://localhost:9083\". Don't forget to assign the sidecar pod template to the Spark Driver like this \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\" For more details, check out the github repo #!/bin/bash # test HMS sidecar on EKS aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name sidecar-hms \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\" } } ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}' 5-Hudi + Remote Hive metastore integration \u00b6 Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Hive metastore in HMS sync mode, with this setting 'hoodie.datasource.hive_sync.mode': 'hms' . This example runs a Hudi job with EMR on EKS, and interact with a remote RDS hive metastore to create a Hudi table. As a serverless option, it can interact with AWS Glue catalog. check out the AWS Glue section for more details. HudiEMRonEKS.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) print ( \"After {} \" . format ( spark . catalog . listTables ())) Request: The latest Hudi-spark3-bundle library is needed to support the new HMS hive sync functionality. In the following sample script, it is downloaded from maven repository when submitting a job with EMR 6.3. Starting from EMR 6.5, you don't need the --jars setting anymore, because EMR 6.5+ includes the Hudi-spark3-bundle library. aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name hudi-test1 \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/HudiEMRonEKS.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\", \"spark.sql.hive.convertMetastoreParquet\": \"false\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\" }} ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"Hive Metastore"},{"location":"metastore-integrations/docs/hive-metastore/#emr-containers-integration-with-hive-metastore","text":"For more details, check out the github repository , which includes CDK/CFN templates that help you to get started quickly.","title":"EMR Containers integration with Hive Metastore"},{"location":"metastore-integrations/docs/hive-metastore/#1-hive-metastore-database-through-jdbc","text":"In this example, a Spark application is configured to connect to a Hive Metastore database provisioned with Amazon RDS Aurora MySql via a JDBC connection. The Amazon RDS and EKS cluster should be in same VPC or else the Spark job will not be able to connect to RDS. You directly pass in the JDBC credentials at the job/application level, which is a simple and quick solution to make a connection to the HMS. However, it is not recommended in a production environment. From the security perspective, the password management could be a risk since the JDBC credentials will appear in all of your job logs. Also engineers may be required to hold the password when it is not necessary. Request: cat > Spark-Python-in-s3-hms-jdbc.json << EOF { \"name\": \"spark-python-in-s3-hms-jdbc\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/hivejdbc.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL=<JDBC-Connection-string> --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-jdbc.json In this example we are connecting to mysql db, so mariadb-connector-java.jar needs to be passed with --jars option. If you are using postgres, Oracle or any other database, the appropriate connector jar needs to be included. Configuration of interest: --jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL**=<JDBC-Connection-string> hivejdbc.py from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE `ehmsdb`.`sparkemrnyc5`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT count(*) FROM ehmsdb.sparkemrnyc5 \" ) . show () spark . stop () The above job lists databases from a remote RDS Hive Metastore, creates a new table and then queries it.","title":"1-Hive metastore Database through JDBC"},{"location":"metastore-integrations/docs/hive-metastore/#2-hive-metastore-thrift-service-through-thrift-protocol","text":"In this example, the spark application is configured to connect to an external Hive metastore thrift server. The thrift server is running on EMR on EC2's master node and AWS RDS Aurora is used as database for the Hive metastore. Running an EMR on EC2 cluster as a thrift server, simplify the application configuration and setup. You can start quickly with reduced engineering effort. However, your maintenance overhead may increase, since you will be monitoring two types of clusters, i.e. EMR on EC2 and EMR on EKS. thriftscript.py: hive.metastore.uris config needs to be set to read from external Hive metastore. The URI format looks like this: thrift://EMR_ON_EC2_MASTER_NODE_DNS_NAME:9083 from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . config ( \"hive.metastore.uris\" , \"<hive metastore thrift uri>\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE ehmsdb.`sparkemrnyc2`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT * FROM ehmsdb.sparkemrnyc2\" ) . show () spark . stop () Request: The below job lists databases from remote Hive Metastore, creates a new table and then queries it. cat > Spark-Python-in-s3-hms-thrift.json << EOF { \"name\": \"spark-python-in-s3-hms-thrift\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/thriftscript.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-thrift.json","title":"2-Hive metastore thrift service through thrift:// protocol"},{"location":"metastore-integrations/docs/hive-metastore/#3-connect-hive-metastore-via-thrift-service-hosted-on-eks","text":"In this example, our Spark application connects to a standalone Hive metastore service (HMS) running in EKS. Running the standalone HMS in EKS unifies your analytics applications with other business critical apps in a single platform. It simplifies your solution architecture and infrastructure design. The helm chart solution includes autoscaling feature, so your EKS cluster can automatically expand or shrink when the HMS request volume changes. Also it follows the security best practice to manage JDBC credentials via AWS Secrets Manager. However, you will need a combination of analytics and k8s skills to maintain this solution. To install the HMS helm chart , simply replace the environment variables in values.yaml, then manually helm install via the command below. Otherwise, deploy the HMS via a CDK/CFN template with a security best practice. Check out the CDK project for more details. cd hive-emr-on-eks/hive-metastore-chart sed -i '' -e 's/{RDS_JDBC_URL}/\"jdbc:mysql:\\/\\/' $YOUR_HOST_NAME ':3306\\/' $YOUR_DB_NAME '?createDatabaseIfNotExist=true\"/g' values.yaml sed -i '' -e 's/{RDS_USERNAME}/' $YOUR_USER_NAME '/g' values.yaml sed -i '' -e 's/{RDS_PASSWORD}/' $YOUR_PASSWORD '/g' values.yaml sed -i '' -e 's/{S3BUCKET}/s3:\\/\\/' $YOUR_S3BUCKET '/g' values.yaml helm repo add hive-metastore https://aws-samples.github.io/hive-metastore-chart helm install hive hive-metastore/hive-metastore -f values.yaml --namespace = emr --debug hivethrift_eks.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . config ( \"hive.metastore.uris\" , \"thrift://\" + environ [ 'HIVE_METASTORE_SERVICE_HOST' ] + \":9083\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview3\" ) spark . sql ( \"CREATE EXTERNAL TABLE IF NOT EXISTS `demo`.`amazonreview3`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview3\" ) . show () spark . stop () An environment variable HIVE_METASTORE_SERVICE_HOST appears in your Spark application pods automatically, once the standalone HMS is up running in EKS. You can directly set the hive.metastore.uris to thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\" . Can set the spark.sql.warehouse.dir property to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environment variable. Request: #!/bin/bash aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name spark-hive-via-thrift \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.2.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"3-Connect Hive metastore via thrift service hosted on EKS"},{"location":"metastore-integrations/docs/hive-metastore/#4-run-thrift-service-as-a-sidecar-in-spark-drivers-pod","text":"This advanced solution runs the standalone HMS thrift service inside a Spark driver as a sidecar. It means each Spark job will have its dedicated thrift server. The benefit of the design is HMS is no long a single point of failure, since each Spark application has its own HMS. Also it is no long a long running service, i.e. it spins up when your Spark job starts, then terminates when your job is done. The sidecar follows the security best practice via leveraging Secrets Manager to extract JDBC crednetials. However, the maintenance of the sidecar increases because you now need to manage the hms sidecar, custom configmaps and sidecar pod templates. Also this solution requires combination skills of analytics and k8s. The CDK/CFN template is available to simplify the installation against a new EKS cluster. If you have an existing EKS cluster, the prerequisite details can be found in the github repository sidecar_hivethrift_eks.py: import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview4\" ) spark . sql ( \"CREATE EXTERNAL TABLE `demo`.`amazonreview4`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview4\" ) . show () spark . stop () Request: Now that the HMS is running inside your Spark driver, it share common attributes such as the network config, the spark.hive.metastore.uris can set to \"thrift://localhost:9083\". Don't forget to assign the sidecar pod template to the Spark Driver like this \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\" For more details, check out the github repo #!/bin/bash # test HMS sidecar on EKS aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name sidecar-hms \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\" } } ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"4-Run thrift service as a sidecar in Spark Driver's pod"},{"location":"metastore-integrations/docs/hive-metastore/#5-hudi-remote-hive-metastore-integration","text":"Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Hive metastore in HMS sync mode, with this setting 'hoodie.datasource.hive_sync.mode': 'hms' . This example runs a Hudi job with EMR on EKS, and interact with a remote RDS hive metastore to create a Hudi table. As a serverless option, it can interact with AWS Glue catalog. check out the AWS Glue section for more details. HudiEMRonEKS.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) print ( \"After {} \" . format ( spark . catalog . listTables ())) Request: The latest Hudi-spark3-bundle library is needed to support the new HMS hive sync functionality. In the following sample script, it is downloaded from maven repository when submitting a job with EMR 6.3. Starting from EMR 6.5, you don't need the --jars setting anymore, because EMR 6.5+ includes the Hudi-spark3-bundle library. aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name hudi-test1 \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/HudiEMRonEKS.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\", \"spark.sql.hive.convertMetastoreParquet\": \"false\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\" }} ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"5-Hudi + Remote Hive metastore integration"},{"location":"node-placement/docs/","text":"","title":"Index"},{"location":"node-placement/docs/eks-node-placement/","text":"EKS Node Placement \u00b6 Single AZ placement \u00b6 AWS EKS clusters can span multiple AZs in a VPC. A Spark application whose driver and executor pods are distributed across multiple AZs can incur inter-AZ data transfer costs. To minimize or eliminate inter-AZ data transfer costs, you can configure the application to only run on the nodes within a single AZ. In this example, we use the kubernetes node selector to specify which AZ should the job run on. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.kubernetes.node.selector.topology.kubernetes.io/zone='<availability zone>' --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts the driver pod and executor pods are scheduled only on those EKS worker nodes with the label topology.kubernetes.io/zone: <availability zone> . This ensures the spark job is run within a single AZ. If there are not enough resources within the specified AZ, the pods will be in the pending state until the Autoscaler(if configured) kicks in or more resources become available. Spark on kubernetes Node selector configuration Kubernetes Node selector reference Configuration of interest - --conf spark.kubernetes.node.selector.zone='<availability zone>' zone is a built in label that EKS assigns to every EKS worker Node. The above config will ensure to schedule the driver and executor pod on those EKS worker nodes labeled - topology.kubernetes.io/zone: <availability zone> . However, user defined labels can also be assigned to EKS worker nodes and used as node selector. Other common use cases are using node labels to force the job to run on on demand/spot, machine type, etc. Single AZ and ec2 instance type placement \u00b6 Multiple key value pairs for spark.kubernetes.node.selector.[labelKey] can be passed to add filter conditions for selecting the EKS worker node. If you want to schedule on EKS worker nodes in <availability zone> and instance-type as m5.4xlarge - it is done as below Request: { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\", \"spark.kubernetes.node.selector.topology.kubernetes.io/zone\":\"<availability zone>\", \"spark.kubernetes.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } } } Configuration of interest spark.kubernetes.node.selector.[labelKey] - Adds to the node selector of the driver pod and executor pods, with key labelKey and the value as the configuration's value. For example, setting spark.kubernetes.node.selector.identifier to myIdentifier will result in the driver pod and executors having a node selector with key identifier and value myIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.","title":"EKS Node placement"},{"location":"node-placement/docs/eks-node-placement/#eks-node-placement","text":"","title":"EKS Node Placement"},{"location":"node-placement/docs/eks-node-placement/#single-az-placement","text":"AWS EKS clusters can span multiple AZs in a VPC. A Spark application whose driver and executor pods are distributed across multiple AZs can incur inter-AZ data transfer costs. To minimize or eliminate inter-AZ data transfer costs, you can configure the application to only run on the nodes within a single AZ. In this example, we use the kubernetes node selector to specify which AZ should the job run on. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.kubernetes.node.selector.topology.kubernetes.io/zone='<availability zone>' --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts the driver pod and executor pods are scheduled only on those EKS worker nodes with the label topology.kubernetes.io/zone: <availability zone> . This ensures the spark job is run within a single AZ. If there are not enough resources within the specified AZ, the pods will be in the pending state until the Autoscaler(if configured) kicks in or more resources become available. Spark on kubernetes Node selector configuration Kubernetes Node selector reference Configuration of interest - --conf spark.kubernetes.node.selector.zone='<availability zone>' zone is a built in label that EKS assigns to every EKS worker Node. The above config will ensure to schedule the driver and executor pod on those EKS worker nodes labeled - topology.kubernetes.io/zone: <availability zone> . However, user defined labels can also be assigned to EKS worker nodes and used as node selector. Other common use cases are using node labels to force the job to run on on demand/spot, machine type, etc.","title":"Single AZ placement"},{"location":"node-placement/docs/eks-node-placement/#single-az-and-ec2-instance-type-placement","text":"Multiple key value pairs for spark.kubernetes.node.selector.[labelKey] can be passed to add filter conditions for selecting the EKS worker node. If you want to schedule on EKS worker nodes in <availability zone> and instance-type as m5.4xlarge - it is done as below Request: { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\", \"spark.kubernetes.node.selector.topology.kubernetes.io/zone\":\"<availability zone>\", \"spark.kubernetes.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } } } Configuration of interest spark.kubernetes.node.selector.[labelKey] - Adds to the node selector of the driver pod and executor pods, with key labelKey and the value as the configuration's value. For example, setting spark.kubernetes.node.selector.identifier to myIdentifier will result in the driver pod and executors having a node selector with key identifier and value myIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.","title":"Single AZ and ec2 instance type placement"},{"location":"node-placement/docs/fargate-node-placement/","text":"EKS Fargate Node Placement \u00b6 Fargate Node Placement \u00b6 AWS Fargate is a technology that provides on-demand, right-sized compute capacity for containers. With AWS Fargate, you don't have to provision, configure, or scale groups of EC2 instances on your own to run containers. You also don't need to choose server types, decide when to scale your node groups, or optimize cluster packing. Instead you can control which pods start on Fargate and how they run with Fargate profiles. AWS Fargate profile \u00b6 Before you can schedule pods on Fargate in your cluster, you must define at least one Fargate profile that specifies which pods use Fargate when launched. You must define a namespace for every selector. The Fargate profile allows an administrator to declare which pods run on Fargate. This declaration is done through the profile\u2019s selectors. If a namespace selector is defined without any labels, Amazon EKS attempts to schedule all pods that run in that namespace onto Fargate using the profile. Create Fargate Profile Create your Fargate profile with the following eksctl command, replacing the <variable text> (including <>) with your own values. You're required to specify a namespace. The --labels option is not required to create your Fargate profile, but will be required if you want to only run Spark executors on Fargate. eksctl create fargateprofile \\ --cluster <cluster_name> \\ --name <fargate_profile_name> \\ --namespace <virtual_cluster_mapped_namespace> \\ --labels spark-node-placement=fargate 1- Place entire job including driver pod on Fargate \u00b6 When both Driver and Executors use the same labels as the Fargate Selector, the entire job including the driver pod will run on Fargate. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=4 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod and executor pods are scheduled only on Fargate since both are labeled with the spark-node-placement: fargate . This is useful when we want to run the entire job on Fargate nodes. The maximum vCPU available for the driver pod is 4vCPU. 2- Place driver pod on EC2 and executor pod on Fargate \u00b6 Remove the label from the driver pod to schedule the driver pod on EC2 instances. This is especially helpful when driver pod needs more resources (i.e. > 4 vCPU). Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=6 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod schedules on an EC2 instance. EKS picks an instance from the first Node Group that has the matching resources available to the driver pod. 3- Define a NodeSelector in Pod Templates \u00b6 Beginning with Amazon EMR versions 5.33.0 or 6.3.0, Amazon EMR on EKS supports Spark\u2019s pod template feature. Pod templates are specifications that determine how to run each pod. You can use pod template files to define the driver or executor pod\u2019s configurations that Spark configurations do not support. For example Spark configurations do not support defining individual node selectors for the driver pod and the executor pods. Define a node selector only for the driver pod when you want to choose on which pool of EC2 instance it should schedule. Let the Fargate Profile schedule the executor pods. Driver Pod Template apiVersion: v1 kind: Pod spec: volumes: - name: source-data-volume emptyDir: {} - name: metrics-files-volume emptyDir: {} nodeSelector: <ec2-instance-node-label-key>: <ec2-instance-node-label-value> containers: - name: spark-kubernetes-driver # This will be interpreted as Spark driver container Store the pod template file onto a S3 location: aws s3 cp /driver-pod-template.yaml s3://<your-bucket-name>/driver-pod-template.yaml Request cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<your-bucket-name>/driver-pod-template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: The driver pod schedules on an EC2 instance with enough capacity and matching label key / value with the node selector.","title":"EKS Fargate Node placement"},{"location":"node-placement/docs/fargate-node-placement/#eks-fargate-node-placement","text":"","title":"EKS Fargate Node Placement"},{"location":"node-placement/docs/fargate-node-placement/#fargate-node-placement","text":"AWS Fargate is a technology that provides on-demand, right-sized compute capacity for containers. With AWS Fargate, you don't have to provision, configure, or scale groups of EC2 instances on your own to run containers. You also don't need to choose server types, decide when to scale your node groups, or optimize cluster packing. Instead you can control which pods start on Fargate and how they run with Fargate profiles.","title":"Fargate Node Placement"},{"location":"node-placement/docs/fargate-node-placement/#aws-fargate-profile","text":"Before you can schedule pods on Fargate in your cluster, you must define at least one Fargate profile that specifies which pods use Fargate when launched. You must define a namespace for every selector. The Fargate profile allows an administrator to declare which pods run on Fargate. This declaration is done through the profile\u2019s selectors. If a namespace selector is defined without any labels, Amazon EKS attempts to schedule all pods that run in that namespace onto Fargate using the profile. Create Fargate Profile Create your Fargate profile with the following eksctl command, replacing the <variable text> (including <>) with your own values. You're required to specify a namespace. The --labels option is not required to create your Fargate profile, but will be required if you want to only run Spark executors on Fargate. eksctl create fargateprofile \\ --cluster <cluster_name> \\ --name <fargate_profile_name> \\ --namespace <virtual_cluster_mapped_namespace> \\ --labels spark-node-placement=fargate","title":"AWS Fargate profile"},{"location":"node-placement/docs/fargate-node-placement/#1-place-entire-job-including-driver-pod-on-fargate","text":"When both Driver and Executors use the same labels as the Fargate Selector, the entire job including the driver pod will run on Fargate. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=4 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod and executor pods are scheduled only on Fargate since both are labeled with the spark-node-placement: fargate . This is useful when we want to run the entire job on Fargate nodes. The maximum vCPU available for the driver pod is 4vCPU.","title":"1- Place entire job including driver pod on Fargate"},{"location":"node-placement/docs/fargate-node-placement/#2-place-driver-pod-on-ec2-and-executor-pod-on-fargate","text":"Remove the label from the driver pod to schedule the driver pod on EC2 instances. This is especially helpful when driver pod needs more resources (i.e. > 4 vCPU). Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=6 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod schedules on an EC2 instance. EKS picks an instance from the first Node Group that has the matching resources available to the driver pod.","title":"2- Place driver pod on EC2 and executor pod on Fargate"},{"location":"node-placement/docs/fargate-node-placement/#3-define-a-nodeselector-in-pod-templates","text":"Beginning with Amazon EMR versions 5.33.0 or 6.3.0, Amazon EMR on EKS supports Spark\u2019s pod template feature. Pod templates are specifications that determine how to run each pod. You can use pod template files to define the driver or executor pod\u2019s configurations that Spark configurations do not support. For example Spark configurations do not support defining individual node selectors for the driver pod and the executor pods. Define a node selector only for the driver pod when you want to choose on which pool of EC2 instance it should schedule. Let the Fargate Profile schedule the executor pods. Driver Pod Template apiVersion: v1 kind: Pod spec: volumes: - name: source-data-volume emptyDir: {} - name: metrics-files-volume emptyDir: {} nodeSelector: <ec2-instance-node-label-key>: <ec2-instance-node-label-value> containers: - name: spark-kubernetes-driver # This will be interpreted as Spark driver container Store the pod template file onto a S3 location: aws s3 cp /driver-pod-template.yaml s3://<your-bucket-name>/driver-pod-template.yaml Request cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<your-bucket-name>/driver-pod-template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: The driver pod schedules on an EC2 instance with enough capacity and matching label key / value with the node selector.","title":"3- Define a NodeSelector in Pod Templates"},{"location":"outposts/","text":"","title":"Index"},{"location":"outposts/emr-containers-on-outposts/","text":"Running EMR Containers on AWS Outposts \u00b6 Background \u00b6 You can now run Amazon EMR container jobs on EKS clusters that are running on AWS Outposts. AWS Outposts enables native AWS services, infrastructure, and operating models in on-premises facilities. In AWS Outposts environments, you can use the same AWS APIs, tools, and infrastructure that you use in the AWS Cloud. Amazon EKS nodes on AWS Outposts is ideal for low-latency workloads that need to be run in close proximity to on-premises data and applications. For more information, see the Amazon EKS on Outposts documentation page . This document provides the steps to set up EMR containers on AWS Outposts. Key Considerations and Recommendations \u00b6 The EKS cluster on an Outpost must be created with self-managed node groups. Use the AWS Management Console and AWS CloudFormation to create a self-managed node group in Outposts. For EMR workloads, we recommend creating EKS clusters where all the worker nodes reside in the self-managed node group of Outposts. The Kubernetes client in the Spark driver pod creates and monitor executor pods by communicating with the EKS managed Kubernetes API server residing in the parent AWS Region. For reliable monitoring of executor pods during a job run, we also recommend having a reliable low latency link between the Outpost and the parent Region. AWS Fargate is not available on Outposts. For more information about the supported Regions, prerequisites and considerations for Amazon EKS on AWS Outposts, see the EKS on Outposts documentation page . Infrastructure Setup \u00b6 Setup EKS on Outposts \u00b6 Network Setup Setup a VPC aws ec2 create - vpc \\ -- region < us - west - 2 > \\ -- cidr - block ' < 10.0.0.0 / 16 > ' In the output, take note of the VPC ID. { \"Vpc\": { \"VpcId\": \"vpc-123vpc\", ... } } Create two subnets in the parent Region. aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.1.0 / 24 > ' aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az2 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.2.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-111\", ... } } { \"Subnet\": { \"SubnetId\": \"subnet-222\", ... } } Create a subnet in the Outpost Availability Zone. (This step is different for Outposts) aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- outpost - arn ' arn:aws:outposts: < us - west - 2 >:< 123456789 >: outpost /< op - 123 op > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.3.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-333outpost\", \"OutpostArn\": \"...\" ... } } EKS Cluster Creation Create an EKS cluster using the three subnet Ids created earlier. aws eks create - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' \\ -- role - arn ' arn:aws: iam ::< 123456789 >: role /< cluster - service - role > ' \\ -- resources - vpc - config subnetIds = ' < subnet - 111 > , < subnet - 222 > , < subnet - 333 outpost > ' Check until the cluster status becomes active. aws eks describe - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' Note the values of resourcesVpcConfig.clusterSecurityGroupId and identity.oidc.issuer. { \"cluster\": { \"name\": \"outposts-eks-cluster\", ... \"resourcesVpcConfig\": { \"clusterSecurityGroupId\": \"sg-123clustersg\", }, \"identity\": { \"oidc\": { \"issuer\": \"https://oidc.eks.us-west-2.amazonaws.com/id/oidcid\" } }, \"status\": \"ACTIVE\", } } Add the Outposts nodes to the EKS Cluster. At this point, eksctl cannot be used to launch self-managed node groups in Outposts. Please follow the steps listed in the self-managed nodes documentation page . In order to use the cloudformation script lised in the AWS Management Console tab, make note of the following values created in the earlier steps: * ClusterName: <outposts-eks-cluster> * ClusterControlPlaneSecurityGroup: <sg-123clustersg> * Subnets: <subnet-333outpost> Apply the aws-auth-cm config map listed on the documentation page to allow the nodes to join the cluster. Register cluster with EMR Containers \u00b6 Once the EKS cluster has been created and the nodes have been registered with the EKS control plane, take the following steps : Enable cluster access for Amazon EMR on EKS. Enable IAM Roles for Service Accounts (IRSA) on the EKS cluster. Create a job execution role. Update the trust policy of the job execution role. Grant users access to Amazon EMR on EKS. Register the Amazon EKS cluster with Amazon EMR. Conclusion \u00b6 EMR-EKS on Outposts allows users to run their big data jobs in close proximity to on-premises data and applications.","title":"EMR on EKS(AWS Outposts)"},{"location":"outposts/emr-containers-on-outposts/#running-emr-containers-on-aws-outposts","text":"","title":"Running EMR Containers on AWS Outposts"},{"location":"outposts/emr-containers-on-outposts/#background","text":"You can now run Amazon EMR container jobs on EKS clusters that are running on AWS Outposts. AWS Outposts enables native AWS services, infrastructure, and operating models in on-premises facilities. In AWS Outposts environments, you can use the same AWS APIs, tools, and infrastructure that you use in the AWS Cloud. Amazon EKS nodes on AWS Outposts is ideal for low-latency workloads that need to be run in close proximity to on-premises data and applications. For more information, see the Amazon EKS on Outposts documentation page . This document provides the steps to set up EMR containers on AWS Outposts.","title":"Background"},{"location":"outposts/emr-containers-on-outposts/#key-considerations-and-recommendations","text":"The EKS cluster on an Outpost must be created with self-managed node groups. Use the AWS Management Console and AWS CloudFormation to create a self-managed node group in Outposts. For EMR workloads, we recommend creating EKS clusters where all the worker nodes reside in the self-managed node group of Outposts. The Kubernetes client in the Spark driver pod creates and monitor executor pods by communicating with the EKS managed Kubernetes API server residing in the parent AWS Region. For reliable monitoring of executor pods during a job run, we also recommend having a reliable low latency link between the Outpost and the parent Region. AWS Fargate is not available on Outposts. For more information about the supported Regions, prerequisites and considerations for Amazon EKS on AWS Outposts, see the EKS on Outposts documentation page .","title":"Key Considerations and Recommendations"},{"location":"outposts/emr-containers-on-outposts/#infrastructure-setup","text":"","title":"Infrastructure Setup"},{"location":"outposts/emr-containers-on-outposts/#setup-eks-on-outposts","text":"Network Setup Setup a VPC aws ec2 create - vpc \\ -- region < us - west - 2 > \\ -- cidr - block ' < 10.0.0.0 / 16 > ' In the output, take note of the VPC ID. { \"Vpc\": { \"VpcId\": \"vpc-123vpc\", ... } } Create two subnets in the parent Region. aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.1.0 / 24 > ' aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az2 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.2.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-111\", ... } } { \"Subnet\": { \"SubnetId\": \"subnet-222\", ... } } Create a subnet in the Outpost Availability Zone. (This step is different for Outposts) aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- outpost - arn ' arn:aws:outposts: < us - west - 2 >:< 123456789 >: outpost /< op - 123 op > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.3.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-333outpost\", \"OutpostArn\": \"...\" ... } } EKS Cluster Creation Create an EKS cluster using the three subnet Ids created earlier. aws eks create - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' \\ -- role - arn ' arn:aws: iam ::< 123456789 >: role /< cluster - service - role > ' \\ -- resources - vpc - config subnetIds = ' < subnet - 111 > , < subnet - 222 > , < subnet - 333 outpost > ' Check until the cluster status becomes active. aws eks describe - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' Note the values of resourcesVpcConfig.clusterSecurityGroupId and identity.oidc.issuer. { \"cluster\": { \"name\": \"outposts-eks-cluster\", ... \"resourcesVpcConfig\": { \"clusterSecurityGroupId\": \"sg-123clustersg\", }, \"identity\": { \"oidc\": { \"issuer\": \"https://oidc.eks.us-west-2.amazonaws.com/id/oidcid\" } }, \"status\": \"ACTIVE\", } } Add the Outposts nodes to the EKS Cluster. At this point, eksctl cannot be used to launch self-managed node groups in Outposts. Please follow the steps listed in the self-managed nodes documentation page . In order to use the cloudformation script lised in the AWS Management Console tab, make note of the following values created in the earlier steps: * ClusterName: <outposts-eks-cluster> * ClusterControlPlaneSecurityGroup: <sg-123clustersg> * Subnets: <subnet-333outpost> Apply the aws-auth-cm config map listed on the documentation page to allow the nodes to join the cluster.","title":"Setup EKS on Outposts"},{"location":"outposts/emr-containers-on-outposts/#register-cluster-with-emr-containers","text":"Once the EKS cluster has been created and the nodes have been registered with the EKS control plane, take the following steps : Enable cluster access for Amazon EMR on EKS. Enable IAM Roles for Service Accounts (IRSA) on the EKS cluster. Create a job execution role. Update the trust policy of the job execution role. Grant users access to Amazon EMR on EKS. Register the Amazon EKS cluster with Amazon EMR.","title":"Register cluster with EMR Containers"},{"location":"outposts/emr-containers-on-outposts/#conclusion","text":"EMR-EKS on Outposts allows users to run their big data jobs in close proximity to on-premises data and applications.","title":"Conclusion"},{"location":"performance/docs/","text":"","title":"Index"},{"location":"performance/docs/dra/","text":"Dynamic Resource Allocation \u00b6 DRA is available in Spark 3 (EMR 6.x) without the need for an external shuffle service. Spark on Kubernetes doesn't support external shuffle service as of spark 3.1, but DRA can be achieved by enabling shuffle tracking . Spark DRA without external shuffle service: With DRA, the spark driver spawns the initial number of executors and then scales up the number until the specified maximum number of executors is met to process the pending tasks. Idle executors are terminated when there are no pending tasks, the executor idle time exceeds the idle timeout( spark.dynamicAllocation.executorIdleTimeout) and it doesn't have any cached or shuffle data. If the executor idle threshold is reached and it has cached data, then it has to exceed the cache data idle timeout( spark.dynamicAllocation.cachedExecutorIdleTimeout) and if the executor doesn't have shuffle data, then the idle executor is terminated. If the executor idle threshold is reached and it has shuffle data, then without external shuffle service the executor will never be terminated. These executors will be terminated when the job is completed. This behavior is enforced by \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\" and \"spark.dynamicAllocation.enabled\":\"true\" If \"spark.dynamicAllocation.shuffleTracking.enabled\":\"false\"and \"spark.dynamicAllocation.enabled\":\"true\" then the spark application will error out since external shuffle service is not available. Request: cat >spark-python-in-s3-dra.json << EOF { \"name\": \"spark-python-in-s3-dra\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"true\", \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\", \"spark.dynamicAllocation.minExecutors\":\"5\", \"spark.dynamicAllocation.maxExecutors\":\"100\", \"spark.dynamicAllocation.initialExecutors\":\"10\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dra.json Observed Behavior: When the job gets started, the driver pod gets created and 10 executors are initially created. ( \"spark.dynamicAllocation.initialExecutors\":\"10\" ) Then the number of executors can scale up to a maximum of 100 ( \"spark.dynamicAllocation.maxExecutors\":\"100\" ). Configurations to note: Please note that this feature is marked as Experimental as of Spark 3.0.0 spark.dynamicAllocation.shuffleTracking.enabled - ** Experimental ** . Enables shuffle file tracking for executors, which allows dynamic allocation without the need for an external shuffle service. This option will try to keep alive executors that are storing shuffle data for active jobs. spark.dynamicAllocation.shuffleTracking.timeout - When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle data. The default value means that Spark will rely on the shuffles being garbage collected to be able to release executors. If for some reason garbage collection is not cleaning up shuffles quickly enough, this option can be used to control when to time out executors even when they are storing shuffle data.","title":"Dynamic Resource Allocation"},{"location":"performance/docs/dra/#dynamic-resource-allocation","text":"DRA is available in Spark 3 (EMR 6.x) without the need for an external shuffle service. Spark on Kubernetes doesn't support external shuffle service as of spark 3.1, but DRA can be achieved by enabling shuffle tracking . Spark DRA without external shuffle service: With DRA, the spark driver spawns the initial number of executors and then scales up the number until the specified maximum number of executors is met to process the pending tasks. Idle executors are terminated when there are no pending tasks, the executor idle time exceeds the idle timeout( spark.dynamicAllocation.executorIdleTimeout) and it doesn't have any cached or shuffle data. If the executor idle threshold is reached and it has cached data, then it has to exceed the cache data idle timeout( spark.dynamicAllocation.cachedExecutorIdleTimeout) and if the executor doesn't have shuffle data, then the idle executor is terminated. If the executor idle threshold is reached and it has shuffle data, then without external shuffle service the executor will never be terminated. These executors will be terminated when the job is completed. This behavior is enforced by \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\" and \"spark.dynamicAllocation.enabled\":\"true\" If \"spark.dynamicAllocation.shuffleTracking.enabled\":\"false\"and \"spark.dynamicAllocation.enabled\":\"true\" then the spark application will error out since external shuffle service is not available. Request: cat >spark-python-in-s3-dra.json << EOF { \"name\": \"spark-python-in-s3-dra\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"true\", \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\", \"spark.dynamicAllocation.minExecutors\":\"5\", \"spark.dynamicAllocation.maxExecutors\":\"100\", \"spark.dynamicAllocation.initialExecutors\":\"10\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dra.json Observed Behavior: When the job gets started, the driver pod gets created and 10 executors are initially created. ( \"spark.dynamicAllocation.initialExecutors\":\"10\" ) Then the number of executors can scale up to a maximum of 100 ( \"spark.dynamicAllocation.maxExecutors\":\"100\" ). Configurations to note: Please note that this feature is marked as Experimental as of Spark 3.0.0 spark.dynamicAllocation.shuffleTracking.enabled - ** Experimental ** . Enables shuffle file tracking for executors, which allows dynamic allocation without the need for an external shuffle service. This option will try to keep alive executors that are storing shuffle data for active jobs. spark.dynamicAllocation.shuffleTracking.timeout - When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle data. The default value means that Spark will rely on the shuffles being garbage collected to be able to release executors. If for some reason garbage collection is not cleaning up shuffles quickly enough, this option can be used to control when to time out executors even when they are storing shuffle data.","title":"Dynamic Resource Allocation"},{"location":"security/docs/","text":"","title":"Index"},{"location":"security/docs/spark/data-encryption/","text":"EMR Containers Spark - In transit and At Rest data encryption \u00b6 Encryption at Rest \u00b6 Amazon S3 Client-Side Encryption \u00b6 To utilize S3 Client side encryption , you will need to create a KMS Key to be used to encrypt and decrypt data. If you do not have an KMS key, please follow this guide - AWS KMS create keys . Also please note the job execution role needs access to this key, please see Add to Key policy for instructions on how to add these permissions. trip-count-encrypt-write.py: cat > trip - count - encrypt - write . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () EOF Request: cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json In the above request, EMRFS encrypts the parquet file with the specified KMS key and the encrypted object is persisted to the specified s3 location. To verify the encryption - use the same KMS key to decrypt - the KMS key used is a symmetric key ( the same key can be used to both encrypt and decrypt) trip-count-encrypt-read.py cat > trip - count - encrypt - read . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df_encrypt = spark . read . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt data - Total trips: \" + str ( df_encrypt . count ())) spark . stop () EOF Request cat > spark-python-in-s3-encrypt-cse-kms-read.json<<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-read\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-read.json Validate encryption: Try to read the encrypted data without specifying \"fs.s3.cse.enabled\":\"true\" - will get an error message in the driver and executor logs because the content is encrypted and cannot be read without decryption.","title":"Data Encryption"},{"location":"security/docs/spark/data-encryption/#emr-containers-spark-in-transit-and-at-rest-data-encryption","text":"","title":"EMR Containers Spark - In transit and At Rest data encryption"},{"location":"security/docs/spark/data-encryption/#encryption-at-rest","text":"","title":"Encryption at Rest"},{"location":"security/docs/spark/data-encryption/#amazon-s3-client-side-encryption","text":"To utilize S3 Client side encryption , you will need to create a KMS Key to be used to encrypt and decrypt data. If you do not have an KMS key, please follow this guide - AWS KMS create keys . Also please note the job execution role needs access to this key, please see Add to Key policy for instructions on how to add these permissions. trip-count-encrypt-write.py: cat > trip - count - encrypt - write . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () EOF Request: cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json In the above request, EMRFS encrypts the parquet file with the specified KMS key and the encrypted object is persisted to the specified s3 location. To verify the encryption - use the same KMS key to decrypt - the KMS key used is a symmetric key ( the same key can be used to both encrypt and decrypt) trip-count-encrypt-read.py cat > trip - count - encrypt - read . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df_encrypt = spark . read . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt data - Total trips: \" + str ( df_encrypt . count ())) spark . stop () EOF Request cat > spark-python-in-s3-encrypt-cse-kms-read.json<<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-read\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-read.json Validate encryption: Try to read the encrypted data without specifying \"fs.s3.cse.enabled\":\"true\" - will get an error message in the driver and executor logs because the content is encrypted and cannot be read without decryption.","title":"Amazon S3 Client-Side Encryption"},{"location":"security/docs/spark/encryption/","text":"EMR on EKS - Encryption Best Practices \u00b6 This document will describe how to think about security and its best practices when applying to EMR on EKS service. We will cover topics related to encryption at rest and in-transit when you run EMR on EKS jobs on EKS cluster. Its important to understand the shared responsibility model when using managed services such as EMR on EKS in order to improve the overall security posture of your environment. Generally speaking AWS is responsible for security \"of\" the cloud whereas you, the customer, are responsible for security \"in\" the cloud. The diagram below depicts this high level definition. Shared responsibility model \u00b6 EMR on EKS provides simple way to run spark jobs on top of EKS clusters. The architecture itself is loosely coupled and is abstracted from customers so that they can run secure environment for running spark applications. Because EMR on EKS uses combination of two services (EMR and EKS) at a minimal, we will cover how EKS enables infrastructure components that are consumable by EMR spark workload and how to handle encryption for each service. AWS assumes different levels of responsibility depending on the features being consumed by EMR on EKS customers. At this time of writing, the features from EKS are managed node groups, self-managed workers, and Fargate. We won\u2019t go in-depth on these architectures as they are detailed in EKS best practices guide (https://aws.github.io/aws-eks-best-practices/security/docs/). Below diagrams depict how this responsibility changes between customer and AWS based on consumed features. Encryption for data in-transit \u00b6 In this section, we will cover encryption for data in-transit. We will highlight AWS platform capabilities from the physical layer and then review how AWS handles encryption in the EMR on EKS architecture layer. Lastly, we will cover how customers can enable encryption between spark drivers and executors. AWS Infrastructure - Physical layer \u00b6 AWS provides secure and private connectivity between EC2 instances of all types. All data flowing across AWS Regions over the AWS global network is automatically encrypted at the physical layer before it leaves AWS secured facilities. All traffic between AZs is encrypted. All cross-Region traffic that uses Amazon VPC and Transit Gateway peering is automatically bulk-encrypted when it exits a Region. In addition, if you use Nitro family of instances, all traffic between instances is encrypted in-transit using AEAD algorithms with 256-bit encryption. We highly recommend reviewing EC2 documentation for more information. Amazon EMR on EKS \u00b6 Below diagram depicts high-level architecture implementation of EMR on EKS. In this section, we will cover encryption in-transit for communication between managed services such as EMR & EKS. All traffic with AWS API\u2019s that support EMR and EKS are encrypted by default. EKS enables Kubernetes API server using https endpoint. Both the kubelet that runs on EKS worker nodes and Kubernetes client such as kubectl interacts with EKS cluster API using TLS. Amazon EMR on EKS uses the same secure channel to interact with EKS cluster API to run spark jobs on worker nodes. In addition, EMR on EKS provides an encrypted endpoint for accessing spark history server. Spark offers AES-based encryption for RPC connections. EMR on EKS customers may choose to encrypt the traffic between spark drivers and executors using this encryption mechanism. In order to enable encryption, RPC authentication must also be enabled in your spark configuration. --conf spark.authenticate=true \\ --conf spark.network.crypto.enabled=true \\ The encryption key is generated by the driver and distributed to executors via environment variables. Because these environment variables can be accessed by users who has access to Kubernetes API (kubectl), we recommend securing access so that only authorized users have access to your environment. You should also configure proper Kubernetes RBAC permissions so that only authorized service accounts can use these variables. Encryption for data at-rest \u00b6 In this section, we will cover encryption for data at-rest. We will review how to enable storage-level encryption so that it is transparent for spark application to use this data securely. We will also see how to enable encryption from spark application while using AWS native storage options. Amazon S3 \u00b6 Amazon S3 offers server-side encryption for encrypting all data that is stored in an S3 bucket. You can enable default encryption using either S3 managed keys (SSE-S3) or KMS managed keys (SSE-KMS). Amazon S3 will encrypt all data before storing it on disks based on the keys specified. We recommend using server-side encryption at a minimum so that your data at-rest is encrypted. Please review Amazon S3 documentation and use the mechanisms that apply to your encryption standards and acceptable performance. Amazon S3 supports client-side encryption as well. Using this approach, you can let spark application to encrypt all data with desired KMS keys and upload this data to S3 buckets. Below examples shows spark application reading and writing parquet data in S3. During job submission, we use EMRFS encryption mechanism to encrypt all data with KMS key into the desired S3 location. import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () Below is the job submission request that depicts KMS specification needed for EMRFS to perform this encryption. For complete end-to-end example, please see EMR on EKS best practices documentation cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json Amazon EKS offers three different storage offerings (EBS, EFS, FSx) that can be directly consumed by pods. Each storage offering provides encryption mechanism that can be enabled at the storage level. Amazon EBS \u00b6 Amazon EBS supports default encryption that can be turned on a per region basis. Once its turned on, you can have newly created EBS volumes and snapshots encrypted using AWS managed KMS keys. Please review EBS documentation to learn more on how to enable this feature You can use Kubernetes (k8s) in-tree storage driver or choose to use EBS CSI driver to consume EBS volumes within your pods. Both choices offer options to enable encryption. In the below example, we use k8s in-tree storage driver to create storage class and persistent volume claim . You can create similar resources using EBS CSI driver as well. apiVersion : storage . k8s . io / v1 kind : StorageClass metadata : name : encrypted - sc provisioner : kubernetes . io / aws - ebs volumeBindingMode : WaitForFirstConsumer parameters : type : gp2 fsType : ext4 encrypted : \"true\" apiVersion : v1 kind : PersistentVolumeClaim metadata : name : spark - driver - pvc spec : storageClassName : encrypted - sc accessModes : - ReadWriteOnce resources : requests : storage : 10 Gi Once these resources are created, you can specify them in your drivers and executors. You can see an example of this specification below. Keep in mind, you can only attach an EBS volume to single EC2 instance or a Kubernetes pod. Therefore, if you have multiple executor pods, you need to create multiple PVCs to fulfill this request --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data ... --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=spark-executor-pvc --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data Another approach is to let k8s create EBS volumes dynamically based on your spark workload. You can do so by specifying just the storageClass and sizeLimit options and specify OnDemand for the persistent volume claim (PVC). This is useful in case of Dynamic Resource Allocation . Please be sure to use EMR 6.3.0 release and above to use this feature because dynamic PVC support was added in Spark 3.1. Below is an example for dynamically creating volumes for executors within your job -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . options . claimName = spark - driver - pvc -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . path =/ var / data / spill -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . readOnly = false For a complete list of available options, please refer to the Spark Documentation Amazon EFS \u00b6 Similar to EBS, you can consume EFS volumes via EFS CSI driver and FSx for Lustre volumes via FSx CSI driver . There are two provisioning methods before these storage volumes are consumed by workloads, namely static provisioning and dynamic provisioning. For static provisioning, you have to pre-create volumes using AWS API\u2019s, CLI or AWS console. For dynamic provisioning, volume is created dynamically by the CSI drivers as workloads are deployed onto Kubernetes cluster. Currently, EFS CSI driver doesn\u2019t support dynamic volume provisioning. However, you can create the volume using EFS API or AWS console before creating a persistent volume (PV) that can be used within your spark application. If you plan to encrypt the data stored in EFS, you need to specify encryption during volume creation. For further information about EFS file encryption, please refer to Encrypting Data at Rest . One of the advantages of using EFS is that it provides encryption in transit support using TLS and its enabled by default by the CSI driver. You can see the example below if you need to enforce TLS encryption during PV creation apiVersion : v1 kind : PersistentVolume metadata : name : efs - pv spec : capacity : storage : 5 Gi volumeMode : Filesystem accessModes : - ReadWriteOnce persistentVolumeReclaimPolicy : Retain storageClassName : efs - sc csi : driver : efs . csi . aws . com volumeHandle : fs - 4 af69aab volumeAttributes : encryptInTransit : \"true\" Amazon FSx for Lustre \u00b6 Amazon FSx CSI driver supports both static and dynamic provisioning. Encryption for data in-transit is automatically enabled from Amazon EC2 instances that support encryption in transit. To learn which EC2 instances support encryption in transit, see Encryption in Transit in the Amazon EC2 User Guide for Linux Instances. Encryption for data at rest is automatically enabled when you create the FSx filesystem. Amazon FSx for Lustre supports two types of filesystems, namely persistent and scratch. You can use the default encryption method where encryption keys are managed by Amazon FSx. However, if you prefer to manage your own KMS keys, you can do so for persistent filesystem. The example below shows how to create storage class using FSx for Lustre for persistent filesystem using your own KMS managed keys. kind : StorageClass apiVersion : storage . k8s . io / v1 metadata : name : fsx - sc provisioner : fsx . csi . aws . com parameters : subnetId : subnet - 056 da83524edbe641 securityGroupIds : sg - 086 f61ea73388fb6b deploymentType : PERSISTENT_1 kmsKeyId : < kms_arn > You can then create persistent volume claim (see an example in FSx repo ) and use within your spark application as below --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=fsx-claim --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data Using Spark to encrypt data \u00b6 Apache Spark supports encrypting temporary data that is stored on storage volumes. These volumes can be instance storage such as NVMe SSD volumes , EBS, EFS or FSx volumes. Temporary data can be shuffle files, shuffle spills and data blocks stored on disk (for both caching and broadcast variables). Its important to note that the data on NVMe instance storage is encrypted using an XTS-AES-256 block cipher implemented in a hardware module on the instance. Even though, instance storage is available, you need to format and mount them while you bootstrap EC2 instances. Below is an example to show how to use instance storage using eksctl managedNodeGroups: - name: nvme minSize: 2 desiredCapacity: 2 maxSize: 10 instanceType: r5d.4xlarge ssh: enableSsm: true preBootstrapCommands: - IDX=1 - for DEV in /dev/disk/by-id/nvme-Amazon_EC2_NVMe_Instance_Storage_*-ns-1; do mkfs.xfs ${ DEV } ;mkdir -p /local ${ IDX } ;echo ${ DEV } /local ${ IDX } xfs defaults,noatime 1 2 >> /etc/fstab; IDX=$(( ${ IDX } + 1)); done - mount -a If you use non-NVMe SSD volumes, you can follow the best practice to encrypt shuffle data before you write them to disks. You can see an example below that shows this example. For more information about the type of instance store volume supported by each instance type, see Instance store volumes . --conf spark.io.encryption.enabled=true Conclusion \u00b6 In this document, we covered shared responsibility model for running EMR on EKS workload. We then reviewed platform capabilities available through AWS infrastructure and how to enable encryption for both storage-level and via spark application. To quote Werner Vogels, AWS CTO \u201cSecurity is everyone\u2019s job now, not just the security team\u2019s\u201d. We hope this document provides prescriptive guidance into how to enable encryption for running secure EMR on EKS workload.","title":"Encryption"},{"location":"security/docs/spark/encryption/#emr-on-eks-encryption-best-practices","text":"This document will describe how to think about security and its best practices when applying to EMR on EKS service. We will cover topics related to encryption at rest and in-transit when you run EMR on EKS jobs on EKS cluster. Its important to understand the shared responsibility model when using managed services such as EMR on EKS in order to improve the overall security posture of your environment. Generally speaking AWS is responsible for security \"of\" the cloud whereas you, the customer, are responsible for security \"in\" the cloud. The diagram below depicts this high level definition.","title":"EMR on EKS - Encryption Best Practices"},{"location":"security/docs/spark/encryption/#shared-responsibility-model","text":"EMR on EKS provides simple way to run spark jobs on top of EKS clusters. The architecture itself is loosely coupled and is abstracted from customers so that they can run secure environment for running spark applications. Because EMR on EKS uses combination of two services (EMR and EKS) at a minimal, we will cover how EKS enables infrastructure components that are consumable by EMR spark workload and how to handle encryption for each service. AWS assumes different levels of responsibility depending on the features being consumed by EMR on EKS customers. At this time of writing, the features from EKS are managed node groups, self-managed workers, and Fargate. We won\u2019t go in-depth on these architectures as they are detailed in EKS best practices guide (https://aws.github.io/aws-eks-best-practices/security/docs/). Below diagrams depict how this responsibility changes between customer and AWS based on consumed features.","title":"Shared responsibility model"},{"location":"security/docs/spark/encryption/#encryption-for-data-in-transit","text":"In this section, we will cover encryption for data in-transit. We will highlight AWS platform capabilities from the physical layer and then review how AWS handles encryption in the EMR on EKS architecture layer. Lastly, we will cover how customers can enable encryption between spark drivers and executors.","title":"Encryption for data in-transit"},{"location":"security/docs/spark/encryption/#aws-infrastructure-physical-layer","text":"AWS provides secure and private connectivity between EC2 instances of all types. All data flowing across AWS Regions over the AWS global network is automatically encrypted at the physical layer before it leaves AWS secured facilities. All traffic between AZs is encrypted. All cross-Region traffic that uses Amazon VPC and Transit Gateway peering is automatically bulk-encrypted when it exits a Region. In addition, if you use Nitro family of instances, all traffic between instances is encrypted in-transit using AEAD algorithms with 256-bit encryption. We highly recommend reviewing EC2 documentation for more information.","title":"AWS Infrastructure - Physical layer"},{"location":"security/docs/spark/encryption/#amazon-emr-on-eks","text":"Below diagram depicts high-level architecture implementation of EMR on EKS. In this section, we will cover encryption in-transit for communication between managed services such as EMR & EKS. All traffic with AWS API\u2019s that support EMR and EKS are encrypted by default. EKS enables Kubernetes API server using https endpoint. Both the kubelet that runs on EKS worker nodes and Kubernetes client such as kubectl interacts with EKS cluster API using TLS. Amazon EMR on EKS uses the same secure channel to interact with EKS cluster API to run spark jobs on worker nodes. In addition, EMR on EKS provides an encrypted endpoint for accessing spark history server. Spark offers AES-based encryption for RPC connections. EMR on EKS customers may choose to encrypt the traffic between spark drivers and executors using this encryption mechanism. In order to enable encryption, RPC authentication must also be enabled in your spark configuration. --conf spark.authenticate=true \\ --conf spark.network.crypto.enabled=true \\ The encryption key is generated by the driver and distributed to executors via environment variables. Because these environment variables can be accessed by users who has access to Kubernetes API (kubectl), we recommend securing access so that only authorized users have access to your environment. You should also configure proper Kubernetes RBAC permissions so that only authorized service accounts can use these variables.","title":"Amazon EMR on EKS"},{"location":"security/docs/spark/encryption/#encryption-for-data-at-rest","text":"In this section, we will cover encryption for data at-rest. We will review how to enable storage-level encryption so that it is transparent for spark application to use this data securely. We will also see how to enable encryption from spark application while using AWS native storage options.","title":"Encryption for data at-rest"},{"location":"security/docs/spark/encryption/#amazon-s3","text":"Amazon S3 offers server-side encryption for encrypting all data that is stored in an S3 bucket. You can enable default encryption using either S3 managed keys (SSE-S3) or KMS managed keys (SSE-KMS). Amazon S3 will encrypt all data before storing it on disks based on the keys specified. We recommend using server-side encryption at a minimum so that your data at-rest is encrypted. Please review Amazon S3 documentation and use the mechanisms that apply to your encryption standards and acceptable performance. Amazon S3 supports client-side encryption as well. Using this approach, you can let spark application to encrypt all data with desired KMS keys and upload this data to S3 buckets. Below examples shows spark application reading and writing parquet data in S3. During job submission, we use EMRFS encryption mechanism to encrypt all data with KMS key into the desired S3 location. import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () Below is the job submission request that depicts KMS specification needed for EMRFS to perform this encryption. For complete end-to-end example, please see EMR on EKS best practices documentation cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json Amazon EKS offers three different storage offerings (EBS, EFS, FSx) that can be directly consumed by pods. Each storage offering provides encryption mechanism that can be enabled at the storage level.","title":"Amazon S3"},{"location":"security/docs/spark/encryption/#amazon-ebs","text":"Amazon EBS supports default encryption that can be turned on a per region basis. Once its turned on, you can have newly created EBS volumes and snapshots encrypted using AWS managed KMS keys. Please review EBS documentation to learn more on how to enable this feature You can use Kubernetes (k8s) in-tree storage driver or choose to use EBS CSI driver to consume EBS volumes within your pods. Both choices offer options to enable encryption. In the below example, we use k8s in-tree storage driver to create storage class and persistent volume claim . You can create similar resources using EBS CSI driver as well. apiVersion : storage . k8s . io / v1 kind : StorageClass metadata : name : encrypted - sc provisioner : kubernetes . io / aws - ebs volumeBindingMode : WaitForFirstConsumer parameters : type : gp2 fsType : ext4 encrypted : \"true\" apiVersion : v1 kind : PersistentVolumeClaim metadata : name : spark - driver - pvc spec : storageClassName : encrypted - sc accessModes : - ReadWriteOnce resources : requests : storage : 10 Gi Once these resources are created, you can specify them in your drivers and executors. You can see an example of this specification below. Keep in mind, you can only attach an EBS volume to single EC2 instance or a Kubernetes pod. Therefore, if you have multiple executor pods, you need to create multiple PVCs to fulfill this request --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data ... --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=spark-executor-pvc --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data Another approach is to let k8s create EBS volumes dynamically based on your spark workload. You can do so by specifying just the storageClass and sizeLimit options and specify OnDemand for the persistent volume claim (PVC). This is useful in case of Dynamic Resource Allocation . Please be sure to use EMR 6.3.0 release and above to use this feature because dynamic PVC support was added in Spark 3.1. Below is an example for dynamically creating volumes for executors within your job -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . options . claimName = spark - driver - pvc -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . path =/ var / data / spill -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . readOnly = false For a complete list of available options, please refer to the Spark Documentation","title":"Amazon EBS"},{"location":"security/docs/spark/encryption/#amazon-efs","text":"Similar to EBS, you can consume EFS volumes via EFS CSI driver and FSx for Lustre volumes via FSx CSI driver . There are two provisioning methods before these storage volumes are consumed by workloads, namely static provisioning and dynamic provisioning. For static provisioning, you have to pre-create volumes using AWS API\u2019s, CLI or AWS console. For dynamic provisioning, volume is created dynamically by the CSI drivers as workloads are deployed onto Kubernetes cluster. Currently, EFS CSI driver doesn\u2019t support dynamic volume provisioning. However, you can create the volume using EFS API or AWS console before creating a persistent volume (PV) that can be used within your spark application. If you plan to encrypt the data stored in EFS, you need to specify encryption during volume creation. For further information about EFS file encryption, please refer to Encrypting Data at Rest . One of the advantages of using EFS is that it provides encryption in transit support using TLS and its enabled by default by the CSI driver. You can see the example below if you need to enforce TLS encryption during PV creation apiVersion : v1 kind : PersistentVolume metadata : name : efs - pv spec : capacity : storage : 5 Gi volumeMode : Filesystem accessModes : - ReadWriteOnce persistentVolumeReclaimPolicy : Retain storageClassName : efs - sc csi : driver : efs . csi . aws . com volumeHandle : fs - 4 af69aab volumeAttributes : encryptInTransit : \"true\"","title":"Amazon EFS"},{"location":"security/docs/spark/encryption/#amazon-fsx-for-lustre","text":"Amazon FSx CSI driver supports both static and dynamic provisioning. Encryption for data in-transit is automatically enabled from Amazon EC2 instances that support encryption in transit. To learn which EC2 instances support encryption in transit, see Encryption in Transit in the Amazon EC2 User Guide for Linux Instances. Encryption for data at rest is automatically enabled when you create the FSx filesystem. Amazon FSx for Lustre supports two types of filesystems, namely persistent and scratch. You can use the default encryption method where encryption keys are managed by Amazon FSx. However, if you prefer to manage your own KMS keys, you can do so for persistent filesystem. The example below shows how to create storage class using FSx for Lustre for persistent filesystem using your own KMS managed keys. kind : StorageClass apiVersion : storage . k8s . io / v1 metadata : name : fsx - sc provisioner : fsx . csi . aws . com parameters : subnetId : subnet - 056 da83524edbe641 securityGroupIds : sg - 086 f61ea73388fb6b deploymentType : PERSISTENT_1 kmsKeyId : < kms_arn > You can then create persistent volume claim (see an example in FSx repo ) and use within your spark application as below --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=fsx-claim --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data","title":"Amazon FSx for Lustre"},{"location":"security/docs/spark/encryption/#using-spark-to-encrypt-data","text":"Apache Spark supports encrypting temporary data that is stored on storage volumes. These volumes can be instance storage such as NVMe SSD volumes , EBS, EFS or FSx volumes. Temporary data can be shuffle files, shuffle spills and data blocks stored on disk (for both caching and broadcast variables). Its important to note that the data on NVMe instance storage is encrypted using an XTS-AES-256 block cipher implemented in a hardware module on the instance. Even though, instance storage is available, you need to format and mount them while you bootstrap EC2 instances. Below is an example to show how to use instance storage using eksctl managedNodeGroups: - name: nvme minSize: 2 desiredCapacity: 2 maxSize: 10 instanceType: r5d.4xlarge ssh: enableSsm: true preBootstrapCommands: - IDX=1 - for DEV in /dev/disk/by-id/nvme-Amazon_EC2_NVMe_Instance_Storage_*-ns-1; do mkfs.xfs ${ DEV } ;mkdir -p /local ${ IDX } ;echo ${ DEV } /local ${ IDX } xfs defaults,noatime 1 2 >> /etc/fstab; IDX=$(( ${ IDX } + 1)); done - mount -a If you use non-NVMe SSD volumes, you can follow the best practice to encrypt shuffle data before you write them to disks. You can see an example below that shows this example. For more information about the type of instance store volume supported by each instance type, see Instance store volumes . --conf spark.io.encryption.enabled=true","title":"Using Spark to encrypt data"},{"location":"security/docs/spark/encryption/#conclusion","text":"In this document, we covered shared responsibility model for running EMR on EKS workload. We then reviewed platform capabilities available through AWS infrastructure and how to enable encryption for both storage-level and via spark application. To quote Werner Vogels, AWS CTO \u201cSecurity is everyone\u2019s job now, not just the security team\u2019s\u201d. We hope this document provides prescriptive guidance into how to enable encryption for running secure EMR on EKS workload.","title":"Conclusion"},{"location":"security/docs/spark/network-security/","text":"Managing VPC for EMR on EKS \u00b6 This section address network security at VPC level. If you want to read more on network security for Spark in EMR on EKS please refer to this section . Security Group \u00b6 The applications running on your EMR on EKS cluster often would need access to services that are running outside the cluster, for example, these can Amazon Redshift, Amazon Relational Database Service, a service self hosted on an EC2 instance. To access these resource you need to allow network traffic at the security group level. The default mechanism in EKS is using security groups at the node level, this means all the pods running on the node will inherit the rules on the security group. For security conscious customers, this is not a desired behavior and you would want to use security groups at the pod level. This section address how you can use Security Groups with EMR on EKS. Configure EKS Cluster to use Security Groups for Pods \u00b6 In order to use Security Groups at the pod level, you need to configure the VPC CNI for EKS. The following link guide through the prerequisites as well as configuring the EKS Cluster. Define SecurityGroupPolicy \u00b6 Once you have configured the VPC CNI, you need to create a SecurityGroupPolicy object. This object define which security group (up to 5) to use, podselector to define which pod to apply the security group to and the namespace in which the Security Group should be evaluated. Below you find an example of SecurityGroupPolicy . apiVersion : vpcresources . k8s . aws / v1beta1 kind : SecurityGroupPolicy metadata : name : <> namespace : < NAMESPACE FOR VC > spec : podSelector : matchLabels : role : spark securityGroups : groupIds : - sg - xxxxx Define pod template to use Security Group for pod \u00b6 In order for the security group to be applied to the Spark driver and executors, you need to provide a podtemplate which add label(s) to the pods. The labels should match the one defined above in the podSelector in our example it is role: spark . The snippet below define the pod template that you can upload in S3 and then reference when launching your job. apiVersion : v1 kind : Pod metadata : labels : role : spark Launch a job \u00b6 The command below can be used to run a job. aws emr - containers start - job - run -- virtual - cluster - id < EMR - VIRTUAL - CLUSTER - ID > -- name spark - jdbc -- execution - role - arn < EXECUTION - ROLE - ARN > -- release - label emr - 6 . 7 . 0 - latest -- job - driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"<S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE>\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1\" } } ' --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" , \"spark.sql.catalogImplementation\" : \"hive\" , \"spark.dynamicAllocation.enabled\" : \"true\" , \"spark.dynamicAllocation.minExecutors\" : \"8\" , \"spark.dynamicAllocation.maxExecutors\" : \"40\" , \"spark.kubernetes.allocation.batch.size\" : \"8\" , \"spark.dynamicAllocation.executorAllocationRatio\" : \"1\" , \"spark.dynamicAllocation.shuffleTracking.enabled\" : \"true\" , \"spark.dynamicAllocation.shuffleTracking.timeout\" : \"300s\" , \"spark.kubernetes.driver.podTemplateFile\" : < S3 - URI - TO - DRIVER - POD - TEMPLATE > , \"spark.kubernetes.executor.podTemplateFile\" : < S3 - URI - TO - EXECUTOR - POD - TEMPLATE > } } ], \"monitoringConfiguration\" : { \"persistentAppUI\" : \"ENABLED\" , \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/aws/emr-containers/\" , \"logStreamNamePrefix\" : \"default\" } } } ' Verify a security group attached to the Pod ENI \u00b6 To verify that spark driver and executor driver have the security group attached to, apply the first command to get the podname then the second one to see the annotation in pod with the ENI associated to the pod which has the secuity group defined in the SecurityGroupPolicy . export POD_NAME =$ ( kubectl - n < NAMESPACE > get pods - l role = spark - o jsonpath = '{.items[].metadata.name}' ) kubectl - n < NAMESPACE > describe pod $ POD_NAME | head - 11 Annotations : kubernetes . io / psp : eks . privileged vpc . amazonaws . com / pod - eni : [{ \"eniId\" : \"eni-xxxxxxx\" , \"ifAddress\" : \"xx:xx:xx:xx:xx:xx\" , \"privateIp\" : \"x.x.x.x\" , \"vlanId\" : 1 , \"subnetCidr\" : \"x.x.x.x/x\" }]","title":"Network Security"},{"location":"security/docs/spark/network-security/#managing-vpc-for-emr-on-eks","text":"This section address network security at VPC level. If you want to read more on network security for Spark in EMR on EKS please refer to this section .","title":"Managing VPC for EMR on EKS"},{"location":"security/docs/spark/network-security/#security-group","text":"The applications running on your EMR on EKS cluster often would need access to services that are running outside the cluster, for example, these can Amazon Redshift, Amazon Relational Database Service, a service self hosted on an EC2 instance. To access these resource you need to allow network traffic at the security group level. The default mechanism in EKS is using security groups at the node level, this means all the pods running on the node will inherit the rules on the security group. For security conscious customers, this is not a desired behavior and you would want to use security groups at the pod level. This section address how you can use Security Groups with EMR on EKS.","title":"Security Group"},{"location":"security/docs/spark/network-security/#configure-eks-cluster-to-use-security-groups-for-pods","text":"In order to use Security Groups at the pod level, you need to configure the VPC CNI for EKS. The following link guide through the prerequisites as well as configuring the EKS Cluster.","title":"Configure EKS Cluster to use Security Groups for Pods"},{"location":"security/docs/spark/network-security/#define-securitygrouppolicy","text":"Once you have configured the VPC CNI, you need to create a SecurityGroupPolicy object. This object define which security group (up to 5) to use, podselector to define which pod to apply the security group to and the namespace in which the Security Group should be evaluated. Below you find an example of SecurityGroupPolicy . apiVersion : vpcresources . k8s . aws / v1beta1 kind : SecurityGroupPolicy metadata : name : <> namespace : < NAMESPACE FOR VC > spec : podSelector : matchLabels : role : spark securityGroups : groupIds : - sg - xxxxx","title":"Define SecurityGroupPolicy"},{"location":"security/docs/spark/network-security/#define-pod-template-to-use-security-group-for-pod","text":"In order for the security group to be applied to the Spark driver and executors, you need to provide a podtemplate which add label(s) to the pods. The labels should match the one defined above in the podSelector in our example it is role: spark . The snippet below define the pod template that you can upload in S3 and then reference when launching your job. apiVersion : v1 kind : Pod metadata : labels : role : spark","title":"Define pod template to use Security Group for pod"},{"location":"security/docs/spark/network-security/#launch-a-job","text":"The command below can be used to run a job. aws emr - containers start - job - run -- virtual - cluster - id < EMR - VIRTUAL - CLUSTER - ID > -- name spark - jdbc -- execution - role - arn < EXECUTION - ROLE - ARN > -- release - label emr - 6 . 7 . 0 - latest -- job - driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"<S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE>\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1\" } } ' --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" , \"spark.sql.catalogImplementation\" : \"hive\" , \"spark.dynamicAllocation.enabled\" : \"true\" , \"spark.dynamicAllocation.minExecutors\" : \"8\" , \"spark.dynamicAllocation.maxExecutors\" : \"40\" , \"spark.kubernetes.allocation.batch.size\" : \"8\" , \"spark.dynamicAllocation.executorAllocationRatio\" : \"1\" , \"spark.dynamicAllocation.shuffleTracking.enabled\" : \"true\" , \"spark.dynamicAllocation.shuffleTracking.timeout\" : \"300s\" , \"spark.kubernetes.driver.podTemplateFile\" : < S3 - URI - TO - DRIVER - POD - TEMPLATE > , \"spark.kubernetes.executor.podTemplateFile\" : < S3 - URI - TO - EXECUTOR - POD - TEMPLATE > } } ], \"monitoringConfiguration\" : { \"persistentAppUI\" : \"ENABLED\" , \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/aws/emr-containers/\" , \"logStreamNamePrefix\" : \"default\" } } } '","title":"Launch a job"},{"location":"security/docs/spark/network-security/#verify-a-security-group-attached-to-the-pod-eni","text":"To verify that spark driver and executor driver have the security group attached to, apply the first command to get the podname then the second one to see the annotation in pod with the ENI associated to the pod which has the secuity group defined in the SecurityGroupPolicy . export POD_NAME =$ ( kubectl - n < NAMESPACE > get pods - l role = spark - o jsonpath = '{.items[].metadata.name}' ) kubectl - n < NAMESPACE > describe pod $ POD_NAME | head - 11 Annotations : kubernetes . io / psp : eks . privileged vpc . amazonaws . com / pod - eni : [{ \"eniId\" : \"eni-xxxxxxx\" , \"ifAddress\" : \"xx:xx:xx:xx:xx:xx\" , \"privateIp\" : \"x.x.x.x\" , \"vlanId\" : 1 , \"subnetCidr\" : \"x.x.x.x/x\" }]","title":"Verify a security group attached to the Pod ENI"},{"location":"security/docs/spark/secrets/","text":"Using Secrets in EMR on EKS \u00b6 Secrets can be credentials to APIs, Databases or other resources. There are various ways these secrets can be passed to your containers, some of them are pod environment variable or Kubernetes Secrets. These methods are not secure, as for environment variable, secrets are stored in clear text and any authorized user who has access to Kubernetes cluster with admin privileges can read those secrets. Storing secrets using Kubernetes secrets is also not secure because they are not encrypted and only base36 encoded. There is a secure method to expose these secrets in EKS through the Secrets Store CSI Driver . The Secrets Store CSI Driver integrate with a secret store like AWS Secrets manager and mount the secrets as volume that can be accessed through your application code. This document describes how to set and use AWS Secrets Manager with EMR on EKS through the Secrets Store CSI Driver. Deploy Secrets Store CSI Drivers and AWS Secrets and Configuration Provider \u00b6 Secrets Store CSI Drivers \u00b6 Configure EKS Cluster with Secrets Store CSI Driver . To learn more about AWS Secrets Manager CSI Driver you can refer to this link helm repo add secrets-store-csi-driver \\ https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts helm install -n kube-system csi-secrets-store \\ --set syncSecret.enabled=true \\ --set enableSecretRotation=true \\ secrets-store-csi-driver/secrets-store-csi-driver Deploy the AWS Secrets and Configuration Provider to use AWS Secrets Manager AWS Secrets and Configuration Provider \u00b6 kubectl apply -f https://raw.githubusercontent.com/aws/secrets-store-csi-driver-provider-aws/main/deployment/aws-provider-installer.yaml Define the SecretProviderClass \u00b6 The SecretProviderClass is how you present present your secret in Kubernetes, below you find a definition of a SecretProviderClass . There are few parameters that are important: The provider must be set to aws . The objectName must be the name of the secret you want to use as defined in AWS. Here the secret is called db-creds . The objectType must be set to secretsmanager . cat > db-cred.yaml << EOF apiVersion: secrets-store.csi.x-k8s.io/v1 kind: SecretProviderClass metadata: name: mysql-spark-secret spec: provider: aws parameters: objects: | - objectName: \"db-creds\" objectType: \"secretsmanager\" EOF kubectl apply -f db-cred.yaml -n <NAMESPACE> In the terminal apply the above command to create SecretProviderClass , The kubectl command must include the namespace where your job will be executed. Pod Template \u00b6 In the executor podtemplate you should define it as follow to mount the secret. The example below show how you can define it. There are few points that are important to mount the secret: secretProviderClass : this should have the same name as the one define above. In this case it is mysql-spark-secret . mountPath : Is where the secret is going to be available to the pod. In this example it will be in /var/secrets When defining the mountPath make sure you do not specify the ones reserved by EMR on EKS as defined here . apiVersion : v1 kind : Pod spec : containers : - name : spark - kubernetes - executors volumeMounts : - mountPath : \"/var/secrets\" name : mysql - cred readOnly : true volumes : - name : mysql - cred csi : driver : secrets - store . csi . k8s . io readOnly : true volumeAttributes : secretProviderClass : mysql - spark - secret This podtemplate must be uploaded to S3 and referenced in the job submit command as shown below. Note You must make sure that the RDS instance or your Database allow traffic from the instances where your driver and executors pods are running. PySpark code \u00b6 The example below shows pyspark code for connecting with a MySQL DB. The example assume the secret is stored in AWS secrets manager as defined above. The username is the key to retrieve the database user as stored in AWS Secrets Manager, and password is the key to retrieve the database password. It shows how you can retrieve the credentials from the mount point /var/secrets/ . The secret is stored in a file with the same name as it is defined in AWS in this case it is db-creds . This has been set in the podTemplate above. from pyspark.sql import SparkSession import json secret_path = \"/var/secrets/db-creds\" f = open ( secret_path , \"r\" ) mySecretDict = json . loads ( f . read ()) spark = SparkSession . builder . getOrCreate () str_jdbc_url = \"jdbc:<DB endpoint>\" str_Query = < QUERY > str_username = mySecretDict [ 'username' ] str_password = mySecretDict [ 'password' ] driver = \"com.mysql.jdbc.Driver\" jdbcDF = spark . read \\ . format ( \"jdbc\" ) \\ . option ( \"url\" , str_jdbc_url ) \\ . option ( \"driver\" , driver ) \\ . option ( \"query\" , str_Query ) \\ . option ( \"user\" , str_username ) \\ . option ( \"password\" , str_password ) \\ . load () jdbcDF . show () Execute the job \u00b6 The command below can be used to run a job. Note : The supplied execution role MUST have access an IAM policy that allow it access to the secret defined in SecretProviderClass above. The IAM policy below shows the IAM actions that are needed. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [\"secretsmanager:GetSecretValue\", \"secretsmanager:DescribeSecret\"], \"Resource\": [<SECRET-ARN>] }] } aws emr - containers start - job - run -- virtual - cluster - id < EMR - VIRTUAL - CLUSTER - ID > -- name spark - jdbc -- execution - role - arn < EXECUTION - ROLE - ARN > -- release - label emr - 6 . 7 . 0 - latest -- job - driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"<S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE>\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1 --conf spark.jars=<S3-URI-TO-MYSQL-JDBC-JAR>\" } } ' --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" , \"spark.sql.catalogImplementation\" : \"hive\" , \"spark.dynamicAllocation.enabled\" : \"true\" , \"spark.dynamicAllocation.minExecutors\" : \"8\" , \"spark.dynamicAllocation.maxExecutors\" : \"40\" , \"spark.kubernetes.allocation.batch.size\" : \"8\" , \"spark.dynamicAllocation.executorAllocationRatio\" : \"1\" , \"spark.dynamicAllocation.shuffleTracking.enabled\" : \"true\" , \"spark.dynamicAllocation.shuffleTracking.timeout\" : \"300s\" , \"spark.kubernetes.driver.podTemplateFile\" : < S3 - URI - TO - DRIVER - POD - TEMPLATE > , \"spark.kubernetes.executor.podTemplateFile\" : < S3 - URI - TO - EXECUTOR - POD - TEMPLATE > } } ], \"monitoringConfiguration\" : { \"persistentAppUI\" : \"ENABLED\" , \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/aws/emr-containers/\" , \"logStreamNamePrefix\" : \"default\" } } } '","title":"Secrets"},{"location":"security/docs/spark/secrets/#using-secrets-in-emr-on-eks","text":"Secrets can be credentials to APIs, Databases or other resources. There are various ways these secrets can be passed to your containers, some of them are pod environment variable or Kubernetes Secrets. These methods are not secure, as for environment variable, secrets are stored in clear text and any authorized user who has access to Kubernetes cluster with admin privileges can read those secrets. Storing secrets using Kubernetes secrets is also not secure because they are not encrypted and only base36 encoded. There is a secure method to expose these secrets in EKS through the Secrets Store CSI Driver . The Secrets Store CSI Driver integrate with a secret store like AWS Secrets manager and mount the secrets as volume that can be accessed through your application code. This document describes how to set and use AWS Secrets Manager with EMR on EKS through the Secrets Store CSI Driver.","title":"Using Secrets in EMR on EKS"},{"location":"security/docs/spark/secrets/#deploy-secrets-store-csi-drivers-and-aws-secrets-and-configuration-provider","text":"","title":"Deploy Secrets Store CSI Drivers and AWS Secrets and Configuration Provider"},{"location":"security/docs/spark/secrets/#secrets-store-csi-drivers","text":"Configure EKS Cluster with Secrets Store CSI Driver . To learn more about AWS Secrets Manager CSI Driver you can refer to this link helm repo add secrets-store-csi-driver \\ https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts helm install -n kube-system csi-secrets-store \\ --set syncSecret.enabled=true \\ --set enableSecretRotation=true \\ secrets-store-csi-driver/secrets-store-csi-driver Deploy the AWS Secrets and Configuration Provider to use AWS Secrets Manager","title":"Secrets Store CSI Drivers"},{"location":"security/docs/spark/secrets/#aws-secrets-and-configuration-provider","text":"kubectl apply -f https://raw.githubusercontent.com/aws/secrets-store-csi-driver-provider-aws/main/deployment/aws-provider-installer.yaml","title":"AWS Secrets and Configuration Provider"},{"location":"security/docs/spark/secrets/#define-the-secretproviderclass","text":"The SecretProviderClass is how you present present your secret in Kubernetes, below you find a definition of a SecretProviderClass . There are few parameters that are important: The provider must be set to aws . The objectName must be the name of the secret you want to use as defined in AWS. Here the secret is called db-creds . The objectType must be set to secretsmanager . cat > db-cred.yaml << EOF apiVersion: secrets-store.csi.x-k8s.io/v1 kind: SecretProviderClass metadata: name: mysql-spark-secret spec: provider: aws parameters: objects: | - objectName: \"db-creds\" objectType: \"secretsmanager\" EOF kubectl apply -f db-cred.yaml -n <NAMESPACE> In the terminal apply the above command to create SecretProviderClass , The kubectl command must include the namespace where your job will be executed.","title":"Define the SecretProviderClass"},{"location":"security/docs/spark/secrets/#pod-template","text":"In the executor podtemplate you should define it as follow to mount the secret. The example below show how you can define it. There are few points that are important to mount the secret: secretProviderClass : this should have the same name as the one define above. In this case it is mysql-spark-secret . mountPath : Is where the secret is going to be available to the pod. In this example it will be in /var/secrets When defining the mountPath make sure you do not specify the ones reserved by EMR on EKS as defined here . apiVersion : v1 kind : Pod spec : containers : - name : spark - kubernetes - executors volumeMounts : - mountPath : \"/var/secrets\" name : mysql - cred readOnly : true volumes : - name : mysql - cred csi : driver : secrets - store . csi . k8s . io readOnly : true volumeAttributes : secretProviderClass : mysql - spark - secret This podtemplate must be uploaded to S3 and referenced in the job submit command as shown below. Note You must make sure that the RDS instance or your Database allow traffic from the instances where your driver and executors pods are running.","title":"Pod Template"},{"location":"security/docs/spark/secrets/#pyspark-code","text":"The example below shows pyspark code for connecting with a MySQL DB. The example assume the secret is stored in AWS secrets manager as defined above. The username is the key to retrieve the database user as stored in AWS Secrets Manager, and password is the key to retrieve the database password. It shows how you can retrieve the credentials from the mount point /var/secrets/ . The secret is stored in a file with the same name as it is defined in AWS in this case it is db-creds . This has been set in the podTemplate above. from pyspark.sql import SparkSession import json secret_path = \"/var/secrets/db-creds\" f = open ( secret_path , \"r\" ) mySecretDict = json . loads ( f . read ()) spark = SparkSession . builder . getOrCreate () str_jdbc_url = \"jdbc:<DB endpoint>\" str_Query = < QUERY > str_username = mySecretDict [ 'username' ] str_password = mySecretDict [ 'password' ] driver = \"com.mysql.jdbc.Driver\" jdbcDF = spark . read \\ . format ( \"jdbc\" ) \\ . option ( \"url\" , str_jdbc_url ) \\ . option ( \"driver\" , driver ) \\ . option ( \"query\" , str_Query ) \\ . option ( \"user\" , str_username ) \\ . option ( \"password\" , str_password ) \\ . load () jdbcDF . show ()","title":"PySpark code"},{"location":"security/docs/spark/secrets/#execute-the-job","text":"The command below can be used to run a job. Note : The supplied execution role MUST have access an IAM policy that allow it access to the secret defined in SecretProviderClass above. The IAM policy below shows the IAM actions that are needed. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [\"secretsmanager:GetSecretValue\", \"secretsmanager:DescribeSecret\"], \"Resource\": [<SECRET-ARN>] }] } aws emr - containers start - job - run -- virtual - cluster - id < EMR - VIRTUAL - CLUSTER - ID > -- name spark - jdbc -- execution - role - arn < EXECUTION - ROLE - ARN > -- release - label emr - 6 . 7 . 0 - latest -- job - driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"<S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE>\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1 --conf spark.jars=<S3-URI-TO-MYSQL-JDBC-JAR>\" } } ' --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" , \"spark.sql.catalogImplementation\" : \"hive\" , \"spark.dynamicAllocation.enabled\" : \"true\" , \"spark.dynamicAllocation.minExecutors\" : \"8\" , \"spark.dynamicAllocation.maxExecutors\" : \"40\" , \"spark.kubernetes.allocation.batch.size\" : \"8\" , \"spark.dynamicAllocation.executorAllocationRatio\" : \"1\" , \"spark.dynamicAllocation.shuffleTracking.enabled\" : \"true\" , \"spark.dynamicAllocation.shuffleTracking.timeout\" : \"300s\" , \"spark.kubernetes.driver.podTemplateFile\" : < S3 - URI - TO - DRIVER - POD - TEMPLATE > , \"spark.kubernetes.executor.podTemplateFile\" : < S3 - URI - TO - EXECUTOR - POD - TEMPLATE > } } ], \"monitoringConfiguration\" : { \"persistentAppUI\" : \"ENABLED\" , \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/aws/emr-containers/\" , \"logStreamNamePrefix\" : \"default\" } } } '","title":"Execute the job"},{"location":"storage/docs/","text":"","title":"Index"},{"location":"storage/docs/spark/ebs/","text":"Mount EBS Volume to spark driver and executor pods \u00b6 Amazon EBS volumes can be mounted on Spark driver and executor pods through static and dynamic provisioning. EKS support for EBS CSI driver Documentation for EBS CSI driver Static Provisioning \u00b6 EKS Admin Tasks \u00b6 First, create your EBS volumes: aws ec2 -- region < region > create - volume -- availability - zone < availability zone > -- size 50 { \"AvailabilityZone\" : \"<availability zone>\" , \"MultiAttachEnabled\" : false , \"Tags\" : [], \"Encrypted\" : false , \"VolumeType\" : \"gp2\" , \"VolumeId\" : \"<vol -id>\" , \"State\" : \"creating\" , \"Iops\" : 150 , \"SnapshotId\" : \"\" , \"CreateTime\" : \"2020-11-03T18:36:21.000Z\" , \"Size\" : 50 } Create Persistent Volume(PV) that has the EBS volume created above hardcoded: cat > ebs-static-pv.yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: ebs-static-pv spec: capacity: storage: 5Gi accessModes: - ReadWriteOnce storageClassName: gp2 awsElasticBlockStore: fsType: ext4 volumeID: <vol -id> EOF kubectl apply -f ebs-static-pv.yaml -n <namespace> Create Persistent Volume Claim(PVC) for the Persistent Volume created above: cat > ebs-static-pvc.yaml << EOF kind: PersistentVolumeClaim apiVersion: v1 metadata: name: ebs-static-pvc spec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi volumeName: ebs-static-pv EOF kubectl apply -f ebs-static-pvc.yaml -n <namespace> PVC - ebs-static-pvc can be used by spark developer to mount to the spark pod NOTE : Pods running in EKS worker nodes can only attach to the EBS volume provisioned in the same AZ as the EKS worker node. Use node selectors to schedule pods on EKS worker nodes the specified AZ. Spark Developer Tasks \u00b6 Request cat > spark - python - in - s3 - ebs - static - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-static-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-static-pvc\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - static - localdir . json Observed Behavior: When the job gets started, the pre-provisioned EBS volume is mounted to driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also you can verify the mount from the driver pod's spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export Dynamic Provisioning \u00b6 Dynamic Provisioning of volumes is supported for both, driver and executors for EMR versions >= 6.3.0 EKS Admin Tasks \u00b6 Create EBS Storage Class cat >demo-gp2-sc.yaml << EOF apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: demo-gp2-sc provisioner: kubernetes.io/aws-ebs parameters: type: gp2 reclaimPolicy: Retain allowVolumeExpansion: true mountOptions: - debug volumeBindingMode: Immediate EOF kubectl apply -f demo-gp2-sc.yaml create Persistent Volume for the EBS storage class - demo-gp2-sc cat >ebs-demo-gp2-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: ebs-demo-gp2-claim labels: app: chicago spec: storageClassName: demo-gp2-sc accessModes: - ReadWriteOnce resources: requests: storage: 100Gi EOF kubectl apply -f ebs-demo-gp2-claim.yaml -n <namespace> Spark Developer Tasks \u00b6 Request cat > spark - python - in - s3 - ebs - dynamic - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-dynamic-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-demo-gp2-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - dynamic - localdir . json Observed Behavior: When the job gets started an EBS volume is provisioned dynamically by the EBS CSI driver and mounted to the driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also, you can verify the mount from driver pod spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export","title":"EBS"},{"location":"storage/docs/spark/ebs/#mount-ebs-volume-to-spark-driver-and-executor-pods","text":"Amazon EBS volumes can be mounted on Spark driver and executor pods through static and dynamic provisioning. EKS support for EBS CSI driver Documentation for EBS CSI driver","title":"Mount EBS Volume to spark driver and executor pods"},{"location":"storage/docs/spark/ebs/#static-provisioning","text":"","title":"Static Provisioning"},{"location":"storage/docs/spark/ebs/#eks-admin-tasks","text":"First, create your EBS volumes: aws ec2 -- region < region > create - volume -- availability - zone < availability zone > -- size 50 { \"AvailabilityZone\" : \"<availability zone>\" , \"MultiAttachEnabled\" : false , \"Tags\" : [], \"Encrypted\" : false , \"VolumeType\" : \"gp2\" , \"VolumeId\" : \"<vol -id>\" , \"State\" : \"creating\" , \"Iops\" : 150 , \"SnapshotId\" : \"\" , \"CreateTime\" : \"2020-11-03T18:36:21.000Z\" , \"Size\" : 50 } Create Persistent Volume(PV) that has the EBS volume created above hardcoded: cat > ebs-static-pv.yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: ebs-static-pv spec: capacity: storage: 5Gi accessModes: - ReadWriteOnce storageClassName: gp2 awsElasticBlockStore: fsType: ext4 volumeID: <vol -id> EOF kubectl apply -f ebs-static-pv.yaml -n <namespace> Create Persistent Volume Claim(PVC) for the Persistent Volume created above: cat > ebs-static-pvc.yaml << EOF kind: PersistentVolumeClaim apiVersion: v1 metadata: name: ebs-static-pvc spec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi volumeName: ebs-static-pv EOF kubectl apply -f ebs-static-pvc.yaml -n <namespace> PVC - ebs-static-pvc can be used by spark developer to mount to the spark pod NOTE : Pods running in EKS worker nodes can only attach to the EBS volume provisioned in the same AZ as the EKS worker node. Use node selectors to schedule pods on EKS worker nodes the specified AZ.","title":"EKS Admin Tasks"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks","text":"Request cat > spark - python - in - s3 - ebs - static - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-static-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-static-pvc\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - static - localdir . json Observed Behavior: When the job gets started, the pre-provisioned EBS volume is mounted to driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also you can verify the mount from the driver pod's spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export","title":"Spark Developer Tasks"},{"location":"storage/docs/spark/ebs/#dynamic-provisioning","text":"Dynamic Provisioning of volumes is supported for both, driver and executors for EMR versions >= 6.3.0","title":"Dynamic Provisioning"},{"location":"storage/docs/spark/ebs/#eks-admin-tasks_1","text":"Create EBS Storage Class cat >demo-gp2-sc.yaml << EOF apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: demo-gp2-sc provisioner: kubernetes.io/aws-ebs parameters: type: gp2 reclaimPolicy: Retain allowVolumeExpansion: true mountOptions: - debug volumeBindingMode: Immediate EOF kubectl apply -f demo-gp2-sc.yaml create Persistent Volume for the EBS storage class - demo-gp2-sc cat >ebs-demo-gp2-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: ebs-demo-gp2-claim labels: app: chicago spec: storageClassName: demo-gp2-sc accessModes: - ReadWriteOnce resources: requests: storage: 100Gi EOF kubectl apply -f ebs-demo-gp2-claim.yaml -n <namespace>","title":"EKS Admin Tasks"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks_1","text":"Request cat > spark - python - in - s3 - ebs - dynamic - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-dynamic-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-demo-gp2-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - dynamic - localdir . json Observed Behavior: When the job gets started an EBS volume is provisioned dynamically by the EBS CSI driver and mounted to the driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also, you can verify the mount from driver pod spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export","title":"Spark Developer Tasks"},{"location":"storage/docs/spark/fsx-lustre/","text":"EMR Containers integration with FSx for Lustre \u00b6 Amazon EKS clusters provide the compute and ephemeral storage for Spark workloads. Ephemeral storage provided by EKS is allocated from the EKS worker node's disk storage and the lifecycle of the storage is bound by the lifecycle of the driver and executor pod. Need for durable storage: When multiple spark applications are executed as part of a data pipeline, there are scenarios where data from one spark application is passed to subsequent spark applications - in this case data can be persisted in S3. Alternatively, this data can also be persisted in FSx for Lustre . FSx for Lustre provides a fully managed, scalable, POSIX compliant native filesystem interface for the data in s3. With FSx, your torage is decoupled from your compute and has its own lifecycle. FSx for Lustre Volumes can be mounted on spark driver and executor pods through static and dynamic provisioning. Data used in the below example is from AWS Open data Registry FSx for Lustre POSIX permissions \u00b6 When a Lustre filesystem is mounted to driver and executor pods, and if the S3 objects does not have required metadata, the mounted volume defaults ownership of the file system to root . EMR on EKS executes the driver and executor pods with UID(999), GID (1000) and groups(1000 and 65534). In this scenario, the spark application has read only access to the mounted Lustre file system. Below are a few approaches that can be considered: Tag Metadata to S3 object \u00b6 Applications writing to S3 can tag the S3 objects with the metadata that FSx for Lustre requires. Walkthrough: Attaching POSIX permissions when uploading objects into an S3 bucket provides a guided tutorial. FSx for Lustre will convert this tagged metadata to corresponding POSIX permissions when mounting Lustre file system to the driver and executor pods. EMR on EKS spawns the driver and executor pods as non-root user( UID -999, GID - 1000, groups - 1000, 65534 ). To enable the spark application to write to the mounted file system, (UID - 999 ) can be made as the file-owner and supplemental group 65534 be made as the file-group . For S3 objects that already exists with no metadata tagging, there can be a process that recursively tags all the S3 objects with the required metadata. Below is an example: 1. Create FSx for Lustre file system to the S3 prefix. 2. Create Persistent Volume and Persistent Volume claim for the created FSx for Lustre file system 3. Run a pod as root user with FSx for Lustre mounted with the PVC created in Step 2. ``` apiVersion: v1 kind: Pod metadata: name: chmod-fsx-pod namespace: test-demo spec: containers: - name: ownership-change image: amazonlinux:2 command: [\"sh\", \"-c\", \"chown -hR +999:+65534 /data\"] volumeMounts: - name: persistent-storage mountPath: /data volumes: - name: persistent-storage persistentVolumeClaim: claimName: fsx-static-root-claim ``` Run a data repository task with import path and export path pointing to the same S3 prefix. This will export the POSIX permission from FSx for Lustre file system as metadata, that is tagged on S3 objects. Now that the S3 objects are tagged with metadata, the spark application with FSx for Lustre filesystem mounted will have write access. Static Provisioning \u00b6 Provision a FSx for Lustre cluster \u00b6 FSx for Luster can also be provisioned through aws cli How to decide what type of FSx for Lustre file system you need ? Create a Security Group to attach to FSx for Lustre file system as below Points to Note: Security group attached to the EKS worker nodes is given access on port number 988, 1021-1023 in inbound rules. Security group specified when creating the FSx for Lustre filesystem is given access on port number 988, 1021-1023 in inbound rules. Fsx for Lustre Provisioning through aws cli cat fsxLustreConfig.json << EOF { \"ClientRequestToken\": \"EMRContainers-fsxLustre-demo\", \"FileSystemType\": \"LUSTRE\", \"StorageCapacity\": 1200, \"StorageType\": \"SSD\", \"SubnetIds\": [ \"<subnet-id>\" ], \"SecurityGroupIds\": [ \"<securitygroup-id>\" ], \"LustreConfiguration\": { \"ImportPath\": \"s3://<s3 prefix>/\", \"ExportPath\": \"s3://<s3 prefix>/\", \"DeploymentType\": \"PERSISTENT_1\", \"AutoImportPolicy\": \"NEW_CHANGED\", \"PerUnitStorageThroughput\": 200 } } EOF Run the aws-cli command to create the FSx for Lustre filesystem as below. aws fsx create-file-system --cli-input-json file:///fsxLustreConfig.json Response is as below { \"FileSystem\" : { \"VpcId\" : \"<vpc id>\" , \"Tags\" : [], \"StorageType\" : \"SSD\" , \"SubnetIds\" : [ \"<subnet-id>\" ], \"FileSystemType\" : \"LUSTRE\" , \"CreationTime\" : 1603752401.183 , \"ResourceARN\" : \"<fsx resource arn>\" , \"StorageCapacity\" : 1200 , \"LustreConfiguration\" : { \"CopyTagsToBackups\" : false , \"WeeklyMaintenanceStartTime\" : \"7:11:30\" , \"DataRepositoryConfiguration\" : { \"ImportPath\" : \"s3://<s3 prefix>\" , \"AutoImportPolicy\" : \"NEW_CHANGED\" , \"ImportedFileChunkSize\" : 1024 , \"Lifecycle\" : \"CREATING\" , \"ExportPath\" : \"s3://<s3 prefix>/\" }, \"DeploymentType\" : \"PERSISTENT_1\" , \"PerUnitStorageThroughput\" : 200 , \"MountName\" : \"mvmxtbmv\" }, \"FileSystemId\" : \"<filesystem id>\" , \"DNSName\" : \"<filesystem id>.fsx.<region>.amazonaws.com\" , \"KmsKeyId\" : \"arn:aws:kms:<region>:<account>:key/<key id>\" , \"OwnerId\" : \"<account>\" , \"Lifecycle\" : \"CREATING\" } } EKS admin tasks \u00b6 Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume and Persistent Volume Claim for FSx for Lustre FSx for Lustre file system is created as described above - Provision a FSx for Lustre cluster Once provisioned, a persistent volume - as specified below is created with a direct (hard-coded) reference to the created lustre file system. A Persistent Volume claim for this persistent volume will always use the same file system. cat > fsxLustre - static - pv . yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: fsx - pv spec: capacity: storage: 1200 Gi volumeMode: Filesystem accessModes: - ReadWriteMany mountOptions: - flock persistentVolumeReclaimPolicy: Recycle csi: driver: fsx . csi . aws . com volumeHandle: < filesystem id > volumeAttributes: dnsname: < filesystem id > . fsx . < region > . amazonaws . com mountname: mvmxtbmv EOF kubectl apply -f fsxLustre-static-pv.yaml Now, a Persistent Volume Claim (PVC) needs to be created that references PV created above. cat >fsxLustre-static-pvc.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-claim namespace: ns1 spec: accessModes: - ReadWriteMany storageClassName: \"\" resources: requests: storage: 1200Gi volumeName: fsx-pv EOF kubectl apply - f fsxLustre - static - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster > Spark Developer Tasks \u00b6 Now spark applications can use fsx-claim in their spark application config to mount the FSx for Lustre filesystem to driver and executor container volumes. cat > spark - python - in - s3 - fsx . json << EOF { \"name\" : \"spark-python-in-s3-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx.json Expected Behavior: All spark jobs that are run with persistent volume claims as fsx-claim will mount to the statically created FSx for Lustre file system. Use case: A data pipeline consisting of 10 spark applications can all be mounted to the statically created FSx for Lustre file system and can write the intermediate output to a particular folder. The next spark job in the data pipeline that is dependent on this data can read from FSx for Lustre. Data that needs to be persisted beyond the scope of the data pipeline can be exported to S3 by creating data repository tasks Data that is used often by multiple spark applications can also be stored in FSx for Lustre for improved performance. Dynamic Provisioning \u00b6 A FSx for Lustre file system can be provisioned on-demand. A Storage-class resource is created and that provisions FSx for Lustre file system dynamically. A PVC is created and refers to the storage class resource that was created. Whenever a pod refers to the PVC, the storage class invokes the FSx for Lustre Container Storage Interface (CSI) to provision a Lustre file system on the fly dynamically. In this model, FSx for Lustre of type Scratch File Systems is provisioned. EKS Admin Tasks \u00b6 Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume Claim( fsx-dynamic-claim ) for FSx for Lustre. Create PVC for dynamic provisioning with fsx-sc storage class. cat >fsx-dynamic-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-dynamic-claim spec: accessModes: - ReadWriteMany storageClassName: fsx-sc resources: requests: storage: 3600Gi EOF kubectl apply - f fsx - dynamic - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster > Spark Developer Tasks \u00b6 cat > spark - python - in - s3 - fsx - dynamic . json << EOF { \"name\" : \"spark-python-in-s3-fsx-dynamic\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.local.dir\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName\" : \"fsx-dynamic-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx-dynamic.json Expected Result: Statically provisioned FSx for Lustre is mounted to /var/data/ as before for the driver pod. For all the executors a SCRATCH 1 deployment type FSx for Lustre is provisioned on the fly dynamically by the Storage class that was created. There will be a latency before the first executor can start running - because the Lustre has to be created. Once it is created the same Lustre file system is mounted to all the executors. Also note - \"spark.local.dir\":\"/var/spark/spill/\" is used to force executor to use this folder mounted to Lustre for all spill and shuffle data. Once the spark job is completed, the Lustre file system is deleted or retained based on the PVC configuration. This dynamically created Lustre file system is mapped to a S3 path like the statically created filesystem. FSx-csi user guide","title":"FSx for Lustre"},{"location":"storage/docs/spark/fsx-lustre/#emr-containers-integration-with-fsx-for-lustre","text":"Amazon EKS clusters provide the compute and ephemeral storage for Spark workloads. Ephemeral storage provided by EKS is allocated from the EKS worker node's disk storage and the lifecycle of the storage is bound by the lifecycle of the driver and executor pod. Need for durable storage: When multiple spark applications are executed as part of a data pipeline, there are scenarios where data from one spark application is passed to subsequent spark applications - in this case data can be persisted in S3. Alternatively, this data can also be persisted in FSx for Lustre . FSx for Lustre provides a fully managed, scalable, POSIX compliant native filesystem interface for the data in s3. With FSx, your torage is decoupled from your compute and has its own lifecycle. FSx for Lustre Volumes can be mounted on spark driver and executor pods through static and dynamic provisioning. Data used in the below example is from AWS Open data Registry","title":"EMR Containers integration with FSx for Lustre"},{"location":"storage/docs/spark/fsx-lustre/#fsx-for-lustre-posix-permissions","text":"When a Lustre filesystem is mounted to driver and executor pods, and if the S3 objects does not have required metadata, the mounted volume defaults ownership of the file system to root . EMR on EKS executes the driver and executor pods with UID(999), GID (1000) and groups(1000 and 65534). In this scenario, the spark application has read only access to the mounted Lustre file system. Below are a few approaches that can be considered:","title":"FSx for Lustre POSIX permissions"},{"location":"storage/docs/spark/fsx-lustre/#tag-metadata-to-s3-object","text":"Applications writing to S3 can tag the S3 objects with the metadata that FSx for Lustre requires. Walkthrough: Attaching POSIX permissions when uploading objects into an S3 bucket provides a guided tutorial. FSx for Lustre will convert this tagged metadata to corresponding POSIX permissions when mounting Lustre file system to the driver and executor pods. EMR on EKS spawns the driver and executor pods as non-root user( UID -999, GID - 1000, groups - 1000, 65534 ). To enable the spark application to write to the mounted file system, (UID - 999 ) can be made as the file-owner and supplemental group 65534 be made as the file-group . For S3 objects that already exists with no metadata tagging, there can be a process that recursively tags all the S3 objects with the required metadata. Below is an example: 1. Create FSx for Lustre file system to the S3 prefix. 2. Create Persistent Volume and Persistent Volume claim for the created FSx for Lustre file system 3. Run a pod as root user with FSx for Lustre mounted with the PVC created in Step 2. ``` apiVersion: v1 kind: Pod metadata: name: chmod-fsx-pod namespace: test-demo spec: containers: - name: ownership-change image: amazonlinux:2 command: [\"sh\", \"-c\", \"chown -hR +999:+65534 /data\"] volumeMounts: - name: persistent-storage mountPath: /data volumes: - name: persistent-storage persistentVolumeClaim: claimName: fsx-static-root-claim ``` Run a data repository task with import path and export path pointing to the same S3 prefix. This will export the POSIX permission from FSx for Lustre file system as metadata, that is tagged on S3 objects. Now that the S3 objects are tagged with metadata, the spark application with FSx for Lustre filesystem mounted will have write access.","title":"Tag Metadata to S3 object"},{"location":"storage/docs/spark/fsx-lustre/#static-provisioning","text":"","title":"Static Provisioning"},{"location":"storage/docs/spark/fsx-lustre/#provision-a-fsx-for-lustre-cluster","text":"FSx for Luster can also be provisioned through aws cli How to decide what type of FSx for Lustre file system you need ? Create a Security Group to attach to FSx for Lustre file system as below Points to Note: Security group attached to the EKS worker nodes is given access on port number 988, 1021-1023 in inbound rules. Security group specified when creating the FSx for Lustre filesystem is given access on port number 988, 1021-1023 in inbound rules. Fsx for Lustre Provisioning through aws cli cat fsxLustreConfig.json << EOF { \"ClientRequestToken\": \"EMRContainers-fsxLustre-demo\", \"FileSystemType\": \"LUSTRE\", \"StorageCapacity\": 1200, \"StorageType\": \"SSD\", \"SubnetIds\": [ \"<subnet-id>\" ], \"SecurityGroupIds\": [ \"<securitygroup-id>\" ], \"LustreConfiguration\": { \"ImportPath\": \"s3://<s3 prefix>/\", \"ExportPath\": \"s3://<s3 prefix>/\", \"DeploymentType\": \"PERSISTENT_1\", \"AutoImportPolicy\": \"NEW_CHANGED\", \"PerUnitStorageThroughput\": 200 } } EOF Run the aws-cli command to create the FSx for Lustre filesystem as below. aws fsx create-file-system --cli-input-json file:///fsxLustreConfig.json Response is as below { \"FileSystem\" : { \"VpcId\" : \"<vpc id>\" , \"Tags\" : [], \"StorageType\" : \"SSD\" , \"SubnetIds\" : [ \"<subnet-id>\" ], \"FileSystemType\" : \"LUSTRE\" , \"CreationTime\" : 1603752401.183 , \"ResourceARN\" : \"<fsx resource arn>\" , \"StorageCapacity\" : 1200 , \"LustreConfiguration\" : { \"CopyTagsToBackups\" : false , \"WeeklyMaintenanceStartTime\" : \"7:11:30\" , \"DataRepositoryConfiguration\" : { \"ImportPath\" : \"s3://<s3 prefix>\" , \"AutoImportPolicy\" : \"NEW_CHANGED\" , \"ImportedFileChunkSize\" : 1024 , \"Lifecycle\" : \"CREATING\" , \"ExportPath\" : \"s3://<s3 prefix>/\" }, \"DeploymentType\" : \"PERSISTENT_1\" , \"PerUnitStorageThroughput\" : 200 , \"MountName\" : \"mvmxtbmv\" }, \"FileSystemId\" : \"<filesystem id>\" , \"DNSName\" : \"<filesystem id>.fsx.<region>.amazonaws.com\" , \"KmsKeyId\" : \"arn:aws:kms:<region>:<account>:key/<key id>\" , \"OwnerId\" : \"<account>\" , \"Lifecycle\" : \"CREATING\" } }","title":"Provision a FSx for Lustre cluster"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks","text":"Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume and Persistent Volume Claim for FSx for Lustre FSx for Lustre file system is created as described above - Provision a FSx for Lustre cluster Once provisioned, a persistent volume - as specified below is created with a direct (hard-coded) reference to the created lustre file system. A Persistent Volume claim for this persistent volume will always use the same file system. cat > fsxLustre - static - pv . yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: fsx - pv spec: capacity: storage: 1200 Gi volumeMode: Filesystem accessModes: - ReadWriteMany mountOptions: - flock persistentVolumeReclaimPolicy: Recycle csi: driver: fsx . csi . aws . com volumeHandle: < filesystem id > volumeAttributes: dnsname: < filesystem id > . fsx . < region > . amazonaws . com mountname: mvmxtbmv EOF kubectl apply -f fsxLustre-static-pv.yaml Now, a Persistent Volume Claim (PVC) needs to be created that references PV created above. cat >fsxLustre-static-pvc.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-claim namespace: ns1 spec: accessModes: - ReadWriteMany storageClassName: \"\" resources: requests: storage: 1200Gi volumeName: fsx-pv EOF kubectl apply - f fsxLustre - static - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster >","title":"EKS admin tasks"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks","text":"Now spark applications can use fsx-claim in their spark application config to mount the FSx for Lustre filesystem to driver and executor container volumes. cat > spark - python - in - s3 - fsx . json << EOF { \"name\" : \"spark-python-in-s3-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx.json Expected Behavior: All spark jobs that are run with persistent volume claims as fsx-claim will mount to the statically created FSx for Lustre file system. Use case: A data pipeline consisting of 10 spark applications can all be mounted to the statically created FSx for Lustre file system and can write the intermediate output to a particular folder. The next spark job in the data pipeline that is dependent on this data can read from FSx for Lustre. Data that needs to be persisted beyond the scope of the data pipeline can be exported to S3 by creating data repository tasks Data that is used often by multiple spark applications can also be stored in FSx for Lustre for improved performance.","title":"Spark Developer Tasks"},{"location":"storage/docs/spark/fsx-lustre/#dynamic-provisioning","text":"A FSx for Lustre file system can be provisioned on-demand. A Storage-class resource is created and that provisions FSx for Lustre file system dynamically. A PVC is created and refers to the storage class resource that was created. Whenever a pod refers to the PVC, the storage class invokes the FSx for Lustre Container Storage Interface (CSI) to provision a Lustre file system on the fly dynamically. In this model, FSx for Lustre of type Scratch File Systems is provisioned.","title":"Dynamic Provisioning"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks_1","text":"Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume Claim( fsx-dynamic-claim ) for FSx for Lustre. Create PVC for dynamic provisioning with fsx-sc storage class. cat >fsx-dynamic-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-dynamic-claim spec: accessModes: - ReadWriteMany storageClassName: fsx-sc resources: requests: storage: 3600Gi EOF kubectl apply - f fsx - dynamic - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster >","title":"EKS Admin Tasks"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks_1","text":"cat > spark - python - in - s3 - fsx - dynamic . json << EOF { \"name\" : \"spark-python-in-s3-fsx-dynamic\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.local.dir\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName\" : \"fsx-dynamic-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx-dynamic.json Expected Result: Statically provisioned FSx for Lustre is mounted to /var/data/ as before for the driver pod. For all the executors a SCRATCH 1 deployment type FSx for Lustre is provisioned on the fly dynamically by the Storage class that was created. There will be a latency before the first executor can start running - because the Lustre has to be created. Once it is created the same Lustre file system is mounted to all the executors. Also note - \"spark.local.dir\":\"/var/spark/spill/\" is used to force executor to use this folder mounted to Lustre for all spill and shuffle data. Once the spark job is completed, the Lustre file system is deleted or retained based on the PVC configuration. This dynamically created Lustre file system is mapped to a S3 path like the statically created filesystem. FSx-csi user guide","title":"Spark Developer Tasks"},{"location":"storage/docs/spark/instance-store/","text":"Instance Store Volumes \u00b6 When working with Spark workloads, it might be useful to use instances powered by SSD instance store volumes to improve the performance of your jobs. This storage is located on disks that are physically attached to the host computer and can provide better performance compared to traditional EBS volumes. In the context of Spark, this might be beneficial for wide transformations (e.g. JOIN, GROUP BY) that generate a significant amount of shuffle data that Spark persists on the local filesystem of the instances where the executors are running. In this document, we highlight two approaches to leverage NVMe disks in your workloads when using EMR on EKS. For a list of instances supporting NVMe disks, see Instance store volumes in the Amazon EC2 documentation. Mount kubelet pod directory on NVMe disks \u00b6 The kublet service manages the lifecycle of pod containers that are created using Kubernetes. When a pod is launched on an instance, an ephemeral volume is automatically created for the pod, and this volume is mapped in a sub-directory within the path /var/lib/kubelet of the host node. This volume folder exists for the lifetime of K8s pod, and it will be automatically deleted once the pod ceases to exists. In order to leverage NVMe disk attached to an EC2 node in our Spark application, we should perform the following actions during node bootstrap: Prepare the NVMe disks attached to the instance (format disks and create a partition) Mount the /var/lib/kubelet/pods path on the NVMe By doing this, all local files generated by your Spark job (blockmanager data, shuffle data, etc.) will be automatically written to NVMe disks. This way, you don't have to configure Spark volume path when launching the pod (driver or executor). This approach is easier to adopt because it doesn\u2019t require any additional configuration in your job. Besides, once the job is completed, all the data stored in ephemeral volumes will be automatically deleted when the EC2 instance is deleted. However, if you have multiple NVMe disks attached to the instance, you need to create RAID0 configuration of all the disks before mounting the /var/lib/kubelet/pods directory on the RAID partition. Without a RAID setup, it will not be possible to leverage all the disks capacity available on the node. The following example shows how to create a node group in your cluster using this approach. In order to prepare our NVMe disks, we can use the eksctl preBootstrapCommands definition while creating the node group. The script will perform the following actions: For instances with a single NVMe disk, format the filesystem, create a Linux partition (e.g. ext4, xfs, etc.) For instances with multiple NVMe disks, create a RAID 0 configuration across all available volumes Once the disks are formatted and ready to use, we will mount the folder /var/lib/kubelet/pods using the filesystem and setup correct permissions. Below, you can find an example of an eksctl configuration to create a managed node group using this approach. Example apiVersion : eksctl . io / v1alpha5 kind : ClusterConfig metadata : name : YOUR_CLUSTER_NAME region : YOUR_REGION managedNodeGroups : - name : ng - c5d - 9 xlarge instanceType : c5d . 9 xlarge desiredCapacity : 1 privateNetworking : true subnets : - YOUR_NG_SUBNET preBootstrapCommands : # commands executed as root - yum install - y mdadm nvme - cli - nvme_disks =( $ ( nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk - F '[[:space:]][[:space:]]+' '{print $1}' )) && [[ $ { # nvme_disks [ @ ]} - eq 1 ]] && mkfs . ext4 - F $ { nvme_disks [*]} && systemctl stop docker && mkdir - p /var/lib/kubelet/pods && mount ${nvme_disks[*]} /var/lib/kubelet/pods && chmod 750 /var/lib/ docker && systemctl start docker - nvme_disks =( $ ( nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk - F '[[:space:]][[:space:]]+' '{print $1}' )) && [[ $ { # nvme_disks [ @ ]} - ge 2 ]] && mdadm -- create -- verbose /dev/md0 --level=0 --raid-devices=${#nvme_disks[@]} ${nvme_disks[*]} && mkfs.ext4 -F /dev/md0 && systemctl stop docker && mkdir -p /var/lib/kubelet/pods && mount /dev/md0 /var/lib/kubelet/pods && chmod 750 /var/lib/ docker && systemctl start docker Benefits No need to mount the disk using Spark configurations or pod templates Data generated by the application, will immediately be deleted at the pod termination. Data will be also purged in case of pod failures. One time configuration for the node group Cons If multiple jobs are allocated on the same EC2 instance, contention of disk resources will occur because it is not possible to allocate instance store volume resources across jobs Mount NVMe disks as data volumes \u00b6 In this section, we\u2019re going to explicitly mount instance store volumes as the mount path in Spark configuration for drivers and executors As in the previous example, this script will automatically format the instance store volumes and create an xfs partition. The disks are then mounted in local folders called /spark_data_IDX where IDX is an integer that corresponds to the disk mounted. Example apiVersion : eksctl . io / v1alpha5 kind : ClusterConfig metadata : name : YOUR_CLUSTER_NAME region : YOUR_REGION managedNodeGroups : - name : ng - m5d - 4 xlarge instanceType : m5d . 4 xlarge desiredCapacity : 1 privateNetworking : true subnets : - YOUR_NG_SUBNET preBootstrapCommands : # commands executed as root - \"IDX=1;for DEV in /dev/nvme[1-9]n1;do mkfs.xfs ${DEV}; mkdir -p /spark_data_${IDX}; echo ${DEV} /spark_data_${IDX} xfs defaults,noatime 1 2 >> /etc/fstab; IDX=$((${IDX} + 1)); done\" - \"mount -a\" - \"chown 999:1000 /spark_data_*\" In order to successfully use ephemeral volumes within Spark, you need to specify additional configurations. In addition to spark configuration, the mounted volume name should start with spark-local-dir- . Below an example configuration provided during the EMR on EKS job submission, that shows how to configure Spark to use 2 volumes as local storage for the job. Spark Configurations { \"name\": ...., \"virtualClusterId\": ...., \"executionRoleArn\": ...., \"releaseLabel\": ...., \"jobDriver\": ...., \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.path\": \"/spark_data_1\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.readOnly\": \"false\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.options.path\": \"/spark_data_1\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.path\": \"/spark_data_2\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.readOnly\": \"false\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.options.path\": \"/spark_data_2\" } } ] } } Please note that for this approach it is required to specify the following configurations for each volume that you want to use. (IDX is a label to identify the volume mounted) # Mount path on the host node spark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.options.path # Mount path on the k8s pod spark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.path # (boolean) Should be defined as false to allow Spark to write in the path spark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.readOnly Benefits You can allocate dedicated resources of instance store volumes across your Spark jobs (For example, lets take a scenario where an EC2 instance has two instance store volumes. If you run two spark jobs on this node, you can dedicate one volume per Spark job) Cons Additional configurations are required for Spark jobs to use instance store volumes. This approach can be error prone if you don\u2019t control the instance types being used (for example, multiple node groups with different instance types). You can mitigate this issue by using k8s node selectors and specify instance type in your spark configuraiton: spark.kubernetes.node.selector.node.kubernetes.io/instance-type Data created on the volumes is automatically deleted once the job is completed and instance is terminated. However, you need to extra measures to delete the data on instance store volumes if EC2 instance is re-used or is not terminated.","title":"Instance Store"},{"location":"storage/docs/spark/instance-store/#instance-store-volumes","text":"When working with Spark workloads, it might be useful to use instances powered by SSD instance store volumes to improve the performance of your jobs. This storage is located on disks that are physically attached to the host computer and can provide better performance compared to traditional EBS volumes. In the context of Spark, this might be beneficial for wide transformations (e.g. JOIN, GROUP BY) that generate a significant amount of shuffle data that Spark persists on the local filesystem of the instances where the executors are running. In this document, we highlight two approaches to leverage NVMe disks in your workloads when using EMR on EKS. For a list of instances supporting NVMe disks, see Instance store volumes in the Amazon EC2 documentation.","title":"Instance Store Volumes"},{"location":"storage/docs/spark/instance-store/#mount-kubelet-pod-directory-on-nvme-disks","text":"The kublet service manages the lifecycle of pod containers that are created using Kubernetes. When a pod is launched on an instance, an ephemeral volume is automatically created for the pod, and this volume is mapped in a sub-directory within the path /var/lib/kubelet of the host node. This volume folder exists for the lifetime of K8s pod, and it will be automatically deleted once the pod ceases to exists. In order to leverage NVMe disk attached to an EC2 node in our Spark application, we should perform the following actions during node bootstrap: Prepare the NVMe disks attached to the instance (format disks and create a partition) Mount the /var/lib/kubelet/pods path on the NVMe By doing this, all local files generated by your Spark job (blockmanager data, shuffle data, etc.) will be automatically written to NVMe disks. This way, you don't have to configure Spark volume path when launching the pod (driver or executor). This approach is easier to adopt because it doesn\u2019t require any additional configuration in your job. Besides, once the job is completed, all the data stored in ephemeral volumes will be automatically deleted when the EC2 instance is deleted. However, if you have multiple NVMe disks attached to the instance, you need to create RAID0 configuration of all the disks before mounting the /var/lib/kubelet/pods directory on the RAID partition. Without a RAID setup, it will not be possible to leverage all the disks capacity available on the node. The following example shows how to create a node group in your cluster using this approach. In order to prepare our NVMe disks, we can use the eksctl preBootstrapCommands definition while creating the node group. The script will perform the following actions: For instances with a single NVMe disk, format the filesystem, create a Linux partition (e.g. ext4, xfs, etc.) For instances with multiple NVMe disks, create a RAID 0 configuration across all available volumes Once the disks are formatted and ready to use, we will mount the folder /var/lib/kubelet/pods using the filesystem and setup correct permissions. Below, you can find an example of an eksctl configuration to create a managed node group using this approach. Example apiVersion : eksctl . io / v1alpha5 kind : ClusterConfig metadata : name : YOUR_CLUSTER_NAME region : YOUR_REGION managedNodeGroups : - name : ng - c5d - 9 xlarge instanceType : c5d . 9 xlarge desiredCapacity : 1 privateNetworking : true subnets : - YOUR_NG_SUBNET preBootstrapCommands : # commands executed as root - yum install - y mdadm nvme - cli - nvme_disks =( $ ( nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk - F '[[:space:]][[:space:]]+' '{print $1}' )) && [[ $ { # nvme_disks [ @ ]} - eq 1 ]] && mkfs . ext4 - F $ { nvme_disks [*]} && systemctl stop docker && mkdir - p /var/lib/kubelet/pods && mount ${nvme_disks[*]} /var/lib/kubelet/pods && chmod 750 /var/lib/ docker && systemctl start docker - nvme_disks =( $ ( nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk - F '[[:space:]][[:space:]]+' '{print $1}' )) && [[ $ { # nvme_disks [ @ ]} - ge 2 ]] && mdadm -- create -- verbose /dev/md0 --level=0 --raid-devices=${#nvme_disks[@]} ${nvme_disks[*]} && mkfs.ext4 -F /dev/md0 && systemctl stop docker && mkdir -p /var/lib/kubelet/pods && mount /dev/md0 /var/lib/kubelet/pods && chmod 750 /var/lib/ docker && systemctl start docker Benefits No need to mount the disk using Spark configurations or pod templates Data generated by the application, will immediately be deleted at the pod termination. Data will be also purged in case of pod failures. One time configuration for the node group Cons If multiple jobs are allocated on the same EC2 instance, contention of disk resources will occur because it is not possible to allocate instance store volume resources across jobs","title":"Mount kubelet pod directory on NVMe disks"},{"location":"storage/docs/spark/instance-store/#mount-nvme-disks-as-data-volumes","text":"In this section, we\u2019re going to explicitly mount instance store volumes as the mount path in Spark configuration for drivers and executors As in the previous example, this script will automatically format the instance store volumes and create an xfs partition. The disks are then mounted in local folders called /spark_data_IDX where IDX is an integer that corresponds to the disk mounted. Example apiVersion : eksctl . io / v1alpha5 kind : ClusterConfig metadata : name : YOUR_CLUSTER_NAME region : YOUR_REGION managedNodeGroups : - name : ng - m5d - 4 xlarge instanceType : m5d . 4 xlarge desiredCapacity : 1 privateNetworking : true subnets : - YOUR_NG_SUBNET preBootstrapCommands : # commands executed as root - \"IDX=1;for DEV in /dev/nvme[1-9]n1;do mkfs.xfs ${DEV}; mkdir -p /spark_data_${IDX}; echo ${DEV} /spark_data_${IDX} xfs defaults,noatime 1 2 >> /etc/fstab; IDX=$((${IDX} + 1)); done\" - \"mount -a\" - \"chown 999:1000 /spark_data_*\" In order to successfully use ephemeral volumes within Spark, you need to specify additional configurations. In addition to spark configuration, the mounted volume name should start with spark-local-dir- . Below an example configuration provided during the EMR on EKS job submission, that shows how to configure Spark to use 2 volumes as local storage for the job. Spark Configurations { \"name\": ...., \"virtualClusterId\": ...., \"executionRoleArn\": ...., \"releaseLabel\": ...., \"jobDriver\": ...., \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.path\": \"/spark_data_1\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.readOnly\": \"false\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.options.path\": \"/spark_data_1\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.path\": \"/spark_data_2\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.readOnly\": \"false\", \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.options.path\": \"/spark_data_2\" } } ] } } Please note that for this approach it is required to specify the following configurations for each volume that you want to use. (IDX is a label to identify the volume mounted) # Mount path on the host node spark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.options.path # Mount path on the k8s pod spark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.path # (boolean) Should be defined as false to allow Spark to write in the path spark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.readOnly Benefits You can allocate dedicated resources of instance store volumes across your Spark jobs (For example, lets take a scenario where an EC2 instance has two instance store volumes. If you run two spark jobs on this node, you can dedicate one volume per Spark job) Cons Additional configurations are required for Spark jobs to use instance store volumes. This approach can be error prone if you don\u2019t control the instance types being used (for example, multiple node groups with different instance types). You can mitigate this issue by using k8s node selectors and specify instance type in your spark configuraiton: spark.kubernetes.node.selector.node.kubernetes.io/instance-type Data created on the volumes is automatically deleted once the job is completed and instance is terminated. However, you need to extra measures to delete the data on instance store volumes if EC2 instance is re-used or is not terminated.","title":"Mount NVMe disks as data volumes"},{"location":"submit-applications/docs/spark/","text":"","title":"Index"},{"location":"submit-applications/docs/spark/java-and-scala/","text":"","title":"Java and scala"},{"location":"submit-applications/docs/spark/pyspark/","text":"Pyspark Job submission \u00b6 Python interpreter is bundled in the EMR containers spark image that is used to run the spark job.Python code and dependencies can be provided with the below options. Python code self contained in a single .py file \u00b6 To start with, in the most simplest scenario - the example below shows how to submit a pi.py file that is self contained and doesn't need any other dependencies. Python file from S3 \u00b6 Request pi.py used in the below request payload is from spark examples cat > spark-python-in-s3.json << EOF { \"name\": \"spark-python-in-image\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3.json Python file from mounted volume \u00b6 In the below example - pi.py is placed in a mounted volume. FSx for Lustre filesystem is mounted as a Persistent Volume on the driver pod under /var/data/ and will be referenced by local:// file prefix. For more information on how to mount FSx for lustre - EMR-Containers-integration-with-FSx-for-Lustre This approach can be used to provide spark application code and dependencies for execution. Persistent Volume mounted to the driver and executor pods lets you access the application code and dependencies with local:// prefix. cat > spark - python - in - FSx . json << EOF { \"name\" : \"spark-python-in-FSx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"local:///var/data/FSxLustre-pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - Fsx . json Python code with python dependencies \u00b6 Info boto3 will only work with ' Bundled as a .pex file ' or with ' Custom docker image ' List of .py files \u00b6 This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. cat > py - files - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext import dependentFunc if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF cat > dependentFunc.py <<EOF def message(): print(\"Printing from inside the dependent python file\") EOF Upload dependentFunc.py and py-files-pi.py to s3 Request: cat > spark-python-in-s3-dependency-files << EOF { \"name\": \"spark-python-in-s3-dependency-files\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/dependentFunc.py --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-files.json Bundled as a zip file \u00b6 In this approach all the dependent python files are bundled as a zip file. Each folder should have __init__.py file as documented in zip python dependencies . Zip should be done at the top folder level and using the -r option. zip -r pyspark-packaged-dependency-src.zip . adding: dependent/ (stored 0%) adding: dependent/__init__.py (stored 0%) adding: dependent/dependentFunc.py (deflated 7%) dependentFunc.py from earlier example has been bundled as pyspark-packaged-dependency-src.zip . Upload this file to a S3 location cat > py - files - zip - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext ** from dependent import dependentFunc ** if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF Request: cat > spark-python-in-s3-dependency-zip.json <<EOF { \"name\": \"spark-python-in-s3-dependency-zip\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark-packaged-dependency-src.zip --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-zip.json Bundled as a .egg file \u00b6 Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .egg file cd / pyspark - packaged - example pip install setuptools python setup . py bdist_egg Upload dist/pyspark_packaged_example-0.0.3-py3.8.egg to a S3 location Request: cat > spark-python-in-s3-dependency-egg.json <<EOF { \"name\": \"spark-python-in-s3-dependency-egg\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3.8.egg --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-egg.json Bundled as a .whl file \u00b6 Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .whl file cd /pyspark-packaged-example `pip install wheel` python setup.py bdist_wheel Upload dist/pyspark_packaged_example-0.0.3-py3-none-any.whl to a s3 location Request: cat > spark-python-in-s3-dependency-wheel.json <<EOF { \"name\": \"spark-python-in-s3-dependency-wheel\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3-none-any.whl --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-wheel.json Bundled as a .pex file \u00b6 pex is a library for generating .pex (Python EXecutable) files which are executable Python environments.PEX files can be created as below docker run -it -v $(pwd):/workdir python:3.7.9-buster /bin/bash #python 3.7.9 is installed in EMR 6.1.0 pip3 install pex pex --python=python3 --inherit-path=prefer -v numpy -o numpy_dep.pex To read more about PEX: PEX PEX documentation Tips on PEX pex packaging for pyspark Approach 1: Using Persistent Volume - FSx for Lustre cluster Upload numpy_dep.pex to a s3 location that is mapped to a FSx for Lustre cluster. numpy_dep.pex can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod. Request: kmeans.py used in the below request is from spark examples cat > spark - python - in - s3 - pex - fsx . json << EOF { \"name\" : \"spark-python-in-s3-pex-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.kubernetes.driverEnv.PEX_ROOT\" : \"./tmp\" , \"spark.executorEnv.PEX_ROOT\" : \"./tmp\" , \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.executorEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.kubernetes.driverEnv.PEX_VERBOSE\" : \"10\" , \"spark.kubernetes.driverEnv.PEX_PYTHON\" : \"python3\" , \"spark.executorEnv.PEX_PYTHON\" : \"python3\" , \"spark.pyspark.driver.python\" : \"/var/data/numpy_dep.pex\" , \"spark.pyspark.python\" : \"/var/data/numpy_dep.pex\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } aws emr - containers start - job - run -- cli - input - json file : //// Spark - Python - in - s3 - pex - fsx . json Approach 2: Using Custom Pod Templates Upload numpy_dep.pex to a s3 location. Create custom pod templates for driver and executor pods. Custom pod templates allows running a command through initContainers before the main application container is created. In this case, the command will download the numpy_dep.pex file to the /tmp/numpy_dep.pex path of the driver and executor pods. Note: This approach is only supported for release image 5.33.0 and later or 6.3.0 and later. Sample driver pod template YAML file: cat > driver_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-driver initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Sample executor pod template YAML file: cat > executor_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-executor initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Replace initContainer's image with the respective release label's container image. In this case we are using the image of release emr-5.33.0-latest . Upload the driver and executor custom pod templates to S3 Request: kmeans.py used in the below request is from spark examples cat > spark-python-in-s3-pex-pod-templates.json << EOF { \"name\": \"spark-python-in-s3-pex-pod-templates\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-5.33.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/kmeans.py\", \"entryPointArguments\": [ \"s3://<s3 prefix>/kmeans_data.txt\", \"2\", \"3\" ], \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.pyspark.pythonVersion\":\"3\", \"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\", \"spark.executorEnv.PEX_ROOT\":\"./tmp\", \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\", \"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\", \"spark.executorEnv.PEX_PYTHON\":\"python3\", \"spark.pyspark.driver.python\":\"/tmp/numpy_dep.pex\", \"spark.pyspark.python\":\"/tmp/numpy_dep.pex\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<s3-prefix>/driver_pod_template.yaml\", \"spark.kubernetes.executor.podTemplateFile\": \"s3://<s3-prefix>/executor_pod_template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } aws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-pod-templates.json Point to Note: PEX files don\u2019t have the python interpreter bundled with it. Using the PEX env variables, we pass in the python interpreter installed in the spark driver and executor docker image. pex vs conda-pack A pex file contain only dependent Python packages but not a Python interpreter in it while a conda-pack environment has a Python interpreter as well, so with the same Python packages a conda-pack environment is much larger than a pex file. A conda-pack environment is a tar.gz file and need to be decompressed before being used while a pex file can be used directly. If a Python interpreter exists, pex is a better option than conda-pack. However, conda-pack is the ONLY CHOICE if you need a specific version of Python interpreter which does not exist and you do not have permission to install one (e.g., when you need to use a specific version of Python interpreter with an enterprise PySpark cluster). If the pex file or conda-pack environment needs to be distributed to machines on demand, there are some overhead before running your application. With the same Python packages, a conda-pack environment has large overhead/latency than the pex file as the conda-pack environment is usually much larger and need to be decompressed before being used. For more information - Tips on PEX Bundled as a tar.gz file with conda-pack \u00b6 conda-pack for spark Install conda through Miniconda Open a new terminal and execute the below commands conda create -y -n example python=3.5 numpy conda activate example pip install conda-pack conda pack -f -o numpy_environment.tar.gz Upload numpy_environment.tar.gz to a s3 location that is mapped to a FSx for Lustre cluster. numpy_environment.tar.gz can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod.Alternatively, S3 path for numpy_environment.tar.gz can also be passed using --py-files Request: { \"name\" : \"spark-python-in-s3-conda-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--verbose --archives /var/data/numpy_environment.tar.gz#environment --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.executor.instances\" : \"3\" , \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.files\" : \"/var/data/numpy_environment.tar.gz#environment\" , \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.pyspark.driver.python\" : \"./environment/bin/python\" , \"spark.pyspark.python\" : \"./environment/bin/python\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } The above request doesn't work with spark on kubernetes Bundled as virtual env \u00b6 Warning This will not work with spark on kubernetes This feature only works with YARN - cluster mode In this implementation for YARN - the dependencies will be installed from the repository for every driver and executor. This might not be a more scalable model as per SPARK-25433 . Recommended solution is to pass in the dependencies as PEX file. Custom docker image \u00b6 See the details in the official documentation . Dockerfile FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0 USER root RUN pip3 install boto3 USER hadoop:hadoop Python code with java dependencies \u00b6 List of packages \u00b6 Warning This will not work with spark on kubernetes This feature only works with YARN - cluster mode kafka integration example ./bin/spark-submit --packages org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2 List of .jar files \u00b6 This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. How to find all of the .jar files which belongs to given package? Go to Maven Repository Search for the package name Select the matching Spark and Scala version Copy the URL of the jar file Copy the URL of the jar file of all compile dependencies Request: cat > Spark-Python-with-jars.json << EOF { \"name\": \"spark-python-with-jars\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar,https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar --conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\" } }, \"configurationOverrides\": { \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-with-jars.json Custom docker image \u00b6 See the basics in the official documentation . Approach 1: List of .jar files This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. How to find all of the .jar files which belongs to given package? Go to Maven Repository Search for the package name Select the matching Spark and Scala version Copy the URL of the jar file Copy the URL of the jar file of all compile dependencies Dockerfile FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0 USER root ARG JAR_HOME = /usr/lib/spark/jars/ # Kafka ADD https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar $JAR_HOME RUN chmod -R +r /usr/lib/spark/jars USER hadoop:hadoop Observed Behavior: Spark automatically installs all the .jar files from /usr/lib/spark/jars/ directory. In Dockerfile we are adding these file as root user and these file will get -rw------- permission while the original files have -rw-r--r-- permission. EMR on EKS uses hadoop:hadoop to run spark jobs and files with -rw------- permission are hidden from this user and can not be imported. To make these file readable for all the users run the following command chmod -R +r /usr/lib/spark/jars and the files will have -rw-r--r-- permission. Approach 2: List of packages This approach is a resource intensive (min 1vCPU, 2GB RAM) solution, because it will run a dummy spark job. Scale your local or CI/CD resources according to it. Dockerfile FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0 USER root ARG KAFKA_PKG = \"org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2\" RUN spark-submit run-example --packages $KAFKA_PKG --deploy-mode = client --master = local [ 1 ] SparkPi RUN mv /root/.ivy2/jars/* /usr/lib/spark/jars/ USER hadoop:hadoop Observed Behavior: Spark runs ivy to get all of its dependencies (packages) when --packages are defined in the submit command. We can run a \"dummy\" spark job to make spark downloads its packages. These .jars are saved in /root/.ivy2/jars/ which we can move to /usr/lib/spark/jars/ for further use. These jars having -rw-r--r-- permission and does not require further modifications. The advantage of this method is ivy download the dependencies of the package as well, and we needed to specify only org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2 instead of 5 jars files above. Import of Dynamic Modules (.pyd, .so) \u00b6 Import of dynamic modules(.pyd, .so) is disallowed when bundled as a zip Steps to create a .so file example.c /* File : example.c */ #include \"example.h\" unsigned int add ( unsigned int a , unsigned int b ) { printf ( \" \\n Inside add function in C library \\n \" ); return ( a + b ); } example.h /* File : example.h */ # include < stdio . h > extern unsigned int add ( unsigned int a , unsigned int b ) ; gcc -fPIC -Wall -g -c example.c gcc -shared -fPIC -o libexample.so example.o Upload libexample.so to a S3 location. pyspark code to be executed - py_c_call.py import sys import os from ctypes import CDLL from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"py-c-so-example\" ) \\ . getOrCreate () basedir = os . path . abspath ( os . path . dirname ( __file__ )) libpath = os . path . join ( basedir , 'libexample.so' ) sum_list = CDLL ( libpath ) data = [( 1 , 2 ),( 2 , 3 ),( 5 , 6 )] columns = [ \"a\" , \"b\" ] df = spark . sparkContext . parallelize ( data ) . toDF ( columns ) df . withColumn ( 'total' , sum_list . add ( df . a , df . b )) . collect () spark . stop () Request: cat > spark-python-in-s3-Clib.json <<EOF { \"name\": \"spark-python-in-s3-Clib\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py_c_call.py\", \"sparkSubmitParameters\": \"--files s3://<s3 prefix>/libexample.so --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-Clib.json Configuration of interest: --files s3://<s3 prefix>/libexample.so distributes the libexample.so to the working directory of all executors. Dynamic modules(.pyd, .so) can also be imported by bundling within .egg ( SPARK-6764 ), .whl and .pex files.","title":"Pyspark"},{"location":"submit-applications/docs/spark/pyspark/#pyspark-job-submission","text":"Python interpreter is bundled in the EMR containers spark image that is used to run the spark job.Python code and dependencies can be provided with the below options.","title":"Pyspark Job submission"},{"location":"submit-applications/docs/spark/pyspark/#python-code-self-contained-in-a-single-py-file","text":"To start with, in the most simplest scenario - the example below shows how to submit a pi.py file that is self contained and doesn't need any other dependencies.","title":"Python code self contained in a single .py file"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-s3","text":"Request pi.py used in the below request payload is from spark examples cat > spark-python-in-s3.json << EOF { \"name\": \"spark-python-in-image\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3.json","title":"Python file from S3"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-mounted-volume","text":"In the below example - pi.py is placed in a mounted volume. FSx for Lustre filesystem is mounted as a Persistent Volume on the driver pod under /var/data/ and will be referenced by local:// file prefix. For more information on how to mount FSx for lustre - EMR-Containers-integration-with-FSx-for-Lustre This approach can be used to provide spark application code and dependencies for execution. Persistent Volume mounted to the driver and executor pods lets you access the application code and dependencies with local:// prefix. cat > spark - python - in - FSx . json << EOF { \"name\" : \"spark-python-in-FSx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"local:///var/data/FSxLustre-pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - Fsx . json","title":"Python file from mounted volume"},{"location":"submit-applications/docs/spark/pyspark/#python-code-with-python-dependencies","text":"Info boto3 will only work with ' Bundled as a .pex file ' or with ' Custom docker image '","title":"Python code with python dependencies"},{"location":"submit-applications/docs/spark/pyspark/#list-of-py-files","text":"This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. cat > py - files - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext import dependentFunc if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF cat > dependentFunc.py <<EOF def message(): print(\"Printing from inside the dependent python file\") EOF Upload dependentFunc.py and py-files-pi.py to s3 Request: cat > spark-python-in-s3-dependency-files << EOF { \"name\": \"spark-python-in-s3-dependency-files\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/dependentFunc.py --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-files.json","title":"List of .py files"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-zip-file","text":"In this approach all the dependent python files are bundled as a zip file. Each folder should have __init__.py file as documented in zip python dependencies . Zip should be done at the top folder level and using the -r option. zip -r pyspark-packaged-dependency-src.zip . adding: dependent/ (stored 0%) adding: dependent/__init__.py (stored 0%) adding: dependent/dependentFunc.py (deflated 7%) dependentFunc.py from earlier example has been bundled as pyspark-packaged-dependency-src.zip . Upload this file to a S3 location cat > py - files - zip - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext ** from dependent import dependentFunc ** if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF Request: cat > spark-python-in-s3-dependency-zip.json <<EOF { \"name\": \"spark-python-in-s3-dependency-zip\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark-packaged-dependency-src.zip --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-zip.json","title":"Bundled as a zip file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-egg-file","text":"Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .egg file cd / pyspark - packaged - example pip install setuptools python setup . py bdist_egg Upload dist/pyspark_packaged_example-0.0.3-py3.8.egg to a S3 location Request: cat > spark-python-in-s3-dependency-egg.json <<EOF { \"name\": \"spark-python-in-s3-dependency-egg\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3.8.egg --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-egg.json","title":"Bundled as a .egg file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-whl-file","text":"Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .whl file cd /pyspark-packaged-example `pip install wheel` python setup.py bdist_wheel Upload dist/pyspark_packaged_example-0.0.3-py3-none-any.whl to a s3 location Request: cat > spark-python-in-s3-dependency-wheel.json <<EOF { \"name\": \"spark-python-in-s3-dependency-wheel\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3-none-any.whl --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-wheel.json","title":"Bundled as a .whl file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-pex-file","text":"pex is a library for generating .pex (Python EXecutable) files which are executable Python environments.PEX files can be created as below docker run -it -v $(pwd):/workdir python:3.7.9-buster /bin/bash #python 3.7.9 is installed in EMR 6.1.0 pip3 install pex pex --python=python3 --inherit-path=prefer -v numpy -o numpy_dep.pex To read more about PEX: PEX PEX documentation Tips on PEX pex packaging for pyspark Approach 1: Using Persistent Volume - FSx for Lustre cluster Upload numpy_dep.pex to a s3 location that is mapped to a FSx for Lustre cluster. numpy_dep.pex can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod. Request: kmeans.py used in the below request is from spark examples cat > spark - python - in - s3 - pex - fsx . json << EOF { \"name\" : \"spark-python-in-s3-pex-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.kubernetes.driverEnv.PEX_ROOT\" : \"./tmp\" , \"spark.executorEnv.PEX_ROOT\" : \"./tmp\" , \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.executorEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.kubernetes.driverEnv.PEX_VERBOSE\" : \"10\" , \"spark.kubernetes.driverEnv.PEX_PYTHON\" : \"python3\" , \"spark.executorEnv.PEX_PYTHON\" : \"python3\" , \"spark.pyspark.driver.python\" : \"/var/data/numpy_dep.pex\" , \"spark.pyspark.python\" : \"/var/data/numpy_dep.pex\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } aws emr - containers start - job - run -- cli - input - json file : //// Spark - Python - in - s3 - pex - fsx . json Approach 2: Using Custom Pod Templates Upload numpy_dep.pex to a s3 location. Create custom pod templates for driver and executor pods. Custom pod templates allows running a command through initContainers before the main application container is created. In this case, the command will download the numpy_dep.pex file to the /tmp/numpy_dep.pex path of the driver and executor pods. Note: This approach is only supported for release image 5.33.0 and later or 6.3.0 and later. Sample driver pod template YAML file: cat > driver_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-driver initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Sample executor pod template YAML file: cat > executor_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-executor initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Replace initContainer's image with the respective release label's container image. In this case we are using the image of release emr-5.33.0-latest . Upload the driver and executor custom pod templates to S3 Request: kmeans.py used in the below request is from spark examples cat > spark-python-in-s3-pex-pod-templates.json << EOF { \"name\": \"spark-python-in-s3-pex-pod-templates\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-5.33.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/kmeans.py\", \"entryPointArguments\": [ \"s3://<s3 prefix>/kmeans_data.txt\", \"2\", \"3\" ], \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.pyspark.pythonVersion\":\"3\", \"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\", \"spark.executorEnv.PEX_ROOT\":\"./tmp\", \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\", \"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\", \"spark.executorEnv.PEX_PYTHON\":\"python3\", \"spark.pyspark.driver.python\":\"/tmp/numpy_dep.pex\", \"spark.pyspark.python\":\"/tmp/numpy_dep.pex\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<s3-prefix>/driver_pod_template.yaml\", \"spark.kubernetes.executor.podTemplateFile\": \"s3://<s3-prefix>/executor_pod_template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } aws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-pod-templates.json Point to Note: PEX files don\u2019t have the python interpreter bundled with it. Using the PEX env variables, we pass in the python interpreter installed in the spark driver and executor docker image. pex vs conda-pack A pex file contain only dependent Python packages but not a Python interpreter in it while a conda-pack environment has a Python interpreter as well, so with the same Python packages a conda-pack environment is much larger than a pex file. A conda-pack environment is a tar.gz file and need to be decompressed before being used while a pex file can be used directly. If a Python interpreter exists, pex is a better option than conda-pack. However, conda-pack is the ONLY CHOICE if you need a specific version of Python interpreter which does not exist and you do not have permission to install one (e.g., when you need to use a specific version of Python interpreter with an enterprise PySpark cluster). If the pex file or conda-pack environment needs to be distributed to machines on demand, there are some overhead before running your application. With the same Python packages, a conda-pack environment has large overhead/latency than the pex file as the conda-pack environment is usually much larger and need to be decompressed before being used. For more information - Tips on PEX","title":"Bundled as a .pex file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-targz-file-with-conda-pack","text":"conda-pack for spark Install conda through Miniconda Open a new terminal and execute the below commands conda create -y -n example python=3.5 numpy conda activate example pip install conda-pack conda pack -f -o numpy_environment.tar.gz Upload numpy_environment.tar.gz to a s3 location that is mapped to a FSx for Lustre cluster. numpy_environment.tar.gz can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod.Alternatively, S3 path for numpy_environment.tar.gz can also be passed using --py-files Request: { \"name\" : \"spark-python-in-s3-conda-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--verbose --archives /var/data/numpy_environment.tar.gz#environment --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.executor.instances\" : \"3\" , \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.files\" : \"/var/data/numpy_environment.tar.gz#environment\" , \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.pyspark.driver.python\" : \"./environment/bin/python\" , \"spark.pyspark.python\" : \"./environment/bin/python\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } The above request doesn't work with spark on kubernetes","title":"Bundled as a tar.gz file with conda-pack"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-virtual-env","text":"Warning This will not work with spark on kubernetes This feature only works with YARN - cluster mode In this implementation for YARN - the dependencies will be installed from the repository for every driver and executor. This might not be a more scalable model as per SPARK-25433 . Recommended solution is to pass in the dependencies as PEX file.","title":"Bundled as virtual env"},{"location":"submit-applications/docs/spark/pyspark/#custom-docker-image","text":"See the details in the official documentation . Dockerfile FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0 USER root RUN pip3 install boto3 USER hadoop:hadoop","title":"Custom docker image"},{"location":"submit-applications/docs/spark/pyspark/#python-code-with-java-dependencies","text":"","title":"Python code with java dependencies"},{"location":"submit-applications/docs/spark/pyspark/#list-of-packages","text":"Warning This will not work with spark on kubernetes This feature only works with YARN - cluster mode kafka integration example ./bin/spark-submit --packages org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2","title":"List of packages"},{"location":"submit-applications/docs/spark/pyspark/#list-of-jar-files","text":"This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. How to find all of the .jar files which belongs to given package? Go to Maven Repository Search for the package name Select the matching Spark and Scala version Copy the URL of the jar file Copy the URL of the jar file of all compile dependencies Request: cat > Spark-Python-with-jars.json << EOF { \"name\": \"spark-python-with-jars\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar,https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar --conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\" } }, \"configurationOverrides\": { \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-with-jars.json","title":"List of .jar files"},{"location":"submit-applications/docs/spark/pyspark/#custom-docker-image_1","text":"See the basics in the official documentation . Approach 1: List of .jar files This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. How to find all of the .jar files which belongs to given package? Go to Maven Repository Search for the package name Select the matching Spark and Scala version Copy the URL of the jar file Copy the URL of the jar file of all compile dependencies Dockerfile FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0 USER root ARG JAR_HOME = /usr/lib/spark/jars/ # Kafka ADD https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar $JAR_HOME ADD https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar $JAR_HOME RUN chmod -R +r /usr/lib/spark/jars USER hadoop:hadoop Observed Behavior: Spark automatically installs all the .jar files from /usr/lib/spark/jars/ directory. In Dockerfile we are adding these file as root user and these file will get -rw------- permission while the original files have -rw-r--r-- permission. EMR on EKS uses hadoop:hadoop to run spark jobs and files with -rw------- permission are hidden from this user and can not be imported. To make these file readable for all the users run the following command chmod -R +r /usr/lib/spark/jars and the files will have -rw-r--r-- permission. Approach 2: List of packages This approach is a resource intensive (min 1vCPU, 2GB RAM) solution, because it will run a dummy spark job. Scale your local or CI/CD resources according to it. Dockerfile FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0 USER root ARG KAFKA_PKG = \"org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2\" RUN spark-submit run-example --packages $KAFKA_PKG --deploy-mode = client --master = local [ 1 ] SparkPi RUN mv /root/.ivy2/jars/* /usr/lib/spark/jars/ USER hadoop:hadoop Observed Behavior: Spark runs ivy to get all of its dependencies (packages) when --packages are defined in the submit command. We can run a \"dummy\" spark job to make spark downloads its packages. These .jars are saved in /root/.ivy2/jars/ which we can move to /usr/lib/spark/jars/ for further use. These jars having -rw-r--r-- permission and does not require further modifications. The advantage of this method is ivy download the dependencies of the package as well, and we needed to specify only org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2 instead of 5 jars files above.","title":"Custom docker image"},{"location":"submit-applications/docs/spark/pyspark/#import-of-dynamic-modules-pyd-so","text":"Import of dynamic modules(.pyd, .so) is disallowed when bundled as a zip Steps to create a .so file example.c /* File : example.c */ #include \"example.h\" unsigned int add ( unsigned int a , unsigned int b ) { printf ( \" \\n Inside add function in C library \\n \" ); return ( a + b ); } example.h /* File : example.h */ # include < stdio . h > extern unsigned int add ( unsigned int a , unsigned int b ) ; gcc -fPIC -Wall -g -c example.c gcc -shared -fPIC -o libexample.so example.o Upload libexample.so to a S3 location. pyspark code to be executed - py_c_call.py import sys import os from ctypes import CDLL from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"py-c-so-example\" ) \\ . getOrCreate () basedir = os . path . abspath ( os . path . dirname ( __file__ )) libpath = os . path . join ( basedir , 'libexample.so' ) sum_list = CDLL ( libpath ) data = [( 1 , 2 ),( 2 , 3 ),( 5 , 6 )] columns = [ \"a\" , \"b\" ] df = spark . sparkContext . parallelize ( data ) . toDF ( columns ) df . withColumn ( 'total' , sum_list . add ( df . a , df . b )) . collect () spark . stop () Request: cat > spark-python-in-s3-Clib.json <<EOF { \"name\": \"spark-python-in-s3-Clib\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py_c_call.py\", \"sparkSubmitParameters\": \"--files s3://<s3 prefix>/libexample.so --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-Clib.json Configuration of interest: --files s3://<s3 prefix>/libexample.so distributes the libexample.so to the working directory of all executors. Dynamic modules(.pyd, .so) can also be imported by bundling within .egg ( SPARK-6764 ), .whl and .pex files.","title":"Import of Dynamic Modules (.pyd, .so)"},{"location":"submit-applications/docs/spark/sparkr/","text":"","title":"Sparkr"},{"location":"submit-applications/docs/spark/sparksql/","text":"","title":"Sparksql"},{"location":"troubleshoot/docs/","text":"","title":"Index"},{"location":"troubleshoot/docs/troubleshooting/","text":"Troubleshooting EMR on EKS issues \u00b6 In this section, you will find several scenarios for troubleshooting described with errors and solutions. You can find these errors using one of these methods using EMR on EKS describe API call using CloudWatch Logs. In the job submission example below, you can find logs in /emr-containers/jobs location using logs shipped to s3. In the job submission example below, you can find logs in s3://'$S3BUCKET'/emr-containers-log path. For driver logs, you need traverse few folders to find the logs. For example, s3://S3BUCKET_NAME/emr-containers-log/CLUSTER_ID/jobs/JOB_ID/containers/spark-JOB_ID/spark-JOB_ID-driver/stderr.gz --configuration-overrides '{ \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://' $S3BUCKET '/emr-containers-log\" } } }' Error - \"PersistentVolumeClaims is forbidden\" \u00b6 Occassionally, there is a drift in RBAC permission required for EMR on EKS and Managed endpoint (EMR Studio) installation to work with EKS clusters. This can happen due to upstream changes in Kubernetes RBAC policies. Here is an example of one such change in Kubernetes v1.22 . Previously, EMR needed permissions for ingresses.extensions to create managed endpoint. But for Kubernetes v1.22 or higher versions, EMR needs ingresses.networking.k8s.io permissions as well. In addition, EMR adds newer features that require newer set of RBAC permissions. For example, Spark jobs that require creation, listing or deletion of Persistent Volume Claims (PVC) was not supported before EMR6.8. Jobs that require these permissions will fail with the exception \u201cpersistentvolumeclaims is forbidden\". Looking into driver logs, you may see an error like this: persistentvolumeclaims is forbidden. User \"system:serviceaccount:emr:emr-containers-sa-spark-client-93ztm12rnjz163mt3rgdb3bjqxqfz1cgvqh1e9be6yr81\" cannot create resource \"persistentvolumeclaims\" in API group \"\" in namesapce \"emr\". You may encounter this error because the default Kubernetes role emr-containers is missing the required RBAC permissions. As a result, the emr-containers primary role can\u2019t dynamically create necessary permissions for additional roles such as Spark driver, Spark executor or Spark client when you submit a job. Because EMR on EKS and Managed endpoint can be installed using different tooling (AWS CLI, SDK, eksctl, terraform, cdk), there can be slight delay in adding most current RBAC permissions into the tooling Solution: \u00b6 Add the required permissions to emr-containers . Here are the complete RBAC permissions for EMR on EKS: emr-containers.yaml You can compare whether you have complete RBAC permissions using the steps below, export NAMESPACE = YOUR_VALUE kubectl describe role emr-containers -n ${ NAMESPACE } If the permissions don't match, proceed to apply latest permissions export NAMESPACE = YOUR_VALUE kubectl apply -f https://github.com/aws/aws-emr-containers-best-practices/blob/main/tools/k8s-rbac-policies/emr-containers.yaml -n ${ NAMESPACE } You can delete other two spark driver/client roles bcoz they will be dynamically created when you run next job.","title":"Troubleshooting EMR on EKS Issues"},{"location":"troubleshoot/docs/troubleshooting/#troubleshooting-emr-on-eks-issues","text":"In this section, you will find several scenarios for troubleshooting described with errors and solutions. You can find these errors using one of these methods using EMR on EKS describe API call using CloudWatch Logs. In the job submission example below, you can find logs in /emr-containers/jobs location using logs shipped to s3. In the job submission example below, you can find logs in s3://'$S3BUCKET'/emr-containers-log path. For driver logs, you need traverse few folders to find the logs. For example, s3://S3BUCKET_NAME/emr-containers-log/CLUSTER_ID/jobs/JOB_ID/containers/spark-JOB_ID/spark-JOB_ID-driver/stderr.gz --configuration-overrides '{ \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://' $S3BUCKET '/emr-containers-log\" } } }'","title":"Troubleshooting EMR on EKS issues"},{"location":"troubleshoot/docs/troubleshooting/#error-persistentvolumeclaims-is-forbidden","text":"Occassionally, there is a drift in RBAC permission required for EMR on EKS and Managed endpoint (EMR Studio) installation to work with EKS clusters. This can happen due to upstream changes in Kubernetes RBAC policies. Here is an example of one such change in Kubernetes v1.22 . Previously, EMR needed permissions for ingresses.extensions to create managed endpoint. But for Kubernetes v1.22 or higher versions, EMR needs ingresses.networking.k8s.io permissions as well. In addition, EMR adds newer features that require newer set of RBAC permissions. For example, Spark jobs that require creation, listing or deletion of Persistent Volume Claims (PVC) was not supported before EMR6.8. Jobs that require these permissions will fail with the exception \u201cpersistentvolumeclaims is forbidden\". Looking into driver logs, you may see an error like this: persistentvolumeclaims is forbidden. User \"system:serviceaccount:emr:emr-containers-sa-spark-client-93ztm12rnjz163mt3rgdb3bjqxqfz1cgvqh1e9be6yr81\" cannot create resource \"persistentvolumeclaims\" in API group \"\" in namesapce \"emr\". You may encounter this error because the default Kubernetes role emr-containers is missing the required RBAC permissions. As a result, the emr-containers primary role can\u2019t dynamically create necessary permissions for additional roles such as Spark driver, Spark executor or Spark client when you submit a job. Because EMR on EKS and Managed endpoint can be installed using different tooling (AWS CLI, SDK, eksctl, terraform, cdk), there can be slight delay in adding most current RBAC permissions into the tooling","title":"Error - \"PersistentVolumeClaims is forbidden\""},{"location":"troubleshoot/docs/troubleshooting/#solution","text":"Add the required permissions to emr-containers . Here are the complete RBAC permissions for EMR on EKS: emr-containers.yaml You can compare whether you have complete RBAC permissions using the steps below, export NAMESPACE = YOUR_VALUE kubectl describe role emr-containers -n ${ NAMESPACE } If the permissions don't match, proceed to apply latest permissions export NAMESPACE = YOUR_VALUE kubectl apply -f https://github.com/aws/aws-emr-containers-best-practices/blob/main/tools/k8s-rbac-policies/emr-containers.yaml -n ${ NAMESPACE } You can delete other two spark driver/client roles bcoz they will be dynamically created when you run next job.","title":"Solution:"}]}