{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the EMR Containers Best Practices Guide. The primary goal of this project is to offer a set of best practices and templates to get started with Amazon EMR on EKS. We publish this guide on GitHub so we could iterate the content quickly, provide timely and effective recommendations for variety of concerns, and easily incorporate suggestions from the broader community.</p>"},{"location":"#amazon-emr-on-eks-workshop","title":"Amazon EMR on EKS Workshop","text":"<p>If you are interested in step-by-step tutorials that leverage the best practices contained in this guide, please visit the Amazon EMR on EKS Workshop.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We encourage you to contribute to these guides. If you have implemented a practice that has proven to be effective, please share it with us by opening an issue or a pull request. Similarly, if you discover an error or flaw in the guide, please submit a pull request to correct it.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/","title":"EKS Best Practices and Recommendations","text":"<p>Amazon EMR on EKS team has run scale tests on EKS cluster and has compiled a list of recommendations. The purpose of this document is to share our recommendations for running large scale EKS clusters supporting EMR on EKS.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#amazon-vpc-cni-best-practices","title":"Amazon VPC CNI Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-1-improve-ip-address-utilization","title":"Recommendation 1: Improve IP Address Utilization","text":"<p>EKS clusters can run out of IP addresses for pods when they reached between 400 and 500 nodes. With the default CNI settings, each node can request more IP addresses than is required. To ensure that you don\u2019t run out of IP addresses, there are two solutions:</p> <ol> <li> <p>Set MINIMUM_IP_TARGET and WARM_IP_TARGET instead of the default setting of WARM_ENI_TARGET=1. The values of these settings will depend on your instance type, expected pod density, and workload. More info about these CNI settings can be found here. The maximum number of IP addresses per node (and thus maximum number of pods per node) depends on instance type and can be looked up here.</p> </li> <li> <p>If you have found the right CNI settings as described above, the subnets created by eksctl still do not provide enough addresses (by default eksctl creates a \u201c/19\u201d subnet for each nodegroup, which contains ~8.1k addresses). You can configure CNI to take addresses from (larger) subnets that you create. For example, you could create a few \u201c/16\u201d subnets, which contain ~65k IP addresses per subnet. You should implement this option after you have configured the CNI settings as described in #1. To configure your pods to use IP addresses from larger manually-created subnets, use CNI custom networking (see below for more information):</p> </li> </ol> <p>CNI custom networking</p> <p>By default, the CNI assigns the Pod\u2019s IP address from the worker node's primary elastic network interface's (ENI) security groups and subnet. If you don\u2019t have enough IP addresses in the worker node subnet, or prefer that the worker nodes and Pods reside in separate subnets to avoid IP address allocation conflicts between Pods and other resources in the VPC, you can use CNI custom networking.</p> <p>Enabling a custom network removes an available elastic network interface (and all of its available IP addresses for pods) from each worker node that uses it. The worker node's primary network interface is not used for pod placement when a custom network is enabled.</p> <p>If you want the CNI to assign IP addresses for Pods from a different subnet, you can set <code>AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG</code> environment variable to <code>true</code>.</p> <pre><code>kubectl set env daemonset aws-node \\\n-n kube-system AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true\n</code></pre> <p>When <code>AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true</code>, the CNI will assign Pod IP address from a subnet defined in <code>ENIConfig</code>. The <code>ENIConfig</code> custom resource is used to define the subnet in which Pods will be scheduled. </p> <pre><code>apiVersion: crd.k8s.amazonaws.com/v1alpha1\nkind: ENIConfig\nmetadata: \n  name: us-west-2a\nspec: \n  securityGroups: \n    - sg-0dff111a1d11c1c11\n  subnet: subnet-011b111c1f11fdf11\n</code></pre> <p>You will need to create an <code>ENIconfig</code> custom resource for each subnet you want to use for Pod networking. </p> <ul> <li> <p>The <code>securityGroups</code> field should have the ID of the security group attached to the worker nodes. </p> </li> <li> <p>The <code>name</code> field should be the name of the Availability Zone in your VPC. If you name your ENIConfig custom resources after each Availability Zone in your VPC, you can enable Kubernetes to automatically apply the corresponding ENIConfig for the worker node Availability Zone with the following command.</p> </li> </ul> <pre><code>kubectl set env daemonset aws-node \\\n-n kube-system ENI_CONFIG_LABEL_DEF=failure-domain.beta.kubernetes.io/zone\n</code></pre> <p>Note</p> <p>Upon creating the <code>ENIconfig</code> custom resources, you will need to create new worker nodes. The existing worker nodes and Pods will remain unaffected.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-2-prevent-ec2-vpc-api-throttling-from-assignprivateipaddresses-attachnetworkinterface","title":"Recommendation 2: Prevent EC2 VPC API throttling from AssignPrivateIpAddresses &amp; AttachNetworkInterface","text":"<p>Often EKS cluster scale-out time can increase because the CNI is being throttled by the EC2 VPC APIs. The following steps can be taken to prevent these issues:</p> <ol> <li> <p>Use CNI version 1.8.0 or later as it reduces the calls to EC2 VPC APIs than earlier versions.</p> </li> <li> <p>Configure the MINIMUM_IP_TARGET and WARM_IP_TARGET parameters instead of the default parameter of WARM_ENI_TARGET=1. Only those IP addresses that are necessary are requested from EC2. The values of these settings will depend on your instance type and expected pod density. More info about these settings here.</p> </li> <li> <p>Request an API limit increase on the EC2 VPC APIs that are getting throttled. This option should be considered only after steps 1 &amp; 2 have been done.</p> </li> </ol>"},{"location":"best-practices-and-recommendations/eks-best-practices/#other-recommendations-for-amazon-vpc-cni","title":"Other Recommendations for Amazon VPC CNI","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#plan-for-growth","title":"Plan for growth","text":"<p>Size the subnets you will use for Pod networking for growth. If you have insufficient IP addresses available in the subnet that the CNI uses, your pods will not get an IP address. The pods will remain in the pending state until an IP address becomes available. This may impact application autoscaling and compromise its availability.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-ip-address-inventory","title":"Monitor IP address inventory","text":"<p>You can monitor the IP addresses inventory of subnets using the CNI Metrics Helper, and set CloudWatch alarms to get notified if a subnet is running out of IP addresses.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#snat-setting","title":"SNAT setting","text":"<p>Source Network Address Translation (source-nat or SNAT) allows traffic from a private network to go out to the internet. Virtual machines launched on a private network can get to the internet by going through a gateway capable of performing SNAT. If your Pods with private IP address need to communicate with other private IP address spaces (for example, Direct Connect, VPC Peering or Transit VPC), then you should enable external SNAT in the CNI:</p> <pre><code>kubectl set env daemonset \\\n-n kube-system aws-node AWS_VPC_K8S_CNI_EXTERNALSNAT=true\n</code></pre>"},{"location":"best-practices-and-recommendations/eks-best-practices/#coredns-best-practices","title":"CoreDNS Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#prevent-coredns-from-being-overwhelmed-unknownhostexception-in-spark-jobs-and-other-pods","title":"Prevent CoreDNS from being overwhelmed (UnknownHostException in spark jobs and other pods)","text":"<p>CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can be a problem for workloads that do a lot of DNS lookups. One simple solution is to install dns-autoscaler, which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-coredns-metrics","title":"Monitor CoreDNS metrics","text":"<p>CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can cause workloads to timeout with unknownHostException as spark-executors will do a lot of DNS lookups which registering themselves to spark-driver. One simple solution to fix this is to install dns-autoscaler, which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#cluster-autoscaler-best-practices","title":"Cluster Autoscaler Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#increase-cluster-autoscaler-memory-to-avoid-unnecessary-exceptions","title":"Increase cluster-autoscaler memory to avoid unnecessary exceptions","text":"<p>Cluster-autoscaler can require a lot of memory to run because it stores a lot of information about the state of the cluster, such as data about every pod and every node. If the cluster-autoscaler has insufficient memory, it can lead to the cluster-autoscaler crashing.  Ensure that you provide the cluster-autoscaler deployment more memory, e.g., 1Gi memory instead of the default 300Mi. Useful information about configuring the cluster-autoscaler for improved scalability and performance can be found here</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#avoid-job-failures-when-cluster-autoscaler-attempts-scale-in","title":"Avoid job failures when Cluster Autoscaler attempts scale-in","text":"<p>Cluster Autoscaler will attempt scale-in action for any under utilized instance within your EKScluster. When scale-in action is performed, all pods from that instance is relocated to another node. This could cause disruption for critical workloads. For example, if driver pod is restarted, the entire job needs to restart. For this reason, we recommend using Kubernetes annotations on all critical pods (especially driver pods) and for cluster autoscaler deployment. Please see here for more info</p> <pre><code>cluster-autoscaler.kubernetes.io/safe-to-evict=false\n</code></pre>"},{"location":"best-practices-and-recommendations/eks-best-practices/#configure-overprovisioning-with-cluster-autoscaler-for-higher-priority-jobs","title":"Configure overprovisioning with Cluster Autoscaler for higher priority jobs","text":"<p>If the required resources is not available in the cluster, pods go into pending state. Cluster Autoscaler uses this metric to scale out the cluster and this activity can be time-consuming (several minutes) for higher priority jobs. In order to minimize time required for scaling, we recommend overprovisioning resources. You can launch pause pods(dummy workloads which sleeps until it receives SIGINT or SIGTERM) with negative priority to reserve EC2 capacity. Once the higher priority jobs are scheduled, these pause pods are preempted to make room for high priority pods which in turn scales out additional capacity as a buffer. You need to be aware that this is a trade-off as it adds slightly higher cost while minimizing scheduling latency. You can read more about over provisioning best practice here.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#eks-control-plane-best-practices","title":"EKS Control Plane Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server-overwhelmed","title":"API server overwhelmed","text":"<p>System pods, workload pods, and external systems can make many calls to the Kubernetes API server. This can decrease performance and also increase EMR on EKS job failures. There are multiple ways to avoid API server availability issues including but not limited to:</p> <ul> <li> <p>By default, the EKS API servers are automatically scaled to meet your workload demand. If you see increased latencies, please contact AWS via a support ticket and work with engineering team to resolve the issue.</p> </li> <li> <p>Consider reducing the scan interval of cluster-autoscaler from the 10 second default value. Each time the cluster-autoscaler runs, it makes many calls to the API server. However, this will result in the cluster scaling-out less frequently and in larger steps (and same with scaling back in when load is reduced). More information can be found about the cluster-autoscaler here. This is not recommended if you need jobs to start ASAP.</p> </li> <li> <p>If you are running your own deployment of fluentd, an increased load on the APIserver can be observed. Consider using fluent-bit instead which makes fewer calls to the API server. More info can be found here</p> </li> </ul>"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-control-plane-metrics","title":"Monitor Control Plane Metrics","text":"<p>Monitoring Kubernetes API metrics can give you insights into control plane performance and identify issues. An unhealthy control plane can compromise the availability of the workloads running inside the cluster. For example, poorly written controllers can overload the API servers, affecting your application's availability.</p> <p>Kubernetes exposes control plane metrics at the  <code>/metrics</code> endpoint. </p> <p>You can view the metrics exposed using <code>kubectl</code>:</p> <pre><code>kubectl get --raw /metrics\n</code></pre> <p>These metrics are represented in a Prometheus text format. </p> <p>You can use Prometheus to collect and store these metrics. In May 2020, CloudWatch added support for monitoring Prometheus metrics in CloudWatch Container Insights. So you can also use Amazon CloudWatch to monitor the EKS control plane. You can follow the Tutorial for Adding a New Prometheus Scrape Target: Prometheus KPI Server Metrics to collect metrics and create CloudWatch dashboard to monitor your cluster\u2019s control plane.</p> <p>You can also find Kubernetes API server metrics here. For example, <code>apiserver_request_duration_seconds</code> can indicate how long API requests are taking to run. </p> <p>Consider monitoring these control plane metrics:</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server","title":"API Server","text":"Metric Description <code>apiserver_request_total</code> Counter of apiserver requests broken out for each verb, dry run value, group, version, resource, scope, component, client, and HTTP response contentType and code. <code>apiserver_request_duration_seconds*</code> Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope, and component. <code>rest_client_request_duration_seconds</code> Request latency in seconds. Broken down by verb and URL. <code>apiserver_admission_controller_admission_duration_seconds</code> Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). <code>rest_client_request_duration_seconds</code> Request latency in seconds. Broken down by verb and URL. <code>rest_client_requests_total</code> Number of HTTP requests, partitioned by status code, method, and host."},{"location":"best-practices-and-recommendations/eks-best-practices/#etcd","title":"etcd","text":"Metric Description <code>etcd_request_duration_seconds</code> Etcd request latency in seconds for each operation and object type. <p>You can visualize and monitor these Kubernetes API server requests, latency and etcD metrics on Grafana via Grafana dashboard 12006.</p>"},{"location":"cost-optimization/docs/cost-optimization/","title":"Cost Optimization using EC2 Spot Instances","text":""},{"location":"cost-optimization/docs/cost-optimization/#ec2-spot-best-practices","title":"EC2 Spot Best Practices","text":"<p>Amazon EMR on Amazon EKS enables you to submit Apache Spark jobs on demand on Amazon Elastic Kubernetes Service (EKS) without provisioning dedicated EMR clusters. With EMR on EKS, you can consolidate analytical workloads with your other Kubernetes-based applications on the same Amazon EKS cluster to improve resource utilization and simplify infrastructure management. Cost Optimization of the underlying infrastructure is often the key requirement for our customers, and this can be achieved by using Amazon EC2 Spot Instances. Spot Instances are spare EC2 capacity and is available at up to 90% discount compared to On-Demand Instance prices. If EC2 needs capacity back for On-Demand Instance usage, Spot Instances can be interrupted. Handling interruptions to build resilient workloads is simple and there are best practices to manage interruption by automation or AWS services like EKS. </p> <p>This document will describe how to architect with EC2 spot best practices and apply to EMR on EKS jobs. We will also cover Spark features related to EC2 Spot when you run EMR on EKS jobs</p>"},{"location":"cost-optimization/docs/cost-optimization/#ec2-spot-capacity-provisioning","title":"EC2 Spot Capacity Provisioning","text":"<p>EMR on EKS runs open-source big data framework like Spark on Amazon EKS, so basically when you are run on Spot instances you are, provisioning capacity for the underlying EKS cluster. The key point to remember when you are using Spot instances is instance diversification. There are three ways that EC2 Spot capacity can be provisioned in an EKS cluster.</p> <p>EKS Managed Nodegroup:</p> <p>We highly recommend to use Managed Nodegroup for provisioning Spot instances. This requires significantly less operational effort when compared to self-managed nodegroups. The Spot instance interruption is handled proactively using the Instance Rebalancing Recommendation and Spot best practice of using Capacity Optimized Allocation strategy is adopted by default along with other useful features. If you are planning to scale your cluster then Cluster Autoscaler can be used but keep in mind, one caveat with this approach is to maintain same vCPU to memory ratio for nodes defined in a nodegroup.</p> <p>Karpenter:</p> <p>An open-source node provisioning tool for Kubernetes which works seamlessly with EMR on EKS. Karpenter can help to improve the efficiency and cost of running workloads. It provisions nodes based on pod resource requirements. The key advantage of Karpenter is flexibility not only in terms of EC2 pricing (Spot/On-Demand) but it also aligns with the Spot best practice of instance diversification, and uses capacity optimized prioritized allocation strategy; more details can be found in this workshop. Karpenter will also be useful to scale the infrastructure which will be further discussed under the scaling section below.</p> <p>Self-Managed Nodegroup:</p> <p>EMR on EKS clusters can also run on self-managed nodegroups on EKS. You need to manage the Spot instance lifecycle if there is an interruption by installing an open-source tool named AWS Node Termination Handler. AWS Node Termination Handler ensures that the Kubernetes control plane responds appropriately to events that can cause your EC2 instance to become unavailable, such as EC2 maintenance events, EC2 Spot interruptions, ASG Scale-In, ASG AZ Rebalance, and EC2 Instance Termination via the API or Console. Please remember you need to manage all the software updates manually if you plan to use this. When you are using dynamic allocation the nodegroups needs to autoscale, and if you are using cluster autoscaler then you need to maintain the vCPU to memory ratio for nodes defined in a nodegroup.</p>"},{"location":"cost-optimization/docs/cost-optimization/#spot-interruption-and-spark","title":"Spot Interruption and Spark","text":"<p>EC2 Spot instances are suitable for flexible and fault tolerant workloads. Spark is a semi-resilient by design because if the executor fails, new executors are spun up by the driver to continue the job. However, if the driver fails, the entire job fails. For added resiliency, EMR of EKS retries up to 5 times for driver pods so that the k8s can find suitable host and job starts successfully. If k8s fails to find a host, job is cancelled after 15 min timeout. If driver pod fails for other reasons, job is cancelled with an error message for troubleshooting. Hence, we recommend to run Spark driver on On-Demand instances and executors on Spot instances to cost optimize the workloads. You can use PodTemplates to configure this scheduling constraint. NodeSelector can be used  as the node selection constraint to run executors on Spot instances as in the example below. This is simple to use and works well with Karpenter too. The pod template for this would look like </p> <pre><code>apiVersion: v1\nkind: Pod\nspec:\n  nodeSelector:\n    eks.amazonaws.com/capacityType: SPOT\n  containers:\n  - name: spark-kubernetes-executor\n</code></pre> <p>Node affinity can also be used here, this allows for more flexibility for the constraints defined. We recommend to use \u2018hard affinity\u2019 as highlighted in the code below for this purpose. For jobs which have strict SLA and are not suitable to run on Spot we suggest to use NoSchedule taint effect to ensure no Pods are scheduled. The key thing to note here is that the bulk of the compute required in a Spark job runs on executors and if they can be run on EC2 Spot instances you can benefit from the steep discount available with Spot instances.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    spark-role: driver\n  namespace: emr-eks-workshop-namespace\nspec:\n  affinity: \n      nodeAffinity: \n          requiredDuringSchedulingIgnoredDuringExecution: \n            nodeSelectorTerms: \n            - matchExpressions: \n              - key: 'eks.amazonaws.com/capacityType' \n                operator: In \n                values: \n                - ON_DEMAND\n</code></pre> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    spark-role: executor\n  namespace: emr-eks-workshop-namespace\nspec:\n  affinity: \n      nodeAffinity: \n          requiredDuringSchedulingIgnoredDuringExecution: \n            nodeSelectorTerms: \n            - matchExpressions: \n              - key: 'eks.amazonaws.com/capacityType' \n                operator: In \n                values: \n                - SPOT\n</code></pre> <p>When Spot instances are interrupted the executors running on them may lose (if any) the shuffle and cached RDDs which would require re-computation. This requires more compute cycles to be spent which will impact the overall SLA of the EMR on EKS jobs. EMR on EKS has incorporated two new Spark features which can help to address these issues. In the following sections we will discuss them.</p> <p>Node Decommissioning:</p> <p>Node decommissioning is a Spark feature that enables the removal of an executor gracefully, by preserving its state before removing it and not scheduling any new jobs on it. This feature is particularly useful when the Spark executors are running on Spot instances, and the Spark executor node is interrupted via a \u2018rebalance recommendation\u2019 or \u2018instance termination\u2019 notice to reclaim the instance. </p> <p>Node decommission begins when a Spark executor node receives a Spot Interruption Notice or Spot Rebalance Recommendation signal. The executor node immediately starts the process of decommissioning by sending a message to the Spark driver. The driver will identify the RDD/Shuffle files that it needs to migrate off the executor node in question, and will try to identify another Executor node which can take over the execution. If an executor is identified, the RDD/Shuffle files are copied to the new executor and the job execution continues on the new executor. If all the executors are busy, the RDD/Shuffle files are copied to an external storage.</p> <p> </p> <p>The key advantage of this process is that it enables block and shuffle data of a Spark executor that receives EC2 Spot Interruption signal to be migrated, reducing the re-computation of the Spark tasks. The reduction in the re-computation for the interrupted Spark tasks improves the resiliency of the system and reduces overall execution time. We recommend to enable node decommissioning feature because it would help to reduce the overall compute cycles when there is a Spot interruption.</p> <p>This feature is available on Amazon EMR version 6.3 and above. To set up this feature, add this configuration to the Spark job under the executor section:</p> <pre><code>\"spark.decommission.enabled\": \"true\"\n\"spark.storage.decommission.rddBlocks.enabled\": \"true\"\n\"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\"\n\"spark.storage.decommission.enabled\": \"true\"\n\"spark.storage.decommission.fallbackStorage.path\": \"s3://&lt;&lt;bucket&gt;&gt;\"\n</code></pre> <p>The Spark executor logs sample shown below shows the process of decommission and sending message to the driver:</p> <pre><code>21/05/05 17:41:41 WARN KubernetesClusterSchedulerBackend$KubernetesDriverEndpoint: Received executor 7 decommissioned message\n21/05/05 17:41:41 DEBUG TaskSetManager: Valid locality levels for TaskSet 2.0: NO_PREF, ANY\n21/05/05 17:41:41 INFO KubernetesClusterSchedulerBackend: Decommission executors: 7\n21/05/05 17:41:41 DEBUG TaskSchedulerImpl: parentName: , name: TaskSet_2.0, runningTasks: 10\n21/05/05 17:41:41 INFO BlockManagerMasterEndpoint: Mark BlockManagers (BlockManagerId(7, 192.168.82.107, 39007, None)) as being decommissioning.\n</code></pre> <pre><code>21/05/05 20:22:17 INFO CoarseGrainedExecutorBackend: Decommission executor 1.\n21/05/05 20:22:17 INFO CoarseGrainedExecutorBackend: Will exit when finished decommissioning\n21/05/05 20:22:17 INFO BlockManager: Starting block manager decommissioning process...\n21/05/05 20:22:17 DEBUG FileSystem: Looking for FS supporting s3a\n</code></pre> <p>The Spark driver logs sample below shows the process of looking for an executor to migrate the shuffle data:</p> <pre><code>22/06/07 20:41:38 INFO ShuffleStatus: Updating map output for 46 to BlockManagerId(4, 192.168.13.235, 34737, None)\n22/06/07 20:41:38 DEBUG BlockManagerMasterEndpoint: Received shuffle data block update for 0 46, ignore.\n22/06/07 20:41:38 DEBUG BlockManagerMasterEndpoint: Received shuffle index block update for 0 46, updating.\n</code></pre> <p>The Spark executor logs sample below shows the process of reusing the shuffle files:</p> <pre><code>22/06/07 20:42:50 INFO BasicExecutorFeatureStep: Adding decommission script to lifecycle\n22/06/07 20:42:50 DEBUG ExecutorPodsAllocator: Requested executor with id 19 from Kubernetes.\n22/06/07 20:42:50 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-bfd0a5813fd1b80f-exec-19, action ADDED\n22/06/07 20:42:50 DEBUG BlockManagerMasterEndpoint: Received shuffle index block update for 0 52, updating.\n22/06/07 20:42:50 INFO ShuffleStatus: Recover 52 BlockManagerId(fallback, remote, 7337, None)\n</code></pre> <p>More details on this can be found here</p> <p>PVC Reuse:</p> <p>A PersistentVolume is a Kubernetes feature to provide persistent storage to container Pods running stateful workloads, and PersistentVolumeClaim (PVC) is to request the above storage in the container Pod for storage by a user. Apache Spark 3.1.0 introduced the ability to dynamically generate, mount, and remove Persistent Volume Claims, SPARK-29873 for Kubernetes workloads, which are basically volumes mounted into your Spark pods. This means Apache Spark does not have to pre-create any claims/volumes for executors and delete it during the executor decommissioning.</p> <p>Since Spark3.2, PVC reuse is introduced. In case of a Spark executor is killed due to EC2 Spot interruption or any other failure, then its PVC is not deleted but persisted throughtout the entire job lifetime. It will be reattached to a new executor for a faster recovery. If there are shuffle files on that volume, then they are reused. Without enabling this feature, the owner of dynamic PVCs is the executor pods. It means if a pod or a node became unavailable, the PVC would be terminated, resulting in all the shuffle data were lost, and the recompute would be triggered.</p> <p> </p> <p>This feature is available started from Amazon EMR version 6.6+. To set it up, you can add these configurations to Spark jobs:</p> <pre><code>\"spark.kubernetes.driver.ownPersistentVolumeClaim\": \"true\"\n\"spark.kubernetes.driver.reusePersistentVolumeClaim\": \"true\n</code></pre> <p>since Spark3.4 (EMR6.12), Spark driver is able to do PVC-oriented executor allocation which means Spark counts the total number of created PVCs which the job can have, and holds on a new executor creation if the driver owns the maximum number of PVCs. This helps the transition of the existing PVC from one executor to another executor. Add this extra config to improve your PVC reuse performance:</p> <pre><code>\"spark.kubernetes.driver.waitToReusePersistentVolumeClaim\": \"true\"\n</code></pre> <p>One key benefit of the PVC reuse is that if any Executor running on EC2 Spot becomes unavailable, the new executor replacement can reuse the shuffle data from the existing PVC, avoiding recompute of the shuffle blocks. Dynamic PVC or persistence volume claim enables \u2018true\u2019 decoupling of storage and compute when we run Spark jobs on Kubernetes, as it can be used as a local storage to spill in-process files too. We recommend to enable PVC reuse feature because the time taken to resume the task when there is a Spot interruption is optimized as the files are used in-situ and there is no time required to move the files around.</p> <p>If one or more of the nodes which are running executors is interrupted the underlying pods gets deleted and the driver gets the update. Note the driver is the owner of those PVCs attaching to executor pods and they are not deleted throughout the job lifetime.</p> <pre><code>22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-3, action DELETED\n22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-6, action MODIFIED\n22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-6, action DELETED\n22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-3, action MODIFIED\n</code></pre> <p>The ExecutorPodsAllocator tries to allocate new executor pods to replace the ones killed due to interruption. During the allocation it tries to figure out how many of the existing PVC has some files and can be reused.</p>"},{"location":"cost-optimization/docs/cost-optimization/#scaling-emr-on-eks-and-ec2-spot","title":"Scaling EMR on EKS and EC2 Spot","text":"<p>One of the key advantages of using Spot instances is it helps to increase the throughput of Big Data workloads at a fraction of the cost of On-Demand instances. There are spark workloads where there is a need to scale the \u2018number of executors\u2019 and the infrastructure dynamically. Scaling in a Spark process is done by spawning pod replicas and when they cannot be scheduled in the existing cluster the cluster need to be scaled up by adding more nodes. When you scale up using Spot instances you get the cost benefits of using the lowest price for EC2 Compute and thus increase the throughput of the job at a lower cost, as you can provision more compute capacity (at the same cost of On-Demand instances) to reduce the time taken to process large data sets.</p> <p>Dynamic Resource Allocation (DRA) enables the Spark driver to spawn the initial number of executors (pod replicas) and then scale up the number until the specified maximum number of executors is met to process the pending tasks. When the executors have no tasks running on them, they are terminated. This enables the nodes deployed in the Amazon EKS cluster to be better utilized while running multiple Spark jobs. DRA has mechanisms to dynamically adjust the resources your application occupies based on the workload. Idle executors are terminated when there are no pending tasks. This feature is available on Amazon EMR version 6.x. More details can be found here.</p> <p>Scaling of the infrastructure by adding more nodes can be achieved by using Cluster Autoscaler or Karpenter.</p> <p>Cluster Autoscaler:</p> <p>Cluster Autoscaler (CAS) is a Kubernetes open-source tool that automatically scale-out the size of the Kubernetes cluster when there are pending pods due to insufficient capacity on existing cluster, or scale-in when there are underutilized nodes in a cluster for extended period of time. The configuration below shows multiple Nodegroups with different vCPU and RAM configurations which adheres to the Spot best practice of diversification. Note each nodegroup has the same vCPU to memory ratio as discussed above. CAS works with EKS Managed and Self-Managed Nodegroups.</p> <p> </p> <p>Karpenter</p> <p>Karpenter is an open-source, flexible, high-performance auto-scaler built for Kubernetes. Karpenter automatically launches just the right compute resources to handle your cluster's applications. Karpenter observes aggregate resource requests of un-schedulable pods, computes and launches best-fit new capacity.</p> <p> </p> <p>The Provisioner CRD\u2019s configuration flexibility is very useful in adopting Spot best practices of diversification. It can include as many Spot Instance types as possible as we do not restrict specific instance types in the configuration. This approach is also future-proof when AWS launches new instance types. It also manages Spot instance lifecycle management through Spot interruptions. We recommend to use Karpenter with Spot Instances as it has faster node scheduling with early pod binding and binpacking to optimize the resource utilization. An example of a Karpenter provisioner with Spot instances below.</p> <pre><code>apiVersion: karpenter.sh/v1alpha5\nkind: Provisioner\nmetadata:\n  name: default\nspec:\n  labels:\n    intent: apps\n  requirements:\n    - key: karpenter.sh/capacity-type\n      operator: In\n      values: [\"spot\"]\n    - key: karpenter.k8s.aws/instance-size\n      operator: NotIn\n      values: [nano, micro, small, medium, large]\n  limits:\n    resources:\n      cpu: 1000\n      memory: 1000Gi\n  ttlSecondsAfterEmpty: 30\n  ttlSecondsUntilExpired: 2592000\n  providerRef:\n    name: default\n</code></pre>"},{"location":"cost-optimization/docs/cost-optimization/#emr-on-eks-and-ec2-spot-instances-best-practices","title":"EMR on EKS and EC2 Spot Instances: Best Practices","text":"<p>In summary, our recommendations are:</p> <ul> <li>Use EC2 Spot instances for Spark executors and On-Demand instances for drivers.<ul> <li>Diversify the instances types (Instance family and size) used in a cluster. </li> </ul> </li> <li>Use a single AZ to launch a cluster to save Inter-AZ data transfer cost and improve job performance.</li> <li>Use Karpenter for capacity provisioning and scaling when running EMR on EKS jobs.</li> <li>If use Cluster Autoscaler not Karpenter, use EKS Managed Nodegroups.</li> <li>If using EKS self-managed nodegroups, enuse the Capacity Optimized Allocation strategy and AWS Node Termination Handler are in place.</li> <li>Utilizing Node decommissioning and PVC Reuse techniques can help reduce the time taken to complete EMR on EKS job when EC2 Spot interruptions occur. However, they do not guarantee 100% avoidance of data loss during shuffling interruptions.</li> <li>Implementing a Remote Shuffle Service (RSS) solution can enhance job stability and availability if Node decommissioning and PVC Reuse features do not fully meet your requirements.</li> <li>Spark's Dynamic Resource Allocation (DRA) feature is particularly useful for reducing job costs, as it releases idle resources if not needed. The cost of EMR on EKS is determined by resource consumption at various stages of a job and is not calculated by the EMR unit price * job run time.</li> <li>DRA implementation on EKS is different from Spark on YARN. Check out the details here. </li> <li>Decouple Compute and Storage. For example use S3 to store Input/Output data or use RSS to store shuffle data. It allows independent scaling of processing and storage. There is low chance of losing data in case of a Spot interruption too. </li> <li>Reduce Spark\u2019s Shuffle Size and Blast Radius. This allows to select more Spot instances for diversification and also reduces the time taken to recompute/move the shuffle files in case of an interruption.</li> <li>Automate Spot Interruption handling via existing tools and services.</li> </ul>"},{"location":"cost-optimization/docs/cost-optimization/#conclusion","title":"Conclusion","text":"<p>In this document, we covered best practices to cost effectively run EMR on EKS workloads using EC2 Spot Instances. We have outlined three key areas: Provisioning, Interruption Handling, and Scaling, along with the corresponding best practices for each. We aim for this document to offer prescriptive guidance on running EMR on EKS workloads with substantial cost savings through the utilization of Spot instances.</p>"},{"location":"cost-optimization/docs/cost-tracking/","title":"Cost Tracking","text":"<p>In AWS users can gain a detailed insight about the cost of their usage by leveraging Data Exports. It allows organizations to create customized exports of the AWS Cost and Usage Report (CUR) 2.0, offering daily or hourly usage insights along with rates, costs, and usage attributes across all chargeable AWS services. The standard data export option delivers customized cost data to Amazon S3 on a recurring basis. With Data Exports users can also track the cost incurred by their pods running in their EKS cluster. </p> <p>In this section we will show you how you can use the Data Exports data to track cost at the Virtual Cluster level, for both the compute and the Amazon EMR on EKS uplift, this would allow you to have a comprehensive view on the cost incured by your jobs.</p>"},{"location":"cost-optimization/docs/cost-tracking/#create-data-exports","title":"Create Data Exports","text":"<p>To create a Data Export report you can execute the following shell script, or you can create by following the AWS documentation.</p> <pre><code>sh create-bucket-data-export.sh NAME-OF-S3-BUCKET-TO-CREATE ACCOUNT-ID REPORT-NAME \n</code></pre> <p>NOTE: if you create it following the AWS documentation, make sure to select the <code>split cost allocation</code> and <code>resource-id</code> to be included in the Data export.</p>"},{"location":"cost-optimization/docs/cost-tracking/#create-the-cost-views","title":"Create the cost views","text":"<p>To get the total cost we will use Amazon Athena to query the cost data from the Data Export report. Using Athena we will first create a table for data exported by Data Export report, then we will create a mapping table that will contain the mapping an Amazon EMR on EKS Virtual Cluster to a namespace. Afterward we will create two views one that will represent the compute cost and a second that will contain the EMR on EKS uplift. Last we will create a view that will combine both the cost of the EMR on EKS uplift as well as the compute, this view will be a union of the two views we created earlier.   </p>"},{"location":"cost-optimization/docs/cost-tracking/#create-the-data-exports-report-table","title":"Create the data exports report table","text":"<p>You can use the following query to create the data export table, if you used the script provided you can just replace the S3 bucket name. If you have created the export report not using the provided shell script then you need to update the S3 location to match the one of where the data is exported by data export report you created.</p>"},{"location":"cost-optimization/docs/cost-tracking/#create-the-virtual-cluster-and-namespace-lookup-table","title":"Create the Virtual cluster and namespace lookup table","text":"<p>To create the look up table you can you the following sql statement.</p> <pre><code>    CREATE EXTERNAL TABLE `virtual_cluster_lookup`(\n    `virtual_cluster_id` string, \n    `namespace` string)\n    ROW FORMAT DELIMITED \n    FIELDS TERMINATED BY ',' \n    STORED AS INPUTFORMAT \n    'org.apache.hadoop.mapred.TextInputFormat' \n    OUTPUTFORMAT \n    'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat'\n    LOCATION\n    's3://BUCKET-NAME/data/virtual_cluster_definition'\n</code></pre> <p>Make sure to insert the look up data, you can use the query below as an example.</p> <pre><code>INSERT INTO virtual_cluster_lookup \nVALUES ('96nxs46332423542abnbd2iuv6049', 'myvc')\n</code></pre>"},{"location":"cost-optimization/docs/cost-tracking/#create-the-emr-on-eks-uplift-view","title":"Create the EMR on EKS uplift view","text":"<p>To create EMR on EKS uplift view  ou can use the following sql statement.</p> <p>NOTE: You may need to change the source data table if you created the data export yourself. The query below has the source data table called <code>data</code> </p> <pre><code>    CREATE OR REPLACE VIEW \"emr_uplift_per_vc_view\" AS \n    WITH\n    emr_uplift_per_vc AS (\n    SELECT\n        DATE_FORMAT(DATE_TRUNC('month', \"line_item_usage_start_date\"), '%Y-%m') \"month\",\n        split_part(line_item_resource_id, '/', 3) vc_id,\n        sum(line_item_blended_cost) cost\n    FROM\n        data\n    WHERE ((line_item_product_code = 'ElasticMapReduce') AND (line_item_operation = 'StartJobRun'))\n    GROUP BY line_item_resource_id, 1\n    ) \n    SELECT\n    month,\n    namespace,\n    SUM(cost) cost\n    FROM\n    (emr_uplift_per_vc uplift\n    INNER JOIN virtual_cluster_lookup lookup ON (uplift.vc_id = lookup.virtual_cluster_id))\n    GROUP BY month, namespace\n</code></pre>"},{"location":"cost-optimization/docs/cost-tracking/#create-the-compute-cost-view","title":"Create the Compute cost view","text":"<p>To create Compute cost view  ou can use the following sql statement.</p> <p>NOTE: You may need to change the source data table if you created the data export yourself. The query below has the source data table called <code>data</code> </p> <pre><code>CREATE OR REPLACE VIEW \"compute_cost_per_namespace_view\" AS\nSELECT\n  DATE_FORMAT(DATE_TRUNC('month', \"line_item_usage_start_date\"), '%Y-%m') \"month\"\n, CONCAT(REPLACE(SPLIT_PART(\"line_item_resource_id\", '/', 1), 'pod', 'cluster'), '/', SPLIT_PART(\"line_item_resource_id\", '/', 2)) \"cluster_arn\"\n, SPLIT_PART(\"line_item_resource_id\", '/', 3) \"namespace\"\n, SUM((CASE WHEN (\"line_item_usage_type\" LIKE '%EKS-EC2-vCPU-Hours') THEN (\"split_line_item_split_cost\" + \"split_line_item_unused_cost\") ELSE 0E0 END)) \"cpu_cost\"\n, SUM((CASE WHEN (\"line_item_usage_type\" LIKE '%EKS-EC2-GB-Hours') THEN (\"split_line_item_split_cost\" + \"split_line_item_unused_cost\") ELSE 0E0 END)) \"ram_cost\"\n, SUM((\"split_line_item_split_cost\" + \"split_line_item_unused_cost\")) \"total_cost\"\nFROM\n  (data\nINNER JOIN virtual_cluster_lookup lookup ON (SPLIT_PART(\"line_item_resource_id\", '/', 3) = lookup.namespace))\nWHERE (\"line_item_operation\" = 'EKSPod-EC2')\nGROUP BY 1, 2, 3\nORDER BY \"month\" DESC, \"cluster_arn\" ASC, \"namespace\" ASC, \"total_cost\" DESC\n</code></pre>"},{"location":"cost-optimization/docs/cost-tracking/#create-the-over-all-cost-view","title":"Create the over all cost view","text":"<p>To create over all cost view view  ou can use the following sql statement.</p> <pre><code>CREATE OR REPLACE VIEW emr_eks_cost AS\n\nSELECT month, namespace, total_cost as cost FROM \"reinventdemo\".\"compute_cost_per_namespace_view\"\n\nUNION\n\nSELECT month, namespace, cost FROM \"reinventdemo\".\"emr_uplift_per_vc_view\"\n</code></pre>"},{"location":"cost-optimization/docs/cost-tracking/#query-the-data","title":"Query the data","text":"<p>After creating the views you can now get insights on the total cost of runing your EMR on EKS job at the virtual cluster level. The query below shows how you van get the over all cost.</p> <pre><code>SELECT month, namespace, sum(cost) as total_cost\nFROM \"emr_eks_cost\"\nGROUP BY namespace, month\n</code></pre> <p>NOTE: In these views the granularity is at the month level, you can also run it at the day level, you can achieve it by changing the date in the SQL queries to include also the day, </p>"},{"location":"cost-optimization/docs/node-decommission/","title":"Node Decommission","text":"<p>This section shows how to use an Apache Spark feature that allows you to store the shuffle data and cached RDD blocks present on the terminating executors to peer executors before a Spot node gets decommissioned. Consequently, your job does not need to recalculate the shuffle and RDD blocks of the terminating executor that would otherwise be lost, thus allowing the job to have minimal delay in completion. </p> <p>This feature is supported for releases EMR 6.3.0+.</p>"},{"location":"cost-optimization/docs/node-decommission/#how-does-it-work","title":"How does it work?","text":"<p>When <code>spark.decommission.enabled</code> is true, Spark will try its best to shut down the executor gracefully. <code>spark.storage.decommission.enabled</code> will enable migrating data stored on the executor. Spark will try to migrate all the cached RDD blocks (controlled by <code>spark.storage.decommission.rddBlocks.enabled</code>) and shuffle blocks (<code>controlled by spark.storage.decommission.shuffleBlocks.enabled</code>) from the decommissioning executor to all remote executors when spark decommission is enabled. Relevant Spark configurations for using node decommissioning in the jobs are</p> Configuration Description Default Value spark.decommission.enabled Whether to enable decommissioning false spark.storage.decommission.enabled Whether to decommission the block manager when decommissioning executor false spark.storage.decommission.rddBlocks.enabled Whether to transfer RDD blocks during block manager decommissioning. false spark.storage.decommission.shuffleBlocks.enabled Whether to transfer shuffle blocks during block manager decommissioning. Requires a migratable shuffle resolver (like sort based shuffle) false spark.storage.decommission.maxReplicationFailuresPerBlock Maximum number of failures which can be handled for migrating shuffle blocks when block manager is decommissioning and trying to move its existing blocks. 3 spark.storage.decommission.shuffleBlocks.maxThreads Maximum number of threads to use in migrating shuffle files. 8 <p>This feature can currently be enabled through a temporary workaround on EMR 6.3.0+ releases. To enable it, Spark\u2019s decom.sh file permission must be modified using a custom image. Once the code is fixed, the page will be updated.</p> <p>Dockerfile for custom image:</p> <pre><code>FROM &lt;release account id&gt;.dkr.ecr.&lt;aws region&gt;.amazonaws.com/spark/&lt;release&gt;\nUSER root\nWORKDIR /home/hadoop\nRUN chown hadoop:hadoop /usr/bin/decom.sh\n</code></pre> <p>Setting decommission timeout:</p> <p>Each executor has to be decommissioned within a certain time limit controlled by the pod\u2019s terminationGracePeriodSeconds configuration.  The default value is 30 secs but can be modified using a custom pod template. The pod template for this modification would look like </p> <pre><code>apiVersion: v1\nkind: Pod\nspec:\n  terminationGracePeriodSeconds: &lt;seconds&gt;\n</code></pre> <p>Note: terminationGracePeriodSeconds timeout should be lesser than spot instance timeout with around 5 seconds buffer kept aside for triggering the node termination</p> <p>Request:</p> <pre><code>cat &gt;spark-python-with-node-decommissioning.json &lt;&lt; EOF\n{\n   \"name\": \"my-job-run-with-node-decommissioning\",\n   \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\",\n   \"executionRoleArn\": \"&lt;execution-role-arn&gt;\",\n   \"releaseLabel\": \"emr-6.3.0-latest\", \n   \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n   }, \n   \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n       \"classification\": \"spark-defaults\",\n       \"properties\": {\n       \"spark.kubernetes.container.image\": \"&lt;account_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/&lt;custom_image_repo&gt;\",\n       \"spark.executor.instances\": \"5\",\n        \"spark.decommission.enabled\": \"true\",\n        \"spark.storage.decommission.rddBlocks.enabled\": \"true\",\n        \"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\",\n        \"spark.storage.decommission.enabled\": \"true\"\n       }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"&lt;log group&gt;\", \n        \"logStreamNamePrefix\": \"&lt;log-group-prefix&gt;\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"&lt;S3 URI&gt;\"\n      }\n    }\n   } \n}\nEOF\n</code></pre> <p>Observed Behavior:</p> <p>When executors begin decommissioning, its shuffle data gets migrated to peer executors instead of recalculating the shuffle blocks again. If sending shuffle blocks to an executor fails, <code>spark.storage.decommission.maxReplicationFailuresPerBlock</code> will give the number of retries for migration. The driver log\u2019s stderr will see log lines <code>Updating map output for &lt;shuffle_id&gt; to BlockManagerId(&lt;executor_id&gt;, &lt;ip_address&gt;, &lt;port&gt;, &lt;topology_info&gt;)</code> denoting details about shuffle block \u2018s migration. This feature does not emit any other metrics for validation yet."},{"location":"metastore-integrations/docs/aws-glue/","title":"EMR Containers integration with AWS Glue","text":""},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-same-account-as-eks","title":"AWS Glue catalog in same account as EKS","text":"<p>In the below example a Spark application will be configured to use AWS Glue data catalog as the hive metastore.  </p> <p>gluequery.py</p> <pre><code>cat &gt; gluequery.py &lt;&lt;EOF\nfrom os.path import expanduser, join, abspath\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Row\n# warehouse_location points to the default location for managed databases and tables\nwarehouse_location = abspath('spark-warehouse')\nspark = SparkSession \\\n    .builder \\\n    .appName(\"Python Spark SQL Hive integration example\") \\\n    .config(\"spark.sql.warehouse.dir\", warehouse_location) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\nspark.sql(\"CREATE EXTERNAL TABLE `sparkemrnyc`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://&lt;s3 prefix&gt;/trip-data.parquet/'\")\nspark.sql(\"SELECT count(*) FROM sparkemrnyc\").show()\nspark.stop()\nEOF\n</code></pre> <pre><code>LOCATION 's3://&lt;s3 prefix&gt;/trip-data.parquet/'\n</code></pre> <p>Configure the above property to point to the S3 location containing the data. </p> <p>Request</p> <pre><code>cat &gt; Spark-Python-in-s3-awsglue-log.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-awsglue-log\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/gluequery.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-log.json\n</code></pre> <p>Output from driver logs - Displays the number of rows.</p> <pre><code>+----------+\n|  count(1)|\n+----------+\n|2716504499|\n+----------+\n</code></pre>"},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-different-account","title":"AWS Glue catalog in different account","text":"<p>The Spark application is submitted to EMR Virtual cluster in Account A and is configured to connect to AWS Glue catalog in Account B. The IAM policy attached to the job execution role <code>(\"executionRoleArn\": \"&lt;execution-role-arn&gt;\")</code>is in Account A</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"glue:*\"\n            ],\n            \"Resource\": [\n                \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:catalog\",\n                \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:database/default\",\n                \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:table/default/sparkemrnyc\"\n            ]\n        }\n    ]\n}\n</code></pre> <p>IAM policy attached to the AWS Glue catalog in Account B</p> <pre><code>{\n  \"Version\" : \"2012-10-17\",\n  \"Statement\" : [ {\n    \"Effect\" : \"Allow\",\n    \"Principal\" : {\n      \"AWS\" : \"&lt;execution-role-arn&gt;\"\n    },\n    \"Action\" : \"glue:*\",\n    \"Resource\" : [ \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:catalog\", \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:database/default\", \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:table/default/sparkemrnyc\" ]\n  } ]\n}\n</code></pre> <p>Request</p> <pre><code>cat &gt; Spark-Python-in-s3-awsglue-crossaccount.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-awsglue-crossaccount\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/gluequery.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n          \"spark.hadoop.hive.metastore.glue.catalogid\":\"&lt;account B&gt;\",\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-crossaccount.json\n</code></pre> <p>Configuration of interest  To specify the accountID where the AWS Glue catalog is defined reference the following: </p> <p>Spark-Glue integration</p> <pre><code>\"spark.hadoop.hive.metastore.glue.catalogid\":\"&lt;account B&gt;\",\n</code></pre> <p>Output from driver logs - displays the number of rows.</p> <pre><code>+----------+\n|  count(1)|\n+----------+\n|2716504499|\n+----------+\n</code></pre>"},{"location":"metastore-integrations/docs/aws-glue/#sync-hudi-table-with-aws-glue-catalog","title":"Sync Hudi table with AWS Glue catalog","text":"<p>In this example, a Spark application will be configured to use AWS Glue data catalog as the hive metastore. </p> <p>Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Glue catalog via the Hive Metastore Service (HMS) in hive sync mode. This example runs a Hudi ETL job with EMR on EKS, and interact with AWS Glue metaStore to create a Hudi table. It provides you the native and serverless capabilities to manage your technical metadata. Also you can query Hudi tables in Athena straigt away after the ETL job, which provides your end user an easy data access and shortens the time to insight.</p> <p>HudiEMRonEKS.py</p> <pre><code>cat &gt; HudiEMRonEKS.py &lt;&lt;EOF\nimport sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", sys.argv[1]+\"/warehouse/\" ) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\n# Create a DataFrame\ninputDF = spark.createDataFrame(\n    [\n        (\"100\", \"2015-01-01\", \"2015-01-01T13:51:39.340396Z\"),\n        (\"101\", \"2015-01-01\", \"2015-01-01T12:14:58.597216Z\"),\n        (\"102\", \"2015-01-01\", \"2015-01-01T13:51:40.417052Z\"),\n        (\"103\", \"2015-01-01\", \"2015-01-01T13:51:40.519832Z\"),\n        (\"104\", \"2015-01-02\", \"2015-01-01T12:15:00.512679Z\"),\n        (\"105\", \"2015-01-02\", \"2015-01-01T13:51:42.248818Z\"),\n    ],\n    [\"id\", \"creation_date\", \"last_update_time\"]\n)\n\n# Specify common DataSourceWriteOptions in the single hudiOptions variable\ntest_tableName = \"hudi_tbl\"\nhudiOptions = {\n'hoodie.table.name': test_tableName,\n'hoodie.datasource.write.recordkey.field': 'id',\n'hoodie.datasource.write.partitionpath.field': 'creation_date',\n'hoodie.datasource.write.precombine.field': 'last_update_time',\n'hoodie.datasource.hive_sync.enable': 'true',\n'hoodie.datasource.hive_sync.table': test_tableName,\n'hoodie.datasource.hive_sync.database': 'default',\n'hoodie.datasource.write.hive_style_partitioning': 'true',\n'hoodie.datasource.hive_sync.partition_fields': 'creation_date',\n'hoodie.datasource.hive_sync.partition_extractor_class': 'org.apache.hudi.hive.MultiPartKeysValueExtractor',\n'hoodie.datasource.hive_sync.mode': 'hms'\n}\n\n\n# Write a DataFrame as a Hudi dataset\ninputDF.write \\\n.format('org.apache.hudi') \\\n.option('hoodie.datasource.write.operation', 'bulk_insert') \\\n.options(**hudiOptions) \\\n.mode('overwrite') \\\n.save(sys.argv[1]+\"/hudi_hive_insert\")\nEOF\n</code></pre> <p>NOTE: configure the <code>warehouse dir</code> property to point to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environament vairable.</p> <pre><code>.config(\"spark.sql.warehouse.dir\", sys.argv[1]+\"/warehouse/\" )\n</code></pre> <p>Request</p> <pre><code>export S3BUCKET=YOUR_S3_BUCKET_NAME\n\naws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name hudi-test1 \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.3.0-latest \\\n--job-driver '{\n  \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\",\n      \"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n      \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\\n--configuration-overrides '{\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\",\n          \"spark.sql.hive.convertMetastoreParquet\": \"false\",\n          \"spark.hadoop.hive.metastore.client.factory.class\": \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\"\n        }}\n    ], \n    \"monitoringConfiguration\": {\n      \"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre> <p>NOTE: To get a correct verison of hudi library, we directly download the jar from the maven repository with the synctax of <code>\"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar</code>. Starting from EMR 6.5, the Hudi-spark3-bundle library will be included in EMR docker images.</p>"},{"location":"metastore-integrations/docs/hive-metastore/","title":"EMR Containers integration with Hive Metastore","text":"<p>For more details, check out the github repository, which includes CDK/CFN templates that help you to get started quickly.</p>"},{"location":"metastore-integrations/docs/hive-metastore/#1-hive-metastore-database-through-jdbc","title":"1-Hive metastore Database through JDBC","text":"<p>In this example, a Spark application is configured to connect to a Hive Metastore database provisioned with Amazon RDS Aurora MySql via a JDBC connection. The Amazon RDS and EKS cluster should be in same VPC or else the Spark job will not be able to connect to RDS. </p> <p>You directly pass in the JDBC credentials at the job/application level, which is a simple and quick solution to make a connection to the HMS. However, it is not recommended in a production environment. From the security perspective, the password management could be a risk since the JDBC credentials will appear in all of your job logs. Also engineers may be required to hold the password when it is not necessary.</p> <p>Request: </p> <pre><code>cat &gt; Spark-Python-in-s3-hms-jdbc.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-hms-jdbc\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/hivejdbc.py\", \n       \"sparkSubmitParameters\": \"--jars s3://&lt;s3 prefix&gt;/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=&lt;connection-user-name&gt; --conf spark.hadoop.javax.jdo.option.ConnectionPassword=&lt;connection-password&gt; --conf spark.hadoop.javax.jdo.option.ConnectionURL=&lt;JDBC-Connection-string&gt; --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-jdbc.json\n</code></pre> <p>In this example we are connecting to mysql db, so <code>mariadb-connector-java.jar</code> needs to be passed with <code>--jars</code> option. If you are using postgres, Oracle or any other database, the appropriate connector jar needs to be included.  </p> <p>Configuration of interest:</p> <pre><code>--jars s3://&lt;s3 prefix&gt;/mariadb-connector-java.jar\n--conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver \n--conf spark.hadoop.javax.jdo.option.ConnectionUserName=&lt;connection-user-name&gt;  \n--conf spark.hadoop.javax.jdo.option.ConnectionPassword=&lt;connection-password&gt;\n--conf spark.hadoop.javax.jdo.option.ConnectionURL**=&lt;JDBC-Connection-string&gt;\n</code></pre> <p>hivejdbc.py</p> <pre><code>from os.path import expanduser, join, abspath\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Row\n# warehouse_location points to the default location for managed databases and tables\nwarehouse_location = abspath('spark-warehouse')\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", warehouse_location) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE EXTERNAL TABLE `ehmsdb`.`sparkemrnyc5`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://&lt;s3 prefix&gt;/nyctaxi_parquet/'\")\nspark.sql(\"SELECT count(*) FROM ehmsdb.sparkemrnyc5 \").show()\nspark.stop()\n</code></pre> <p>The above job lists databases from a remote RDS Hive Metastore, creates a new table and then queries it.</p>"},{"location":"metastore-integrations/docs/hive-metastore/#2-hive-metastore-thrift-service-through-thrift-protocol","title":"2-Hive metastore thrift service through thrift:// protocol","text":"<p>In this example, the spark application is configured to connect to an external Hive metastore thrift server. The thrift server is running on <code>EMR on EC2's master node</code> and AWS RDS Aurora is used as database for the Hive metastore. </p> <p>Running an EMR on EC2 cluster as a thrift server, simplify the application configuration and setup. You can start quickly with reduced engineering effort. However, your maintenance overhead may increase, since you will be monitoring two types of clusters, i.e. EMR on EC2 and EMR on EKS.</p> <p>thriftscript.py: <code>hive.metastore.uris</code> config needs to be set to read from external Hive metastore. The URI format looks like this: <code>thrift://EMR_ON_EC2_MASTER_NODE_DNS_NAME:9083</code></p> <pre><code>from os.path import expanduser, join, abspath\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Row\n# warehouse_location points to the default location for managed databases and tables\nwarehouse_location = abspath('spark-warehouse')\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", warehouse_location) \\\n    .config(\"hive.metastore.uris\",\"&lt;hive metastore thrift uri&gt;\") \\\n    .enableHiveSupport() \\\n    .getOrCreate()\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE EXTERNAL TABLE ehmsdb.`sparkemrnyc2`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://&lt;s3 prefix&gt;/nyctaxi_parquet/'\")\nspark.sql(\"SELECT * FROM ehmsdb.sparkemrnyc2\").show()\nspark.stop()\n</code></pre> <p>Request:</p> <p>The below job lists databases from remote Hive Metastore, creates a new table and then queries it.</p> <pre><code>cat &gt; Spark-Python-in-s3-hms-thrift.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-hms-thrift\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/thriftscript.py\", \n       \"sparkSubmitParameters\": \"--jars s3://&lt;s3 prefix&gt;/mariadb-connector-java.jar --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-thrift.json\n</code></pre>"},{"location":"metastore-integrations/docs/hive-metastore/#3-connect-hive-metastore-via-thrift-service-hosted-on-eks","title":"3-Connect Hive metastore via thrift service hosted on EKS","text":"<p>In this example, our Spark application connects to a standalone Hive metastore service (HMS) running in EKS.</p> <p>Running the standalone HMS in EKS unifies your analytics applications with other business critical apps in a single platform. It simplifies your solution architecture and infrastructure design. The helm chart solution includes autoscaling feature, so your EKS cluster can automatically expand or shrink when the HMS request volume changes. Also it follows the security best practice to manage JDBC credentials via AWS Secrets Manager. However, you will need a combination of analytics and k8s skills to maintain this solution.</p> <p>To install the HMS helm chart, simply replace the environment variables in values.yaml, then manually <code>helm install</code> via the command below. Otherwise, deploy the HMS via a CDK/CFN template with a security best practice. Check out the CDK project for more details.</p> <pre><code>cd hive-emr-on-eks/hive-metastore-chart\n\nsed -i '' -e 's/{RDS_JDBC_URL}/\"jdbc:mysql:\\/\\/'$YOUR_HOST_NAME':3306\\/'$YOUR_DB_NAME'?createDatabaseIfNotExist=true\"/g' values.yaml \nsed -i '' -e 's/{RDS_USERNAME}/'$YOUR_USER_NAME'/g' values.yaml \nsed -i '' -e 's/{RDS_PASSWORD}/'$YOUR_PASSWORD'/g' values.yaml\nsed -i '' -e 's/{S3BUCKET}/s3:\\/\\/'$YOUR_S3BUCKET'/g' values.yaml\n\nhelm repo add hive-metastore https://aws-samples.github.io/hive-metastore-chart \nhelm install hive hive-metastore/hive-metastore -f values.yaml --namespace=emr --debug\n</code></pre> <p>hivethrift_eks.py</p> <pre><code>from os import environ\nimport sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\",environ['warehouse_location']) \\\n    .config(\"hive.metastore.uris\",\"thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\") \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE DATABASE IF NOT EXISTS `demo`\")\nspark.sql(\"DROP TABLE IF EXISTS demo.amazonreview3\")\nspark.sql(\"CREATE EXTERNAL TABLE IF NOT EXISTS `demo`.`amazonreview3`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\"+sys.argv[1]+\"/app_code/data/toy/'\")\nspark.sql(\"SELECT coount(*) FROM demo.amazonreview3\").show()\nspark.stop()\n</code></pre> <p>An environment variable <code>HIVE_METASTORE_SERVICE_HOST</code> appears in your Spark application pods automatically, once the standalone HMS is up running in EKS. You can directly set the <code>hive.metastore.uris</code> to <code>thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\"</code>.</p> <p>Can set the <code>spark.sql.warehouse.dir</code> property to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environment variable.</p> <p>Request:</p> <pre><code>#!/bin/bash\naws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name spark-hive-via-thrift \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.2.0-latest \\\n--job-driver '{\n  \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/hivethrift_eks.py\",\n      \"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n      \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\\n--configuration-overrides '{\n    \"monitoringConfiguration\": {\n      \"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre>"},{"location":"metastore-integrations/docs/hive-metastore/#4-run-thrift-service-as-a-sidecar-in-spark-drivers-pod","title":"4-Run thrift service as a sidecar in Spark Driver's pod","text":"<p>This advanced solution runs the standalone HMS thrift service inside a Spark driver as a sidecar. It means each Spark job will have its dedicated thrift server. The benefit of the design is HMS is no long a single point of failure, since each Spark application has its own HMS. Also it is no long a long running service, i.e. it spins up when your Spark job starts, then terminates when your job is done. The sidecar follows the security best practice via leveraging Secrets Manager to extract JDBC crednetials. However, the maintenance of the sidecar increases because you now need to manage the hms sidecar, custom configmaps and sidecar pod templates. Also this solution requires combination skills of analytics and k8s. </p> <p>The CDK/CFN template is available to simplify the installation against a new EKS cluster. If you have an existing EKS cluster, the prerequisite details can be found in the github repository</p> <p>sidecar_hivethrift_eks.py:</p> <pre><code>import sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\",environ['warehouse_location']) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE DATABASE IF NOT EXISTS `demo`\")\nspark.sql(\"DROP TABLE IF EXISTS demo.amazonreview4\")\nspark.sql(\"CREATE EXTERNAL TABLE `demo`.`amazonreview4`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\"+sys.argv[1]+\"/app_code/data/toy/'\")\nspark.sql(\"SELECT coount(*) FROM demo.amazonreview4\").show()\nspark.stop()\n</code></pre> <p>Request:</p> <p>Now that the HMS is running inside your Spark driver, it shares common attributes such as the network config, the <code>spark.hive.metastore.uris</code> can set to \"thrift://localhost:9083\". Don't forget to assign the sidecar pod template to the Spark Driver like this <code>\"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\"</code> </p> <p>For more details, check out the github repo</p> <pre><code>#!/bin/bash\n# test HMS sidecar on EKS\naws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name sidecar-hms \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.3.0-latest \\\n--job-driver '{\n  \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hivethrift_eks.py\",\n      \"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n      \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\\n--configuration-overrides '{\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\",\n          \"spark.hive.metastore.uris\": \"thrift://localhost:9083\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre>"},{"location":"metastore-integrations/docs/hive-metastore/#5-hudi-remote-hive-metastore-integration","title":"5-Hudi + Remote Hive metastore integration","text":"<p>Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Hive metastore in HMS sync mode, with this setting <code>'hoodie.datasource.hive_sync.mode': 'hms'</code>. </p> <p>This example runs a Hudi job with EMR on EKS, and interact with a remote RDS hive metastore to create a Hudi table. As a serverless option, it can interact with AWS Glue catalog. check out the AWS Glue section for more details.</p> <p>HudiEMRonEKS.py</p> <pre><code>from os import environ\nimport sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", sys.argv[1]+\"/warehouse/\" ) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\n# Create a DataFrame\ninputDF = spark.createDataFrame(\n    [\n        (\"100\", \"2015-01-01\", \"2015-01-01T13:51:39.340396Z\"),\n        (\"101\", \"2015-01-01\", \"2015-01-01T12:14:58.597216Z\"),\n        (\"102\", \"2015-01-01\", \"2015-01-01T13:51:40.417052Z\"),\n        (\"103\", \"2015-01-01\", \"2015-01-01T13:51:40.519832Z\"),\n        (\"104\", \"2015-01-02\", \"2015-01-01T12:15:00.512679Z\"),\n        (\"105\", \"2015-01-02\", \"2015-01-01T13:51:42.248818Z\"),\n    ],\n    [\"id\", \"creation_date\", \"last_update_time\"]\n)\n\n# Specify common DataSourceWriteOptions in the single hudiOptions variable\ntest_tableName = \"hudi_tbl\"\nhudiOptions = {\n'hoodie.table.name': test_tableName,\n'hoodie.datasource.write.recordkey.field': 'id',\n'hoodie.datasource.write.partitionpath.field': 'creation_date',\n'hoodie.datasource.write.precombine.field': 'last_update_time',\n'hoodie.datasource.hive_sync.enable': 'true',\n'hoodie.datasource.hive_sync.table': test_tableName,\n'hoodie.datasource.hive_sync.database': 'default',\n'hoodie.datasource.write.hive_style_partitioning': 'true',\n'hoodie.datasource.hive_sync.partition_fields': 'creation_date',\n'hoodie.datasource.hive_sync.partition_extractor_class': 'org.apache.hudi.hive.MultiPartKeysValueExtractor',\n'hoodie.datasource.hive_sync.mode': 'hms'\n}\n\n\n# Write a DataFrame as a Hudi dataset\ninputDF.write \\\n.format('org.apache.hudi') \\\n.option('hoodie.datasource.write.operation', 'bulk_insert') \\\n.options(**hudiOptions) \\\n.mode('overwrite') \\\n.save(sys.argv[1]+\"/hudi_hive_insert\")\n\nprint(\"After {}\".format(spark.catalog.listTables()))\n</code></pre> <p>Request:</p> <p>The latest Hudi-spark3-bundle library is needed to support the new HMS hive sync functionality. In the following sample script, it is downloaded from maven repository when submitting a job with EMR 6.3. Starting from EMR 6.5, you don't need the <code>--jars</code> setting anymore, because EMR 6.5+ includes the Hudi-spark3-bundle library. </p> <pre><code>aws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name hudi-test1 \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.3.0-latest \\\n--job-driver '{\n  \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\",\n      \"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n      \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\\n--configuration-overrides '{\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\",\n          \"spark.sql.hive.convertMetastoreParquet\": \"false\",\n          \"spark.hive.metastore.uris\": \"thrift://localhost:9083\",\n          \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\"\n        }}\n    ], \n    \"monitoringConfiguration\": {\n      \"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre>"},{"location":"node-placement/docs/eks-node-placement/","title":"EKS Node Placement","text":""},{"location":"node-placement/docs/eks-node-placement/#single-az-placement","title":"Single AZ placement","text":"<p>AWS EKS clusters can span multiple AZs in a VPC. A Spark application whose driver and executor pods are distributed across multiple AZs can incur inter-AZ data transfer costs. To minimize or eliminate inter-AZ data transfer costs, you can configure the application to only run on the nodes within a single AZ.  In this example, we use the kubernetes node selector to specify which AZ should the job run on.</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.kubernetes.node.selector.topology.kubernetes.io/zone='&lt;availability zone&gt;' --conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: When the job starts the driver pod and executor pods are scheduled only on those EKS worker nodes with the label <code>topology.kubernetes.io/zone: &lt;availability zone&gt;</code>. This ensures the spark job is run within a single AZ. If there are not enough resources within the specified AZ, the pods will be in the <code>pending</code> state until the Autoscaler(if configured) kicks in or more resources become available.</p> <p>Spark on kubernetes Node selector configuration Kubernetes Node selector reference</p> <p>Configuration of interest - </p> <pre><code>--conf spark.kubernetes.node.selector.zone='&lt;availability zone&gt;'\n</code></pre> <p><code>zone</code> is a built-in label that EKS assigns to every EKS worker Node. The above config will ensure to schedule the driver and executor pod on those EKS worker nodes labeled - <code>topology.kubernetes.io/zone: &lt;availability zone&gt;</code>. However, user defined labels can also be assigned to EKS worker nodes and used as node selector.</p> <p>Other common use cases are using node labels to force the job to run on on demand/spot, machine type, etc.  </p>"},{"location":"node-placement/docs/eks-node-placement/#single-az-and-ec2-instance-type-placement","title":"Single AZ and ec2 instance type placement","text":"<p>Multiple key value pairs for spark.kubernetes.node.selector.[labelKey] can be passed to add filter conditions for selecting the EKS worker node. If you want to schedule on EKS worker nodes in <code>&lt;availability zone&gt;</code> and instance-type as m5.4xlarge - it is done as below  </p> <p>Request:</p> <pre><code>{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\",\n          \"spark.kubernetes.node.selector.topology.kubernetes.io/zone\":\"&lt;availability zone&gt;\",\n          \"spark.kubernetes.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n      }\n      }\n    }\n  }\n}\n</code></pre> <p>Configuration of interest </p> <p><code>spark.kubernetes.node.selector.[labelKey] - Adds to the node selector of the driver pod and executor pods, with key labelKey and the value as the configuration's value. For example, setting spark.kubernetes.node.selector.identifier to myIdentifier will result in the driver pod and executors having a node selector with key identifier and value myIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.</code></p>"},{"location":"node-placement/docs/eks-node-placement/#job-submitter-pod-placement","title":"Job submitter pod placement","text":"<p>Similar to driver and executor pods, you can configure the job submitter pod's node selectors as well using the <code>emr-job-submitter</code> classification.  It is recommended for job submitter pods to have node placement on <code>ON_DEMAND</code> nodes and not <code>SPOT</code> nodes as the job will fail if the job submitter pod gets Spot instance interruptions. You can also place the job submitter pod in a single AZ or use any Kubernetes labels that are applied to the nodes.</p> <p>Note: The job submitter pod is also referred as the job-runner pod</p> <p>StartJobRun request with ON_DEMAND node placement for job submitter pod</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector-job-submitter.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      },\n      {\n        \"classification\": \"emr-job-submitter\",\n        \"properties\": {\n            \"jobsubmitter.node.selector.eks.amazonaws.com/capacityType\": \"ON_DEMAND\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector-job-submitter.json\n</code></pre> <p>StartJobRun request with Single AZ node placement for job submitter pod:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector-job-submitter-az.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      },\n      {\n        \"classification\": \"emr-job-submitter\",\n        \"properties\": {\n            \"jobsubmitter.node.selector.topology.kubernetes.io/zone\": \"&lt;availability zone&gt;\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector-job-submitter-az.json\n</code></pre> <p>StartJobRun request with single AZ and ec2 instance type placement for job submitter pod:</p> <pre><code>{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\",\n         }\n      },\n      {\n        \"classification\": \"emr-job-submitter\",\n        \"properties\": {\n            \"jobsubmitter.node.selector.topology.kubernetes.io/zone\": \"&lt;availability zone&gt;\",\n            \"jobsubmitter.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n      }\n      }\n    }\n  }\n}\n</code></pre> <p>Configurations of interest:</p> <p><code>jobsubmitter.node.selector.[labelKey]</code>: Adds to the node selector of the job submitter pod, with key <code>labelKey</code> and the value as the configuration's value. For example, setting <code>jobsubmitter.node.selector.identifier</code> to <code>myIdentifier</code> will result in the job-runner pod having a node selector with key identifier and value <code>myIdentifier</code>. Multiple node selector keys can be added by setting multiple configurations with this prefix.</p>"},{"location":"node-placement/docs/fargate-node-placement/","title":"EKS Fargate Node Placement","text":""},{"location":"node-placement/docs/fargate-node-placement/#fargate-node-placement","title":"Fargate Node Placement","text":"<p>AWS Fargate is a technology that provides on-demand, right-sized compute capacity for containers. With AWS Fargate, you don't have to provision, configure, or scale groups of EC2 instances on your own to run containers. You also don't need to choose server types, decide when to scale your node groups, or optimize cluster packing. Instead you can control which pods start on Fargate and how they run with Fargate profiles.</p>"},{"location":"node-placement/docs/fargate-node-placement/#aws-fargate-profile","title":"AWS Fargate profile","text":"<p>Before you can schedule pods on Fargate in your cluster, you must define at least one Fargate profile that specifies which pods use Fargate when launched.  You must define a namespace for every selector. The Fargate profile allows an administrator to declare which pods run on Fargate. This declaration is done through the profile\u2019s selectors. If a namespace selector is defined without any labels, Amazon EKS attempts to schedule all pods that run in that namespace onto Fargate using the profile.</p> <p>Create Fargate Profile Create your Fargate profile with the following eksctl command, replacing the <code>&lt;variable text&gt;</code> (including &lt;&gt;) with your own values. You're required to specify a namespace. The <code>--labels</code> option is not required to create your Fargate profile, but will be required if you want to only run Spark executors on Fargate.</p> <pre><code>eksctl create fargateprofile \\\n    --cluster &lt;cluster_name&gt; \\\n    --name &lt;fargate_profile_name&gt; \\\n    --namespace &lt;virtual_cluster_mapped_namespace&gt; \\\n    --labels spark-node-placement=fargate\n</code></pre>"},{"location":"node-placement/docs/fargate-node-placement/#1-place-entire-job-including-driver-pod-on-fargate","title":"1- Place entire job including driver pod on Fargate","text":"<p>When both Driver and Executors use the same labels as the Fargate Selector, the entire job including the driver pod will run on Fargate.</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-fargate-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=4  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n            \"spark.kubernetes.driver.label.spark-node-placement\": \"fargate\",\n            \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: When the job starts, the driver pod and executor pods are scheduled only on Fargate since both are labeled with the <code>spark-node-placement: fargate</code>. This is useful when we want to run the entire job on Fargate nodes. The maximum vCPU available for the driver pod is 4vCPU. </p>"},{"location":"node-placement/docs/fargate-node-placement/#2-place-driver-pod-on-ec2-and-executor-pod-on-fargate","title":"2- Place driver pod on EC2 and executor pod on Fargate","text":"<p>Remove the label from the driver pod to schedule the driver pod on EC2 instances. This is especially helpful when driver pod needs more resources (i.e. &gt; 4 vCPU).</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-fargate-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=6 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n            \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: When the job starts, the driver pod schedules on an EC2 instance. EKS picks an instance from the first Node Group that has the matching resources available to the driver pod.</p>"},{"location":"node-placement/docs/fargate-node-placement/#3-define-a-nodeselector-in-pod-templates","title":"3- Define a NodeSelector in Pod Templates","text":"<p>Beginning with Amazon EMR versions 5.33.0 or 6.3.0, Amazon EMR on EKS supports Spark\u2019s pod template feature. Pod templates are specifications that determine how to run each pod. You can use pod template files to define the driver or executor pod\u2019s configurations that Spark configurations do not support. For example Spark configurations do not support defining individual node selectors for the driver pod and the executor pods. Define a node selector only for the driver pod when you want to choose on which pool of EC2 instance it should schedule. Let the Fargate Profile schedule the executor pods.</p> <p>Driver Pod Template</p> <pre><code>apiVersion: v1\nkind: Pod\nspec:\n  volumes:\n    - name: source-data-volume\n      emptyDir: {}\n    - name: metrics-files-volume\n      emptyDir: {}\n  nodeSelector:\n    &lt;ec2-instance-node-label-key&gt;: &lt;ec2-instance-node-label-value&gt;\n  containers:\n  - name: spark-kubernetes-driver # This will be interpreted as Spark driver container\n</code></pre> <p>Store the pod template file onto a S3 location:</p> <p><code>aws s3 cp /driver-pod-template.yaml s3://&lt;your-bucket-name&gt;/driver-pod-template.yaml</code></p> <p>Request</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-fargate-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n            \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\",\n            \"spark.kubernetes.driver.podTemplateFile\": \"s3://&lt;your-bucket-name&gt;/driver-pod-template.yaml\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: The driver pod schedules on an EC2 instance with enough capacity and matching label key / value with the node selector.</p>"},{"location":"outposts/emr-containers-on-outposts/","title":"Running EMR Containers on AWS Outposts","text":""},{"location":"outposts/emr-containers-on-outposts/#background","title":"Background","text":"<p>You can now run Amazon EMR container jobs on EKS clusters that are running on AWS Outposts. AWS Outposts enables native AWS services, infrastructure, and operating models in on-premises facilities. In AWS Outposts environments, you can use the same AWS APIs, tools, and infrastructure that you use in the AWS Cloud. Amazon EKS nodes on AWS Outposts is ideal for low-latency workloads that need to be run in close proximity to on-premises data and applications. For more information, see the Amazon EKS on Outposts documentation page.</p> <p>This document provides the steps to set up EMR containers on AWS Outposts.</p> <p></p>"},{"location":"outposts/emr-containers-on-outposts/#key-considerations-and-recommendations","title":"Key Considerations and Recommendations","text":"<ul> <li>The EKS cluster on an Outpost must be created with self-managed node groups.</li> <li>Use the AWS Management Console and AWS CloudFormation to create a self-managed node group in Outposts.</li> <li>For EMR workloads, we recommend creating EKS clusters where all the worker nodes reside in the self-managed node group of Outposts.</li> <li>The Kubernetes client in the Spark driver pod creates and monitor executor pods by communicating with the EKS managed Kubernetes API server residing in the parent AWS Region. For reliable monitoring of executor pods during a job run, we also recommend having a reliable low latency link between the Outpost and the parent Region.</li> <li>AWS Fargate is not available on Outposts.</li> <li>For more information about the supported Regions, prerequisites and considerations for Amazon EKS on AWS Outposts, see the EKS on Outposts documentation page.</li> </ul>"},{"location":"outposts/emr-containers-on-outposts/#infrastructure-setup","title":"Infrastructure Setup","text":""},{"location":"outposts/emr-containers-on-outposts/#setup-eks-on-outposts","title":"Setup EKS on Outposts","text":"<p>Network Setup </p> <ul> <li>Setup a VPC</li> </ul> <pre><code>aws ec2 create-vpc \\\n--region &lt;us-west-2&gt; \\\n--cidr-block '&lt;10.0.0.0/16&gt;'\n</code></pre> <p>In the output, take note of the VPC ID. </p> <pre><code>{\n    \"Vpc\": {\n        \"VpcId\": \"vpc-123vpc\", \n        ...\n    }\n}\n</code></pre> <ul> <li>Create two subnets in the parent Region.</li> </ul> <pre><code>aws ec2 create-subnet \\\n    --region '&lt;us-west-2&gt;' \\\n    --availability-zone-id '&lt;usw2-az1&gt;' \\\n    --vpc-id '&lt;vpc-123vpc&gt;' \\\n    --cidr-block '&lt;10.0.1.0/24&gt;'\n\naws ec2 create-subnet \\\n    --region '&lt;us-west-2&gt;' \\\n    --availability-zone-id '&lt;usw2-az2&gt;' \\\n    --vpc-id '&lt;vpc-123vpc&gt;' \\\n    --cidr-block '&lt;10.0.2.0/24&gt;'\n</code></pre> <p>In the output, take note of the Subnet ID.</p> <pre><code>{\n    \"Subnet\": {\n        \"SubnetId\": \"subnet-111\",\n        ...\n    }\n}\n{\n    \"Subnet\": {\n        \"SubnetId\": \"subnet-222\",\n        ...\n    }\n}\n</code></pre> <ul> <li>Create a subnet in the Outpost Availability Zone. (This step is different for Outposts)</li> </ul> <pre><code>aws ec2 create-subnet \\\n    --region '&lt;us-west-2&gt;' \\\n    --availability-zone-id '&lt;usw2-az1&gt;' \\\n    --outpost-arn 'arn:aws:outposts:&lt;us-west-2&gt;:&lt;123456789&gt;:outpost/&lt;op-123op&gt;' \\\n    --vpc-id '&lt;vpc-123vpc&gt;' \\\n    --cidr-block '&lt;10.0.3.0/24&gt;'\n</code></pre> <p>In the output, take note of the Subnet ID.</p> <pre><code>{\n    \"Subnet\": {\n        \"SubnetId\": \"subnet-333outpost\",\n        \"OutpostArn\": \"...\"\n        ...\n    }\n}\n</code></pre> <p>EKS Cluster Creation </p> <ul> <li>Create an EKS cluster using the three subnet Ids created earlier.</li> </ul> <pre><code>aws eks create-cluster \\\n    --region '&lt;us-west-2&gt;' \\\n    --name '&lt;outposts-eks-cluster&gt;' \\\n    --role-arn 'arn:aws:iam::&lt;123456789&gt;:role/&lt;cluster-service-role&gt;' \\\n    --resources-vpc-config  subnetIds='&lt;subnet-111&gt;,&lt;subnet-222&gt;,&lt;subnet-333outpost&gt;'\n</code></pre> <ul> <li>Check until the cluster status becomes active.</li> </ul> <pre><code>aws eks describe-cluster \\\n    --region '&lt;us-west-2&gt;' \\\n    --name '&lt;outposts-eks-cluster&gt;'\n</code></pre> <p>Note the values of resourcesVpcConfig.clusterSecurityGroupId and identity.oidc.issuer.</p> <pre><code>{\n    \"cluster\": {\n        \"name\": \"outposts-eks-cluster\",\n        ...\n        \"resourcesVpcConfig\": {\n            \"clusterSecurityGroupId\": \"sg-123clustersg\",\n        },\n        \"identity\": {\n            \"oidc\": {\n                \"issuer\": \"https://oidc.eks.us-west-2.amazonaws.com/id/oidcid\"\n            }\n        },\n        \"status\": \"ACTIVE\",\n    }\n}\n</code></pre> <ul> <li>Add the Outposts nodes to the EKS Cluster.</li> </ul> <p>At this point, eksctl cannot be used to launch self-managed node groups in Outposts. Please follow the steps listed in the self-managed nodes documentation page. In order to use the cloudformation script lised in the AWS Management Console tab, make note of the following values created in the earlier steps: * ClusterName: <code>&lt;outposts-eks-cluster&gt;</code> * ClusterControlPlaneSecurityGroup: <code>&lt;sg-123clustersg&gt;</code> * Subnets: <code>&lt;subnet-333outpost&gt;</code></p> <p>Apply the aws-auth-cm config map listed on the documentation page to allow the nodes to join the cluster.</p>"},{"location":"outposts/emr-containers-on-outposts/#register-cluster-with-emr-containers","title":"Register cluster with EMR Containers","text":"<p>Once the EKS cluster has been created and the nodes have been registered with the EKS control plane, take the following steps:</p> <ul> <li>Enable cluster access for Amazon EMR on EKS.</li> <li>Enable IAM Roles for Service Accounts (IRSA) on the EKS cluster.</li> <li>Create a job execution role.</li> <li>Update the trust policy of the job execution role.</li> <li>Grant users access to Amazon EMR on EKS.</li> <li>Register the Amazon EKS cluster with Amazon EMR.</li> </ul>"},{"location":"outposts/emr-containers-on-outposts/#conclusion","title":"Conclusion","text":"<p>EMR-EKS on Outposts allows users to run their big data jobs in close proximity to on-premises data and applications.</p>"},{"location":"performance/docs/binpack/","title":"Custom Scheduler for Binpacking","text":"<p>Binpacking directly influences the cost performance of your EKS cluster. Both Cluster Autoscaler and Karpenter, as node provisioners, can efficiently scales nodes in and out, but without a binpacking custom scheduler, you might end up with a scenario where nodes are underutilized due to inefficient pod distribution at the pod scheduling time.</p> <ul> <li>Better Binpacking: When pods are tightly packed onto fewer nodes, node provisioner (Cluster Autoscaler or Karpenter) can more effectively scale down unused nodes, reducing costs.</li> <li>Poor Binpacking: If pods are spread out inefficiently across many nodes, node provisioner might struggle to find opportunities to scale down, leading to resource waste.</li> </ul>"},{"location":"performance/docs/binpack/#demonstration","title":"Demonstration","text":"<p>Poor Binpacking with the default kube-scheduler:</p> <p> </p> <p>Better Binpacking with a Custom Scheduler:</p> <p> </p> <p>Before we tackle the binpacking issue in Amazon EMR on EKS, let\u2019s install a node viewer tool - eks-node-viewer. It  provides enhanced visibility into the EKS nodes utilization, helping with real-time monitoring, debugging, and optimization efforts. In this case, we use it to visualize dynamic node and pod allocation within an EKS cluster for tracking the binpacking performance.</p>"},{"location":"performance/docs/binpack/#install-eks-node-viewer","title":"Install eks-node-viewer","text":"<p>eks-node-viewer\uff1ahttps://github.com/awslabs/eks-node-viewer</p> <p>HomeBrew</p> <pre><code>brew tap aws/tap\nbrew install eks-node-viewer\n</code></pre> <p>Manual</p> <pre><code>go install github.com/awslabs/eks-node-viewer/cmd/eks-node-viewer@latest\n</code></pre> <p>Quick Start:</p> <pre><code>eks-node-viewer --resources cpu,memory\n</code></pre>"},{"location":"performance/docs/binpack/#install-bin-packing-custom-scheduler","title":"Install Bin-packing custom scheduler","text":"<p>In the scheduling-plugin <code>NodeResourcesFit</code> of kube-scheduler, there are two scoring strategies that support the bin packing of resources:       <code>MostAllocated</code> and <code>RequestedToCapacityRatio</code>. We created a custom scheduler based on the MostAllocated strategy. See the K8s\u2019s Resource Bin Packing documentation for more details.</p> <p>The following customer scheduler named \u201cmy-scheduler\u201d is created for EKS version v1.28, as the \u201ckube-scheduler\u201d container image version is required to match with EKS version. The KubeSchedulerConfiguration API version is stable(v1) in Kubernetes 1.25, for those cluster prior to 1.25, should use kubescheduler.config.k8s.io/v1beta2. Please adjust them accordingly if your EKS version is different.  </p> <p>We do not recommend build the kube-scheduler by yourself, you can leverage the eks-distro kube-scheduler image. For example:</p> <ul> <li>Amazon EKS 1.28 image: public.ecr.aws/eks-distro/kubernetes/kube-scheduler:v1.28.11-eks-1-28-latest</li> <li>Amazon EKS 1.29 image: public.ecr.aws/eks-distro/kubernetes/kube-scheduler:v1.29.6-eks-1-29-18</li> </ul> <p>NOTE: If your binpacking pod throttles for a large scale workload, please increase the QPS and Burst values in the \"configmap\" section:</p> <pre><code>   clientConnection:\n      burst: 200\n      qps: 100\n</code></pre> <p>An example of throttle error from the pod logs:</p> <pre><code>I1030 23:19:48.258159       1 request.go:697] Waited for 1.93509847s due to client-side throttling, not priority and fairness, request: POST:https://10.100.0.1:443/apis/events.k8s.io/v1/namespa...vents\nI1030 23:19:58.258457       1 request.go:697] Waited for 1.905177346s due to client-side throttling, not priority and fairness, request: POST:https://10.100.0.1:443/apis/events.k8s.io/v1/namespa...\n</code></pre> <p>Run the following command against EKS v1.28:</p> <pre><code>cat &lt;&lt;EOF | kubectl apply -f -\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: my-scheduler\n  namespace: kube-system\n---\nkind: ClusterRole\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: my-scheduler\nrules:\n- apiGroups:\n  - \"\"\n  - events.k8s.io\n  resources:\n  - events\n  verbs:\n  - create\n  - patch\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - configmaps\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - coordination.k8s.io\n  resources:\n  - leases\n  verbs:\n  - create\n  - get\n  - list\n  - update\n- apiGroups:\n  - coordination.k8s.io\n  resourceNames:\n  - kube-scheduler\n  resources:\n  - leases\n  verbs:\n  - get\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - endpoints\n  verbs:\n  - create\n- apiGroups:\n  - \"\"\n  resourceNames:\n  - kube-scheduler\n  resources:\n  - endpoints\n  verbs:\n  - get\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - nodes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - pods\n  verbs:\n  - delete\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - bindings\n  - pods/binding\n  verbs:\n  - create\n- apiGroups:\n  - \"\"\n  resources:\n  - pods/status\n  verbs:\n  - patch\n  - update\n- apiGroups:\n  - \"\"\n  resources:\n  - replicationcontrollers\n  - services\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - apps\n  - extensions\n  resources:\n  - replicasets\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - apps\n  resources:\n  - statefulsets\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - policy\n  resources:\n  - poddisruptionbudgets\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - persistentvolumeclaims\n  - persistentvolumes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - authentication.k8s.io\n  resources:\n  - tokenreviews\n  verbs:\n  - create\n- apiGroups:\n  - authorization.k8s.io\n  resources:\n  - subjectaccessreviews\n  verbs:\n  - create\n- apiGroups:\n  - storage.k8s.io\n  resources:\n  - csinodes\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - \"\"\n  resources:\n  - namespaces\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - storage.k8s.io\n  resources:\n  - csidrivers\n  verbs:\n  - get\n  - list\n  - watch\n- apiGroups:\n  - storage.k8s.io\n  resources:\n  - csistoragecapacities\n  verbs:\n  - get\n  - list\n  - watch\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: my-scheduler-as-kube-scheduler\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: my-scheduler\nsubjects:\n- kind: ServiceAccount\n  name: my-scheduler\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: my-scheduler-as-volume-scheduler\nsubjects:\n- kind: ServiceAccount\n  name: my-scheduler\n  namespace: kube-system\nroleRef:\n  kind: ClusterRole\n  name: system:volume-scheduler\n  apiGroup: rbac.authorization.k8s.io\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-scheduler-config\n  namespace: kube-system\ndata:\n  my-scheduler-config.yaml: |\n    apiVersion: kubescheduler.config.k8s.io/v1\n    kind: KubeSchedulerConfiguration\n    profiles:\n      - pluginConfig:\n          - args:\n              apiVersion: kubescheduler.config.k8s.io/v1\n              kind: NodeResourcesFitArgs\n              scoringStrategy:\n                  resources:\n                      - name: cpu\n                        weight: 1\n                      - name: memory\n                        weight: 1\n                  type: MostAllocated\n            name: NodeResourcesFit\n        plugins:\n          score:\n              enabled:\n                  - name: NodeResourcesFit\n                    weight: 1\n              disabled:\n                  - name: \"*\"\n          multiPoint:\n              enabled:\n                  - name: NodeResourcesFit\n                    weight: 1\n        schedulerName: my-scheduler\n    leaderElection:\n      leaderElect: true\n      resourceNamespace: kube-system\n      resourceName: my-scheduler\n    clientConnection:\n      burst: 200\n      qps: 100\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    component: scheduler\n    tier: control-plane\n  name: my-scheduler\n  namespace: kube-system\nspec:\n  selector:\n    matchLabels:\n      component: scheduler\n      tier: control-plane\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        component: scheduler\n        tier: control-plane\n        version: second\n    spec:\n      affinity:\n        nodeAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n            nodeSelectorTerms:\n            - matchExpressions:\n              - key: karpenter.sh/nodepool\n                operator: DoesNotExist\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - labelSelector:\n              matchLabels:\n                component: scheduler\n                tier: control-plane\n            topologyKey: kubernetes.io/hostname\n      serviceAccountName: my-scheduler\n      containers:\n      - command:\n        - /usr/local/bin/kube-scheduler\n        - --bind-address=0.0.0.0\n        - --config=/etc/kubernetes/my-scheduler/my-scheduler-config.yaml\n        - --v=5\n        image: public.ecr.aws/eks-distro/kubernetes/kube-scheduler:v1.28.11-eks-1-28-latest\n        livenessProbe:\n          httpGet:\n            path: /healthz\n            port: 10259\n            scheme: HTTPS\n          initialDelaySeconds: 15\n        name: kube-second-scheduler\n        readinessProbe:\n          httpGet:\n            path: /healthz\n            port: 10259\n            scheme: HTTPS\n        resources:\n          requests:\n            cpu: '1'\n        securityContext:\n          privileged: false\n        volumeMounts:\n          - name: config-volume\n            mountPath: /etc/kubernetes/my-scheduler\n      hostNetwork: false\n      hostPID: false\n      volumes:\n        - name: config-volume\n          configMap:\n               name: my-scheduler-config\nEOF\n</code></pre>"},{"location":"performance/docs/binpack/#validate-the-custom-scheduler","title":"Validate the Custom Scheduler","text":"<ul> <li>Step1: Launch the node viewer in a terminal:</li> </ul> <pre><code>eks-node-viewer --resources cpu,memory\n</code></pre> <ul> <li>Step 2: Add the custom scheduler to an EMR on EKS job either via a Spark config or via Pod Templates. For exmaple:</li> </ul> <p>sample-job.sh (last line)</p> <pre><code>aws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name $app_name \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-7.2.0-latest \\\n--job-driver '{\n\"sparkSubmitJobDriver\": {\n    \"entryPoint\": \"local:///usr/lib/spark/examples/jars/spark-examples.jar\", \n    \"entryPointArguments\": [\"1000000\"],\n    \"sparkSubmitParameters\": \"--class org.apache.spark.examples.SparkPi --conf spark.executor.instances=10\" }}' \\\n--configuration-overrides '{\n\"applicationConfiguration\": [\n    {\n    \"classification\": \"spark-defaults\", \n    \"properties\": {\n        \"spark.kubernetes.node.selector.provisioner\": \"karpenter-binpack-test\",\n        \"spark.kubernetes.scheduler.name\": \"my-scheduler\" }}]}'\n</code></pre> <p>OR sample-pod-template.yaml (line #3)</p> <pre><code>kind: Pod\nspec:\n  schedulerName: my-scheduler\n  nodeSelector:\n    provisioner: karpenter-binpack-test\n  volumes:\n    # EKS automatically mount EBS or NVMe SSD by\n    # https://github.com/awslabs/amazon-eks-ami/blob/main/templates/al2/runtime/bootstrap.sh \n    - name: spark-local-dir-1\n      emptyDir: {}\n  containers:\n  - name: spark-kubernetes-executor\n    volumeMounts:\n      - name: spark-local-dir-1\n        mountPath: /data1\n        readOnly: false    \n</code></pre> <p>Step3: Monitor via eks-node-viewer </p> <p>-Before apply the change in pod template:- </p> <p>-After the change:-</p> <ul> <li>Higher resource usage per node at pod scheduling time</li> <li>Over 50% of cost reduction since Karpenter was terminating idle EC2 nodes at the same time\u00a0 </li> </ul> <p>Consideration:</p> <ol> <li>At pod launch, the custom scheduler can optimize resource utilization by fitting as many pods as possible onto a single EC2 node. This approach minimizes pod distribution across multiple nodes, leading to higher resource utilization and improved cost efficiency.</li> <li>Dynamic Resource Allocation (DRA) requires shuffle tracking to be enabled because Spark on Kubernetes does not yet support an external shuffle service. Consequently, we have observed that idle EC2 nodes sometimes fail to scale down due to the shuffle data tracking requirement. Using a Binpack scheduler can help reduce the likelihood of long-running idle nodes with leftover shuffle data, resulting a better DRA outcome.</li> <li>Karpenter\u2019s consolidation policy remains essential for reducing underutilized or empty nodes. This is particularly beneficial for long-running jobs where pods are scattered across underutilized EC2 nodes.</li> <li>After implementing a custom scheduler for binpacking, it's recommended to adjust the consolidation frequency to be less aggressive.</li> </ol>"},{"location":"performance/docs/dra/","title":"Dynamic Resource Allocation","text":"<p>DRA is available in Spark 3 (EMR 6.x) without the need for an external shuffle service. Spark on Kubernetes doesn't support external shuffle service as of spark 3.1, but DRA can be achieved by enabling shuffle tracking.</p> <p>Spark DRA without external shuffle service: With DRA, the spark driver spawns the initial number of executors and then scales up the number until the specified maximum number of executors is met to process the pending tasks. Idle executors are terminated when there are no pending tasks, the executor idle time exceeds the idle timeout(<code>spark.dynamicAllocation.executorIdleTimeout)</code>and it doesn't have any cached or shuffle data.</p> <p>If the executor idle threshold is reached and it has cached data, then it has to exceed the cache data idle timeout(<code>spark.dynamicAllocation.cachedExecutorIdleTimeout)</code> and if the executor doesn't have shuffle data, then the idle executor is terminated.</p> <p>If the executor idle threshold is reached and it has shuffle data, then without external shuffle service the executor will never be terminated. These executors will be terminated when the job is completed. This behavior is enforced by <code>\"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\" and \"spark.dynamicAllocation.enabled\":\"true\"</code></p> <p>If <code>\"spark.dynamicAllocation.shuffleTracking.enabled\":\"false\"and \"spark.dynamicAllocation.enabled\":\"true\"</code> then the spark application will error out since external shuffle service is not available.</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-dra.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-dra\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"true\",\n          \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\",\n          \"spark.dynamicAllocation.minExecutors\":\"5\",\n          \"spark.dynamicAllocation.maxExecutors\":\"100\",\n          \"spark.dynamicAllocation.initialExecutors\":\"10\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n</code></pre> <pre><code>aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dra.json\n</code></pre> <p>Observed Behavior: When the job gets started, the driver pod gets created and 10 executors are initially created. (<code>\"spark.dynamicAllocation.initialExecutors\":\"10\"</code>) Then the number of executors can scale up to a maximum of 100 (<code>\"spark.dynamicAllocation.maxExecutors\":\"100\"</code>).  Configurations to note: </p> <p><code>spark.dynamicAllocation.shuffleTracking.enabled</code> - <code>**</code>Experimental<code>**</code>. Enables shuffle file tracking for executors, which allows dynamic allocation without the need for an external shuffle service. This option will try to keep alive executors that are storing shuffle data for active jobs.</p> <p><code>spark.dynamicAllocation.shuffleTracking.timeout</code> - When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle data. The default value means that Spark will rely on the shuffles being garbage collected to be able to release executors. If for some reason garbage collection is not cleaning up shuffles quickly enough, this option can be used to control when to time out executors even when they are storing shuffle data.</p>"},{"location":"scalability/docs/graphana-dashboard/","title":"Grafana Dashbaords","text":"<ul> <li>Spark Operator Dashboard Template</li> </ul> <ul> <li>EKS Control Plane &amp; Etcd DB monitoring</li> </ul> <ul> <li>CNI usage dashbaord</li> </ul> <ul> <li>EMR on EKS Job dashbaord</li> </ul>"},{"location":"scalability/docs/known-factors-spark-operator/","title":"Known factors that impact EMR on EKS Spark Operator submission rate","text":"Category Impact Spark Operator Numbers For the single spark operator, the max performance for submission rate would be around 30 jobs per min, and the performance tune on a single operator is very limited in the current version. Thus, to handle the large volume of workload, to horizontally scale up, with multiple Spark Operator would be the best solution. The operators will be not impacted from each other on eks cluster side, but higher number of operators will increase the overhead on apiserver/etcd side. Spark Operator's controllerThreads controllerThreads is also named as \"workers\", which controls the number of concurrent threads used to process Spark application requests. Increasing this value can increase the performance of spark operator to handle the requests. Binpacking Binpacking could efficiently allocate pods to available nodes within a Kubernetes cluster. Its primary goal is to optimize resource utilization by packing pods as tightly as possible onto nodes, while still meeting resource requirements and constraints. This approach aims to maximize cluster efficiency, reduce costs, and improve overall performance by minimizing the number of active nodes required to run the workload. With Binpacking enabled, the overall workload can minimise the resources used on network traffic between phsical nodes, as most of pods will be allocated in a single node at its launch time. However, we use Karpenter's consolidation feature to maximize pods tensity when node's utilization starts to drop. Spark Operator timeToLiveSeconds TimeToLiveSeconds defines the Time-To-Live (TTL) duration in seconds for this SparkApplication after its termination. The SparkApplication object will be garbage collected if the current time is more than the TimeToLiveSeconds since its termination. Spark Job Run Time Experimental observations indicate that Spark Operator performs better with longer-running jobs compared to shorter ones. This is likely due to the Operator's internal workqueue mechanism for managing job submissions and completions. The Spark Operator uses watchers to monitor SparkApplication status changes in the EKS cluster. Each status change triggers a task in the Operator's workqueue. Consequently, shorter jobs cause more frequent status changes, resulting in higher workqueue activity. This design suggests that a higher frequency of short-running jobs may impose greater processing overhead on the Spark Operator compared to fewer, longer-running jobs, even with equivalent total computation time. Understanding this behavior is important for optimizing Spark job scheduling in environments with varying job durations. Number of executors in EKS Spark Operator The higher number of executors (10 vs 2) per single EMR on EKS job, number of objects created on EKS cluster grow such as pods, config maps, events etc. This becomes a limiting factor for querying etcd database eventually causing EKS cluster performance degradation. Spark Job Config - InitContainers initContainer has a big impacted on the both Spark Operator and API server / etcd side. As with this setting enbaled, which will creat more events than jobs without this enabled. To utilize more Spark Operators for the job needs this set up, but for etcd size, it still be a bottleneck when the workload is large. EKS Spark Operator submission Rate The EMR on EKS job submission rate will dictate the load placed on the API Server. A larger EMR EKS job submission rate can cause the more k8s objects in etcd db, increasing etcd db size, increased etcd request and api server request latency, and lower EMR job submission throughput. EMR Image pull policy Default Image pull policy for job submitter, driver, and executor pods is set as Always. This adds latency in pod creation times. Unless specifically required for customer usecase, we can set Image pull policy to <code>IfNotPresent</code> resulting in lesser pod creation times. EKS K8s control plane scaling EKS will autoscale the K8s control plane including API server and etcd db instances for customer's EKS cluster based on resource consumption. To be able to successfully run larger amounts of concurrent EMR on EKS jobs on EKS the API Server needs to be scaled up to handle the extra load. However if factors like webhook latency impact the metrics needed by the EKS API Server autoscaler are inhibited this can lead to not properly scaling up. This will impact the health of the API Server and etcd db and lead to a lower throughput on successfully completed jobs. EKS etcd db size As you submit more concurrent running EMR on EKS jobs, the number of k8s objects stored in etcd db grow and in turn increase etcd db size as well. Increased etcd db size causes lantecy in some api server requests requiring cluster-wide/namespace-wide etcd read calls and will reduce EMR job submission throughput. Upper bound on etcd db size is 8GB as specified by EKS and reaching this capacity can make EKS cluster in read-only mode. Customers should monitor and keep their etcd db size within limits. We recommend keeping it below 7GB. In addition, as Spark Operator does not store the metadata of all the running jobs, so if there is any unhealthy or crash happened in etcd/API server, then could cause some job failed or running state lost with Spark Operator. EKS VPC Subnets IP pool Available IP addresses in VPC subnets that are configured for EKS cluster also impact the EMR on EKS job throughput. Each pod needs to be assigned an IP address, thus it is essential to have large enough IP address pool available in VPC subnets of the EKS cluster to achieve higher pod concurrency. Exhaustion of IP adresses causes new pod creation requests to fail. EKS Cluster version EKS has made improvements to cluster versions higher than 1.28 resulting in higher job throughput for EMR on EKS jobs. These recommendations are based on using EKS cluster version 1.30. Pod template size Having high pod template sizes, for example from a high number of sidecar containers, init containers, or numerous environment variables, results in increased usage of the etcd database. This increased usage can potentially limit the number of pods that can be stored in etcd and may impact the cluster's overall performance, including the rate at which EMR jobs can be submitted."},{"location":"scalability/docs/known-factors-start-job-run/","title":"Known factors that impact EMR on EKS submission rate for StartJobRun","text":"Category Impact Mutating Webhook Latency Increased webhook latency leads to an increase in the K8s API Server latency (delay in pod creation for example, if webhook is setup for pod creation). Pod creation latency in turn is propogated to the K8s job controller whose workers are now experiencing delays in creating jobs and leads to growing Job Worker Queue depth. Larger queue depth leads to a lower thoughput in the number of concurrent EMR on EKS jobs EMR on EKS Job driver retries Driver retries create an extra K8s Job object which essentially doubles the amount of K8s Job objects in etcd database. This leads to increased strain in etcd database and also database size to grow faster and hence leads to increase in etcd request latency. This in turn results in a lower throughput in the number of concurrent EMR on EKS jobs. EMR on EKS Job Start Timeout Setting When the K8s job controller work queue depth is larger, that means there could be a delay in the actual Spark driver pod to get created. In the meantime EMR on EKS's control plane by default expects the EMR EKS job driver pod to be created within 15 mins. If the driver is not created within that timeout period, the EMR on EKS control plane will mark the job as failed preemptively. Higher timeout values will ensure the job gets longer time for getting the job scheduled and begin running EMR on EKS Job run time A longer EMR on EKS job run time means that we will essentially have more concurrent active jobs in the EKS cluster. If we keep a consistent job submission rate for long running EMR EKS jobs as compared to a job with a shorter duration we will end up with a larger amount of active concurrent jobs in the EKS cluster. This can lead to more objects in etcd db, increasing etcd db size, increased etcd request latency, and lower EMR job submission throughput. Number of executors in EMR on EKS Job As we define higher number of executors per single EMR on EKS job, number of objects created on EKS cluster grow such as pods, config maps, events etc. This becomes a limiting factor for querying etcd database eventually causing EKS cluster performance degradation. EMR on EK Job submission Rate The EMR on EKS job submission rate will dictate the load placed on the API Server. A larger EMR EKS job submission rate can cause the more k8s objects in etcd db, increasing etcd db size, increased etcd request and api server request latency, and lower EMR job submission throughput. EMR Image pull policy Default Image pull policy for job submitter, driver, and executor pods is set as Always. This adds latency in pod creation times. Unless specifically required for customer usecase, we can set Image pull policy to <code>IfNotPresent</code> resulting in lesser pod creation times. EMR Job type Job concurrency values are different for batch and streaming job types. Streaming jobs usually consume less resources resulting in higher job concurrency values compared to batch jobs. EKS K8s control plane scaling EKS will autoscale the K8s control plane including API server and etcd db instances for customer's EKS cluster based on resource consumption. To be able to successfully run larger amounts of concurrent EMR on EKS jobs on EKS the API Server needs to be scaled up to handle the extra load. However if factors like webhook latency impact the metrics needed by the EKS API Server autoscaler are inhibited this can lead to not properly scaling up. This will impact the health of the API Server and etcd db and lead to a lower throughput on successfully completed jobs. EKS etcd db size As you submit more concurrent running EMR on EKS jobs, the number of k8s objects stored in etcd db grow and in turn increase etcd db size as well. Increased etcd db size causes lantecy in some api server requests requiring cluster-wide/namespace-wide etcd read calls and will reduce EMR job submission throughput. Upper bound on etcd db size is 8GB as specified by EKS and reaching this capacity can make EKS cluster in read-only mode. Customers should monitor and keep their etcd db size within limits. We recommend keeping it below 7GB. EKS VPC Subnets IP pool Available IP addresses in VPC subnets that are configured for EKS cluster also impact the EMR on EKS job throughput. Each pod needs to be assigned an IP address, thus it is essential to have large enough IP address pool available in VPC subnets of the EKS cluster to achieve higher pod concurrency. Exhaustion of IP adresses causes new pod creation requests to fail. EKS Cluster version EKS has made improvements to cluster versions higher than 1.28 resulting in higher job throughput for EMR on EKS jobs. These recommendations are based on using EKS cluster version 1.30. Pod template size Having high pod template sizes, for example from a high number of sidecar containers, init containers, or numerous environment variables, results in increased usage of the etcd database. This increased usage can potentially limit the number of pods that can be stored in etcd and may impact the cluster's overall performance, including the rate at which EMR jobs can be submitted."},{"location":"scalability/docs/load-test-for-spark-operator/","title":"Run Large Scale Jobs by EMR on EKS Spark Operator","text":"<p>This scalability recommendation is focused on EMR on EKS's Spark Operator performance in a large-scale environment. It offers insights derived from extensive benchmarking and testing across various configurations and workloads. The study explores key factors influencing Spark Operator efficiency, including cluster setup, resource allocation, and job submission patterns.</p> <p>Our findings provide a valuable reference for optimizing EMR Spark Operator workloads on Amazon EKS, addressing challenges unique to high-volume, distributed computing environments. The recommendations outlined here aim to help customers achieve a balance between performance, scalability, and resource utilization. By considering these best practices, organizations can enhance their EMR on EKS deployments, ensuring robust and efficient Spark job processing while managing infrastructure costs effectively. This overview serves as a foundation for IT professionals and data engineers seeking to maximize the potential of their Spark applications in cloud-native Kubernetes environments.</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Large Scale Load Benchmark<ul> <li>Benchmark Results</li> <li>Metrics Explanation</li> <li>Notes about the Limitations</li> </ul> </li> <li>Best Practice / Recommendation<ul> <li>1. Spark Operator Numbers</li> <li>2. Instance Sizes</li> <li>3. Spark Operator Configuration</li> <li>4. EKS Cluster Scaler &amp; Scheduler<ul> <li>4.1 Autoscaler</li> <li>4.2 Karpenter</li> <li>4.3 Binpacking Custom Scheduler</li> <li>4.4 Implementing Retry Mechanisms</li> </ul> </li> <li>5. IP Address Utilization &amp; Settings<ul> <li>5.1 With EKS AutoScaler</li> <li>5.2 With Karpenter Node Provisioner</li> </ul> </li> <li>6. Config Maps and initContainers</li> </ul> </li> <li>Appendix<ul> <li>7.1 Artifact Reference</li> </ul> </li> </ol>"},{"location":"scalability/docs/load-test-for-spark-operator/#large-scale-load-benchmark","title":"Large Scale Load Benchmark","text":"<ul> <li>For these benchmark, we tuned following settings for EKS:<ul> <li>EKS cluster version: 1.30</li> <li>SparkOperator version: <code>emr-6.11.0 (v1beta2-1.3.8-3.1.1)</code><ul> <li>The current version of EMR Spark Operator has limited API exposed for users to tune the performance, in this article, we keen to use the below set up for Spark Operators:</li> </ul> </li> <li>Pre-warm the EKS control plane</li> <li>Isolated the Operational services and Spark application pods.<ul> <li><code>controllerThreads=30</code> , Higher operator worker than default 10.</li> <li>To minimise the impacts caused by other services, eg.: spark job pods, prometheus pods, etc, we allocated the Spark Operator(s), Prometheus operators in the dedicated operational node groups accordingly.</li> <li>Please see details for Spark Operator(s) and Spark Job Set up in the following best practice section.</li> </ul> </li> <li>To utilize the cluster resources, we have tested the following techniques and settings.<ul> <li>EKS Autoscaler or Karpenter</li> <li>Binpacking strategy is enabled and accompany with either Autoscaler and Karpenter accordingly. </li> </ul> </li> <li>The cluster resides in a VPC with 6 subnets (2 public subnets and 4 private subnets with S3 endpoint attached):<ul> <li>The 4 private subnets are allocated into 2 AZs evenly.</li> <li>All Node groups are created in the 4 private subnets, and for each NodeGroup, the subnets associated are in the same AZ, e.g: NodeGroup-AZ1, NodeGroup-AZ2.</li> </ul> </li> </ul> </li> <li>The benchmark results are based on the Spark Testing job with spec as below;<ul> <li>Driver: 1 Core, 512mb</li> <li>Executor: 1 Core 512mb each, for 10 executors. <ul> <li>Due to default value of <code>spark.scheduler.minRegisteredResourcesRatio</code> = 0.8, then Spark job will start to run with min of 8 executors are allocated. Ref Document: link</li> </ul> </li> <li>Each Spark Job is expected to run between 12 ~ 16 mins, which does NOT include the spark submission &amp; pod scheduling time consume.</li> <li>Testing Job Script is stored in S3, the code submitted with <code>hadoopConf</code> and <code>sparkConf</code> configmaps.</li> <li>Enabled <code>nodeSelector</code> to ensure the Spark Jobs will be assigned into Worker Node Groups.</li> </ul> </li> </ul>"},{"location":"scalability/docs/load-test-for-spark-operator/#benchmark-results","title":"Benchmark Results","text":""},{"location":"scalability/docs/load-test-for-spark-operator/#metrics-explanation","title":"Metrics Explanation","text":"<ul> <li>Spark Operator Job Submission Rate (per EKS cluster):<ul> <li>The average submitted jobs per minute, eg: Total jobs submitted / Test Time.</li> </ul> </li> <li>Spark Operator Numbers: <ul> <li>The number of spark operators to be used for the test.</li> </ul> </li> <li>Max Number of Active Jobs / Driver Pods:<ul> <li>The max number of Spark Driver pods running concurrently.</li> </ul> </li> <li>Spark Job Running Time<ul> <li>The time spent on the spark job execution, the time is vary due to testing spark job, to pick a random number within the time range, to mimic the real workloads.</li> </ul> </li> <li>Number of Worker Nodes:<ul> <li>The total worker instances created by EKS cluster, Operational Instances exclusive.</li> </ul> </li> <li>Number of Spark jobs :<ul> <li>The total job submitted from Client.</li> </ul> </li> <li>Number of Concurrent pods<ul> <li>The max number of spark job pods (Drivers &amp; Executors) running concurrently during the testing</li> </ul> </li> <li>API Server Request Latency - p99 (for create Pod calls) :<ul> <li>This metric provides the 99th percentile of API server response times for POST requests to create pods in an EKS cluster over the last 5 minutes.</li> </ul> </li> </ul>"},{"location":"scalability/docs/load-test-for-spark-operator/#notes-about-the-limitations","title":"Notes about the Limitations","text":"<ul> <li>Pod template is not available in the current version, this feature has been added into OSS Spark Operator Roadmap. Users can only put the configurations via spark job yaml file at the current stage. </li> <li>With property <code>spark.scheduler.minRegisteredResourcesRatio</code> has default value <code>0.8</code> forKUBERNETES mode, then it would be hard to get the accurate numbers of how many spark jobs are running with sufficient executor pods without the code changes on Spark Operator internally or without Gang Scheduling enabled. Thus, from the benchmark results, for metrics <code>Max Jobs Concurrent Running</code>, we evalute this via how many drivers are running and also the ratio of <code>total_executor_pods_running</code>/<code>total_executor_pods_running</code>, if the ratio is greater than 8, then we collect the <code>Max Driver Pods Concurrent Running</code> as the <code>Max Jobs Concurrent Running</code>.</li> <li>Need to increase the bucket limit and the refill rate for <code>DescribeInstances</code> ,eg: Bucket size 140 and Refill rate 60. Have observed this issue in both CAS and Karpenter as the cluster scaler.</li> <li>There is limited performance tuning parameters are available on Spark Operator, eg: bucketQPS / bucketSize are hardcoded in the current version of Spark Operator</li> <li>The current EMR Spark Operator Version cannot handle, for a single operator to monitor the multiple specified job name spaces. Can only work as one operator one job namespaces or one operator for all namespaces. https://github.com/kubeflow/spark-operator/issues/2052, the limitation has been fixed at OSS V2.</li> </ul>"},{"location":"scalability/docs/load-test-for-spark-operator/#best-practice-recommendation-to-use-spark-operator-on-eks","title":"Best practice / recommendation to use Spark Operator on EKS:","text":""},{"location":"scalability/docs/load-test-for-spark-operator/#1-spark-operator-numbers","title":"1. Spark Operator numbers","text":"<p>The number of Spark Operator has significant impacts on the performance of submitting the jobs from client to eks cluster. Here are the recommendations when using multiple EMR Spark Operators on EKS cluster </p>"},{"location":"scalability/docs/load-test-for-spark-operator/#11-use-multiple-spark-operators-for-high-volume-tasks","title":"1.1 Use Multiple Spark Operators for High-Volume Tasks","text":"<p>For large-scale workload, deploying multiple Spark Operators significantly improves performance. A single operator can handle about 20-30 task submissions per minute. Beyond this, you'll see better results with multiple operators, especially before the submission workload hitting the threshold of eks etcd or api server side.</p> <p>With our testing job set up, for submission rates between 250-270 tasks per minute, there is no significant performance difference between 10 or 15 Spark Operators in overall. However, lower operator number can provide better stability than higher operator number. This setup maintains high performance with minimal task failures (less than 0.1%). </p> <p>Be cautious when exceeding 270 submissions per minute. We've observed increased failure rates regardless of the number of operators in(10, 15, or 20).</p> <p>The number of spark operator may be impacted by the submission rate and also the job configs, e.g.: The Spark job with initContainers enabled, will lead to more events will be submitted to API server from Spark Operators, and then the size of etcd database will be increased more faster than the jobs without initContainers enabled.</p> <pre><code>* For the spark job without initContainers:\n    * Each Spark Operator can submit 20~30 jobs per min in average.\n* For the spark job with initContainers:\n    * Each Spark Operator can submit 12~18 jobs per min in average, which vary in different spark job configs.\n</code></pre>"},{"location":"scalability/docs/load-test-for-spark-operator/#12-balancing-operator-numbers-for-long-running-tests","title":"1.2 Balancing Operator Numbers for Long-Running Tests","text":"<p>For extended operations (e.g., 200-minute tests), slightly fewer operators could be beneficial. This is represented by the API request latency, which shows a slight increase with more operators, from the Spark Operator to the API server. This could be due to 10 operators placing less strain on the API server and etcd while maintaining good performance compared to 15 operators. We observed that the situation worsens further with 20 operators.</p> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#13-do-not-use-too-small-operators-for-large-volume-of-workload","title":"1.3 Do not use too small Operators for large volume of workload.","text":"<p>Please aware, if the number of Spark Operators are too small for large workload, e.g.: 5 Operator for 250 min submission rate could cause the Spark Operator throttling internally. </p> <p>The symptoms of Spark Operator throttling could be either or both:</p> <pre><code>*  The number of Jobs in `New` State (also known as `Null` State) or the number of Jobs in `Succeeding` are keep increasing, but the number of jobs in `Submitted` state is reducing.\n* In addition, you may also see the Spark Operator metrics API provides the wrong data, e.g.: The running application number is much less than the number of running Driver Pods.\n</code></pre>"},{"location":"scalability/docs/load-test-for-spark-operator/#14-system-health-considerations","title":"1.4 System Health Considerations","text":"<p>Based on the given testing job, to keep submission rates below 250 tasks per minute for optimal system health. Please aware, the number of 250/min submission rate is a reference, as it could be impacted by other factors, such as spark job config maps, the size of pods settings, etc. Please monitor etcd size closely, especially during high-volume operations. We've seen it exceed 7.4GB, risking going over the 8GB mark despite EKS's automatic compaction.</p> <p>Please note, these recommendations are based on our specific test environment - your optimal settings may vary slightly based on your unique infrastructure and workload characteristics.</p> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#15-formula-to-determine-the-number-of-operators","title":"1.5 Formula to determine  the number of Operators :","text":"<p>The number of EKS cluster required for Spark Job is not relating to how many operators, as if set the right number of the operators, then the bottleneck will be on API Server &amp; etcd DB size. Please see the below formula as a reference to determine how many eks cluster needed for workload.</p> <ul> <li>Job Submission Rate (submission_rate) = Average number of jobs submitted per minute</li> <li>Average Job Duration (avg_job_runtime) = Average job runtime in minutes</li> <li>Pods per Job (avg_pods_per_job) = Average number of pods per job</li> <li>Max Concurrent Pods (max_concur_pods) = Maximum number of pods that can run concurrently in the cluster</li> </ul> <p>Formula</p> <pre><code>Est_cluster_numbers = (submission_rate * avg_job_runtime * avg_pods_per_job) \n                        / (max_concur_pods * (1 - buffer_ratio))\n</code></pre> <ul> <li><code>buffer_ratio</code> is recommended to decide the number of eks cluster to use. eg: <code>buffer_ratio</code> = 0.1, to ensure the cluster can reserve 10% of buffer for apiserver &amp; etcd DB to handle workloads, instead of hit the benchmark results.</li> <li><code>Est_cluster_numbers</code>, the number of eks clusters needed is vary in the pod sizes of spark jobs, the formula above is a starting point to have a roughly understanding.</li> </ul> <p>Please aware, this formula applies on the eks cluster environment as EMR Spark Operator on EKS Benchmark Utility suggested. And all recommendation suggested in this article has been implemented.</p> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#2-instance-sizes","title":"2. Instance Sizes","text":"<p>Based on the testing benchmark results with the instance types as below:</p> <pre><code>- m5.8xlarge  &amp; r5.8xlarge\n- m5.16xlarge\n- m5.24xlarge &amp; c5.metal\n</code></pre> <p>The experiment data reveals that medium-sized EC2 instances demonstrate more consistent and favorable performance in this Spark cluster configuration:</p> <ol> <li>These instances maintain a more stable Driver/Total Pods ratio, typically below 12.6%.</li> <li>They show consistent performance across key metrics such as submission rates, job concurrency, and latency.</li> </ol> <p>Compared to larger instance types, medium-sized instances exhibit a better balance of efficiency and stability in this specific setup, suggesting they are well-suited for the current cluster configuration.</p> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#3-spark-operator-configuration-best-practice","title":"3. Spark Operator Configuration best practice:","text":""},{"location":"scalability/docs/load-test-for-spark-operator/#31-to-isolate-the-operational-services-and-spark-application-pods","title":"3.1 To Isolate the Operational services and Spark application pods","text":"<p>It is recommended to run the operational services onto the dedicate NodeGroups from both performance and operational consideration.</p> <ul> <li> <p>To minimise the impacts caused by other services, e.g.: spark job pods, prometheus pods, etc, we allocated the Spark Operator(s), Prometheus operators in the dedicated operational node groups accordingly.</p> <ul> <li>Operational NodeGroup for Spark Operator, we use <code>r5.4xlarge</code> for each spark Operator.</li> <li>Operational NodeGroup (<code>r5.8xlarge</code> ) for Monitoring tools, Binpackking, Karpenter (if applied).</li> </ul> </li> <li> <p>To use <code>podAntiAffinity</code> to ensure the multiple Spark Operations will <code>NOT</code> to be allocated in the same operational node:</p> </li> </ul> <pre><code>nodeSelector:\ncluster-worker: \"true\" \n## this label is managed on EKS Nodegroup side.\n## To define the nodeSelector label for Spark Operator pods,\n## Ensure all operators will be running on the operational Nodegroup.\n\n\n## Use pod affinity:\n## to ensure only one Spark Operator will be running on one Operational Node\naffinity:\n  podAntiAffinity:\n    requiredDuringSchedulingIgnoredDuringExecution:\n    - labelSelector:\n        matchExpressions:\n        - key: app.kubernetes.io/name\n          operator: Exists\n      topologyKey: \"kubernetes.io/hostname\"\nwebhook:\n  enable: true\n  nodeSelector:\n## To define the nodeSelector label for Spark Operator pods,\n## Ensure all operators will be running on the operational Nodegroup.\n</code></pre> <p>Please aware, for other operational service like prometheus, Binpacking, Node Scaler (CAS), Karpenter, etc. We use the same approach as above to ensure the operational services will be running in the Operational Node group(s) only.</p> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#32-to-set-up-controllerthreads-with-higher-number","title":"3.2 To set up <code>controllerThreads</code> with higher number","text":"<p>The default value of Spark Operator Worker number (<code>controllerThreads</code>) is 10, to increase it from 10 would increase performance.</p> <pre><code># For workers of spark operator,\n# we found out the 30 seems can provide the better performance.\n# It would be vary in different spark jobmission object size.\n# We have also tested very large numbers, eg: 50/100, etc.\n# But it was not helpful for Operator performance, as the bucketSize and # qps was hard coded. Thus, with higher workers does not help on the performance.\n\ncontrollerThreads: 30\n</code></pre> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#33-for-spark-job-drivers-and-executor-pods","title":"3.3 For spark job drivers and executor pods:","text":"<p>Similar as operational pods, utilzing <code>nodeSelector</code> with label feature, to ensure the spark job pods will be allocated to worker NodeGroup or Karpenter nodepools.</p> <pre><code>    driver:\n      nodeSelector:\n      cluster-worker: \"true\" \n## This label needs to match with EKS nodegroup kubernetes label or kapenter nodepool\n\n    executor:\n      nodeSelector:\n      cluster-worker: \"true\" \n## This label needs to match with EKS nodegroup kubernetes label or kapenter nodepool\n</code></pre>"},{"location":"scalability/docs/load-test-for-spark-operator/#34-implementing-retry-mechanisms","title":"3.4 Implementing Retry Mechanisms","text":"<p>Set up retry configurations to handle the small percentage of task failures that may occur. Different from EKS StartJobRun API, in spark operator, setting up retry does not impact the overall performance from the load testing. </p> <p>As a reference, we have below configs for test job:</p> <pre><code>  hadoopConf:\n    # EMRFS filesystem\n    fs.s3.customAWSCredentialsProvider: com.amazonaws.auth.WebIdentityTokenCredentialsProvider\n    fs.s3.impl: com.amazon.ws.emr.hadoop.fs.EmrFileSystem\n    fs.AbstractFileSystem.s3.impl: org.apache.hadoop.fs.s3.EMRFSDelegate\n    fs.s3.buffer.dir: /mnt/s3\n    fs.s3.getObject.initialSocketTimeoutMilliseconds: \"2000\"\n    mapreduce.fileoutputcommitter.algorithm.version.emr_internal_use_only.EmrFileSystem: \"2\"\n    mapreduce.fileoutputcommitter.cleanup-failures.ignored.emr_internal_use_only.EmrFileSystem: \"true\"\n  sparkConf:\n    spark.executor.heartbeatInterval: 3000s\n    spark.scheduler.maxRegisteredResourcesWaitingTime: 40s\n    spark.network.timeout: 120000s\n    # Required for EMR Runtime\n    spark.driver.extraClassPath: /usr/lib/hadoop-lzo/lib/*:/usr/lib/hadoop/hadoop-aws.jar:/usr/share/aws/aws-java-sdk/*:/usr/share/aws/emr/emrfs/conf:/usr/share/aws/emr/emrfs/lib/*:/usr/share/aws/emr/emrfs/auxlib/*:/usr/share/aws/emr/security/conf:/usr/share/aws/emr/security/lib/*:/usr/share/aws/hmclient/lib/aws-glue-datacatalog-spark-client.jar:/usr/share/java/Hive-JSON-Serde/hive-openx-serde.jar:/usr/share/aws/sagemaker-spark-sdk/lib/sagemaker-spark-sdk.jar:/home/hadoop/extrajars/*\n    spark.driver.extraLibraryPath: /usr/lib/hadoop/lib/native:/usr/lib/hadoop-lzo/lib/native:/docker/usr/lib/hadoop/lib/native:/docker/usr/lib/hadoop-lzo/lib/native\n    spark.executor.extraClassPath: /usr/lib/hadoop-lzo/lib/*:/usr/lib/hadoop/hadoop-aws.jar:/usr/share/aws/aws-java-sdk/*:/usr/share/aws/emr/emrfs/conf:/usr/share/aws/emr/emrfs/lib/*:/usr/share/aws/emr/emrfs/auxlib/*:/usr/share/aws/emr/security/conf:/usr/share/aws/emr/security/lib/*:/usr/share/aws/hmclient/lib/aws-glue-datacatalog-spark-client.jar:/usr/share/java/Hive-JSON-Serde/hive-openx-serde.jar:/usr/share/aws/sagemaker-spark-sdk/lib/sagemaker-spark-sdk.jar:/home/hadoop/extrajars/*\n    spark.executor.extraLibraryPath: /usr/lib/hadoop/lib/native:/usr/lib/hadoop-lzo/lib/native:/docker/usr/lib/hadoop/lib/native:/docker/usr/lib/hadoop-lzo/lib/native\n</code></pre> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#4-eks-cluster-scaler-scheduler-set-up","title":"4. EKS cluster scaler &amp; scheduler set up","text":""},{"location":"scalability/docs/load-test-for-spark-operator/#41-autoscaler","title":"4.1 Autoscaler","text":"<p>With Autoscaler, we\u2019ve tested on the following worker node instances types, mixture the below patterns to avoid the EC2 capacity issue. The benchmark in this article is mainly focused on the CPU utilization, but not memory utilization on the worker instances.</p> <pre><code>* m5.8xlarge &amp; r5.8xlarge, each instance has 32 Cores.\n* m5.16xlarge, each instance has 64 Cores.\n* m5.24xlarge &amp; c5.metal, each instance has 96 Cores.\n</code></pre> <p>To minimise the impacts of job running slowness which may be caused due to the pods of one job are allocated into multiple nodes, or crossing AZs. </p> <pre><code>* Set up the kubernetes label on the node groups in different AZs, and then to ensure the `nodeSelector` for both the drivers and executors to be specified in the Spark Job yaml file. By doing this set up, the pods of a single job will be allocated into the same NodeGroup (e.g.: NodeGroup-AZ1), instead of the pods to be allocated into 2 or more AZs.\n* Set up `Binpacking Custom Scheduler ` to prevent pods from being spread out. Please check the `Bindpacking` scheduler part from below for details.\n</code></pre> <p>To schedule the large volume of pods, need to increase the qps and burst for <code>NodeScaler</code>.</p> <pre><code>nodeSelector:\n ## Kubernetes label for pod allocation.\npodAnnotations:\n  cluster-autoscaler.kubernetes.io/safe-to-evict: 'false'\n...\nextraArgs:\n...\n  kube-client-qps: 300\n  kube-client-burst: 400\n</code></pre> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#42-karpenter","title":"4.2 Karpenter","text":"<p>With Karpenter cluster, we have the setting up as below:</p> <pre><code>* To allocate the operational pods, e.g.: Spark Operator, Prometheus, Karpenter, Binpacking, etc in the Operational EKS NodeGroup, which not controlled by Karpenter via setting up `nodeSelector` on the operational pods.\n* Karpenter Nodepool configs:\n    * Utilize the `provisioner` label to separate the spark driver pods and spark executor pods. As the driver pods will be creating earlier than executor pods, and then each driver pod will create 10 executors, which can improve the pending pods in short period of time.\n    * To align with NodeGroup on CAS, and also minimise the networking level noisy, to utilize the `topology.kubernetes.io/zone` when submitting karpenter spark jobs, to ensure all pods of a single job will be allocated into the same AZ.\n* We\u2019ve testing the below instance pattens:\n    * Instance family: m5, c5, r5\n    * Instance size: 12xlarge, 16xlarge, 24xlarge, metal.\n    * In terms of IP related configuration, please see below `IP address utilisation &amp; settings`  \u2192 `With Karpenter Scaler `\n</code></pre> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#43-binpacking-custom-scheduler","title":"4.3 Binpacking Custom Scheduler","text":"<p>Setting up Binpacking will very helpful on the job execution especially beneficial on the pod allocation.</p> <pre><code>* We use the default `MostAllocated strategy` for Binpacking, has the below settings:\n</code></pre> <pre><code>                scoringStrategy:\n                  resources:\n                      - name: cpu\n                        weight: 1\n                      - name: memory\n                        weight: 1\n                  type: MostAllocated\n</code></pre> <pre><code>* The `MostAllocated` strategy scores the nodes based on the utilization of resources, favoring the ones with higher allocation.\n* Binpacking Custom Scheduler is enabled and accompany with either Autoscaler or Karpenter accordingly. Please learn more about the Scheduler via [link](https://aws.github.io/aws-emr-containers-best-practices/performance/docs/binpack/).\n* When running the large volume of test, which may cause Binpacking throttling. To solve this issue, can increase the rate as below when install the Binpacking scheduler:\n</code></pre> <pre><code>    apiVersion: kubescheduler.config.k8s.io/v1\n    kind: KubeSchedulerConfiguration\n    profiles:\n    ....\n    clientConnection:\n      burst: 400\n      qps: 300\n</code></pre> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#5-ip-address-utilisation-settings","title":"5. IP address utilisation &amp; settings:","text":""},{"location":"scalability/docs/load-test-for-spark-operator/#51-with-eks-autoscaluer","title":"5.1 With EKS AutoScaluer:","text":"<p>When to use the worker instance type: <code>m5.24xlarge</code> and <code>c5.metal</code> which both have the 96 Cores and 50 IP address per ENI and 15 max ENIs. If to leave the following default settings unchanged: </p> <ul> <li><code>WARM_ENI_TARGET=1</code></li> <li><code>WARM_IP_TARGET=None</code></li> <li><code>MINIMUM_IP_TARGET=None</code></li> </ul> <p>If a single worker node only utilizes 50~100 IP address, then the node will reserve 150 IPs from the Subnet, and over 50 IP addresses will be wasted.</p> <p>Best Practice: If we know the maximum number of IPs needed for each worker node, it is recommended to set the <code>MINIMUM_IP_TARGET</code> equal to the \u201cmaximum number of IPs\u201d, to set <code>WARM_IP_TARGET</code> to 1~5 as a buffer.  Please note, you should alway keep <code>MINIMUM_IP_TARGET</code> + <code>WARM_IP_TARGET</code> &lt;= IP-address-per-ENI-number * integer, e.g.:</p> <pre><code>kubectl set env daemonset aws-node -n kube-system WARM_IP_TARGET=5\nkubectl set env daemonset aws-node -n kube-system MINIMUM_IP_TARGET=95\n</code></pre> <ul> <li><code>MINIMUM_IP_TARGET</code> will ensure for each instances of the eks cluster will reserve the number of the IP addresses while the node is ready to use by Kubernetes.</li> <li><code>WARM_IP_TARGET</code> will ensure the number of IP address specified is hot standby in a warm IP pool, and if any of the IP to be allocated to a Pod, then the pool will refill the IPs from Subnet to ensure the warm IP pool.</li> <li>Please check our document for the Best Practice of the Targets for your own EKS workload.</li> <li>To find out the default IP address and ENI number of ec2 instances, please check document: Maximum IP addresses per network interface.</li> </ul> <p>The reason for setting <code>MINIMUM_IP_TARGET</code> to a large number, e.g.: equal to the \u201cmaximum IP usage per node\u201d is to prevent/minimize the API calls to the EC2 service for getting IP addresses, as it may cause API throttling and impact performance. </p> <p>However, please note, it may not be the ideal solution for using Karpenter as the EKS Scaler, especially the Instance types of Karpenter NodePool are including small and large sizes, eg: The NodePool has 16 Cores and 96 Cores. If you are setting the both Targets as above, 95+5, which means for 16 Cores instance that created by Karpenter will also take 100 IPs. Please check Best Practice in Karpenter part.</p> <p>It is recommended to run a small load test with fewer nodes and concurrent jobs using default settings to get a clear picture of how the pods/IP usage will be on a node. Then, set up the <code>MINIMUM_IP_TARGET</code> and <code>WARM_IP_TARGET</code> accordingly.</p> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#52-with-karpenter-node-provisioner","title":"5.2 With Karpenter Node Provisioner:","text":"<p>With Karpenter eks cluster, it is recommend to follow one of the following options:</p> <ul> <li>Least IP wastage but limited on the instances Cores strategy. </li> </ul> <p>To select the instance types and sizes in the karpenter nodepools, with the same/close number of Cores.</p> <pre><code>* e.g.: Using `m5.16xlarge` and `r5.16xlarge` for the karpenter nodepools, as both of them have 64 Cores, and with the `1-Core-1-pod-1-IP` pattern of the spark job sepc, the max number of IP usage per node should be around 64, to leave some buffer we can set up the IP targets as below (_*please aware, for each node, it may be a few operational pods may or may not consume IP, it\u2019s vary in the different eks addons setting*_):\n</code></pre> <pre><code>kubectl set env daemonset aws-node -n kube-system WARM_IP_TARGET=3\nkubectl set env daemonset aws-node -n kube-system MINIMUM_IP_TARGET=65\n</code></pre> <ul> <li>Balanced in Cores and IP per ENI strategy, with more bundle of instance types and sized, may waste IPs slightly:</li> </ul> <p>To select the instance types and sizes, which the Cores of the instance are multiple of it\u2019s IP per ENI:</p> <pre><code>* e.g.: Using `m5.24xlarge` and `m5.12xlarge`, \n    * `m5.24xlarge`: 96 Cores with 50 IP per ENI.\n    * `m5.12xlarge`: 48 Cores with 30 IP per ENI.\n    * In this bundle, we can unset the both IP targets, but enable `MAX_ENI` = 2:\n</code></pre> <pre><code>kubectl set env daemonset aws-node -n kube-system WARM_IP_TARGET-\nkubectl set env daemonset aws-node -n kube-system MINIMUM_IP_TARGET-\n\nkubectl set env daemonset aws-node -n kube-system MAX_ENI=2\n</code></pre> <pre><code>* With this setting, for each instances of the nodepool:\n    * `m5.24xlarge` will reserve 100 IPs when the node is ready, which includes the 50 IPs from one active ENI and 50 IPs from one WARM_ENI pool. The maximum IPs to be consumed by the node will be 100, as we have set the 2 as the `MAX_ENI` . \n    * `m5.12xlarge` will reserve 60 IPs when the node is ready, which includes the 30 IPs from one active ENI and 30 IPs from one WARM_ENI pool. The maximum IPs to be consumed by the node will be 60, as we have set the 2 as the `MAX_ENI` . \n    * Thus, almost no IP wastage on the `m5.24xlarge` instance, as It will run up to 99 pods. For `m5.12xlarge` instances with up to 50 pods running, there is up to 10 IPs will be wasted.\n* For the this balanced strategy, if to select `m5.16xlarge` as the candidate of the nodepool instance:\n    * `m5.16xlarge` will reserve 100 IPs, however, as only 64 Cores available to use and up to 67 pods are running, then it will waste over 30 IPs for each instance.\n</code></pre> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#6-minimise-the-config-maps-and-initcontainers-spec","title":"6. Minimise the Config Maps and initContainers spec","text":"<p>When using Spark Operator on EKS, excessive use of <code>[initContainers](https://github.com/kubeflow/spark-operator/blob/f56ba30d5c36feeaaba5c89ddd48a3f663060f0d/docs/api-docs.md?plain=1#L3118)</code> and large sparkConf/hadoopConf configurations can increase API server events and pod object sizes, potentially impacting etcd performance. </p> <p>To optimize this situation, please try:</p> <ul> <li>To utilize other solutions to replace the <code>initContainers</code> when running the large volume workloads. e.g.: To mount disk in EKS cluster level when creating a new eks or updating the running eks.</li> <li>Minimize ConfigMap quantity and size, include only essential sparkConf/hadoopConf settings.</li> </ul> <p>^ back to top</p>"},{"location":"scalability/docs/load-test-for-spark-operator/#7-appendix","title":"7. Appendix","text":""},{"location":"scalability/docs/load-test-for-spark-operator/#71-artifact-reference","title":"7.1 Artifact Reference","text":"<ul> <li>Load Test Set up Guide for EMR on EKS</li> <li>Grafana &amp; Prometheus Dashboard for monitoring</li> </ul>"},{"location":"scalability/docs/load-test-for-start-job-run-api/","title":"EMR EKS Scale Recommendations for Large customers","text":"<p>This recommendation is to be used by EMR on EKS customers to meet their high workload demands for their EMR on EKS migration. This includes recommendations for cluster farm sizing, EKS pod concurrency and EMR on EKS throughput. EMR on EKS job submission rate is defined at the maximum number of EMR on EKS jobs submitted per minute to a single EKS cluster. EMR on EKS job submission rate is defined at a cluster level and impacted by several factors including infrastructure, control plane, and data plane components.</p> <p>These recommendations are only guidelines, we recommend monitoring cluster activity to determine whether additional clusters or additional workload split across clusters is required. Lastly, both AWS EMR and EKS teams are constantly making improvements to support higher throughput. Customers can use these recommendations to continue onboarding their workloads to EMR on EKS. </p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#large-scale-load-benchmark","title":"Large Scale Load Benchmark","text":"<ul> <li>For these benchmark, we tuned following settings for EKS:<ul> <li>EKS cluster version: 1.30</li> <li>Pre-warm the EKS control plane</li> <li><code>vpc-cni</code> add-on settings:<ul> <li><code>livenessProbeTimeoutSeconds</code> : 60 seconds</li> <li><code>readinessProbeTimeoutSeconds</code> : 60 seconds</li> <li><code>WARM_IP_TARGET</code> : 10</li> <li><code>AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG</code> : true with custom ENIConfigs (each AZ having custom subnet of 65536 IP addresses pool for pods)</li> </ul> </li> </ul> </li> <li>Note that max number of active EMR on EKS jobs corresponds to maximum concurrently active jobs that have been submitted to the EKS cluster, and are not yet completed.</li> <li>Batch jobs were run with 10 executors </li> <li>We used default pod spec for our EMR jobs</li> <li>The streaming jobs scenario were tested by first submitting all streaming jobs before running the batch jobs</li> <li>The streaming jobs were tested with constant 3 executors</li> </ul>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#benchmark-results","title":"Benchmark Results","text":"<p>The benchmark results show the different configurations we ran with to mimic customer workloads, achieving a near 100% job completion rate for EMR on EKS. The factors we tuned were the following:</p> <ul> <li>EMR on EKS Job submission rate</li> <li>Spark Job Driver retries configuration</li> <li>Mutating Webhook latency</li> <li>Duration of the EMR on EKS job run time</li> <li>Total runtime for the test</li> <li>Image pull policy</li> </ul> <p>There are also some other factors that will affect the EMR job submission throughput that we didn\u2019t tune and used their default settings:</p> <ul> <li>Pod spec (the number of containers per pod)</li> </ul> <p>Based on these factors if we examine our results below we notice the following trends:</p> <ul> <li>If we enable retries on the Spark driver, we have to subsequently reduce the EMR on EKS job submission rate as adding retries also creates more K8s job objects and hence cause an increase in etcd database size and etcd requests latency due to higher number of database objects - increasing overall strain to etcd database.</li> <li>Mutating Webhook latency directly impacts Kubernetes API server latencies and the scalability of EKS control plane, increasing the webhook latency leads to backpressure propagated to and leads to delays in running the EMR on EKS job. </li> <li><code>vpc-cni</code> add-on becomes a bottleneck during high CPU utilization. This may result in job failures due to network timeouts. <ul> <li>Issue 1: <code>vpc-cni</code> experiences liveness/readiness probe failures due to high node CPU utilization. When these probes fail the nodes are marked as <code>NotReady</code> which can cause jobs to be re-scheduled on another node and fail. The settings for these we recommend to update are <code>livenessProbeTimeoutSeconds</code> and <code>readinessProbeTimeoutSeconds.</code></li> <li>Issue 2: <code>vpc-cni</code> by default maintains a pool of IP addresses for 1 ENI. For x24large this is 50 IP addresses, when these IP addresses are all used <code>vpc-cni</code> will request a 2nd ENI to be attached, this can cause some immediate issues with running out of IP addresses locally on the Node. The setting that we recommend to update to maintain a warm IP pool is <code>WARM_IP_TARGET.</code> This will instruct <code>vpc-cni</code> to always have a fixed number of IP\u2019s as available. <code>vpc-cni</code> will automatically request new ENI to maintain a constant pool of <code>WARM_IP_TARGET</code></li> <li>Issue 3: <code>vpc-cni</code> by default assigns IP addresses to pods from the subnet of the node. The number of IP addresses available in the node\u2019s subnet becomes bottleneck if this number is not large enough, causing pod creation to start failing. We can change the behavior of <code>vpc-cni</code> to specify a subnet to be used to assign IP addresses to pods. This behavior can be enabled by creating custom ENIConfig in the cluster and then setting <code>AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG</code> variable. You can follow Steps 2 and 3 in this EKS doc for detailed instructions on enabling custom networking for pods. After that, you will need to recreate node-groups in EKS cluster for those changes to take effect.</li> <li>Reference: https://aws.github.io/aws-eks-best-practices/networking/vpc-cni/</li> </ul> </li> <li>The bottleneck in increasing the job submission rate is usually etcd db size and the number of objects in etcd db. <ul> <li>Etcd db has a db size limit of 8GB, beyond which db becomes readonly and you can lose access to your EKS cluster. Ideally, we recommend to not cross 7GB of etcd db size.</li> <li>As the number of objects in etcd db increase, this leads to increased load on Kubernetes API server, causing API server requests to fail, subsequently causing EMR jobs to fail and reducing EMR job success rate.</li> </ul> </li> <li>The Job churn rate is the operations by the job controller. If the churn rate is high, then the Job queue can\u2019t be processed in time which lead to latency in the EKS cluster. The job churn rate is affected by the job submissions and when the jobs are terminated. It can happen when etcd requests are seeing higher latency and thereby affecting job churn rate.</li> </ul> Test Scenario Job submission mode Job Type EMR EKS Job Submission Rate (per EKS cluster) Jobs/VC/Min Max Number of Active EMR EKS Jobs Weighted Avg Job Duration Executors/job # of Nodes # of EMR jobs # of Concurrent pods # of Pod / Node (m5.24xlarge) Job with default configurations (no spark driver retries and no webhook) StartJobRun batch 150 jobs/min 1 1996 10 mins 10 pods 351 24556 23007 65 Job with default configurations (no spark driver retries and no webhook, 2x executors) StartJobRun batch 80 jobs/min 1 1066 10 mins 20 pods 351 15928 21997 62 Job with default configurations (no spark driver retries and no webhook, 10x jobs per VC) StartJobRun batch 150 jobs/min 10 1953 10 mins 10 pods 351 23953 22092 62 Job with spark driver retries and no webhook StartJobRun batch 140 jobs/min 1 1747 10 mins 10 pods 251 8270 20014 79 Job with webhook (up to max 2 sec delay) and retries StartJobRun batch 140 jobs/min 1 1827 10 mins 10 pods 351 21848 21498 61 Job with default retries with webhook of 2 seconds, 4500+ streaming jobs and 4500+ batch jobs StartJobRun Streaming 140 jobs/min 1 4080 N/A 3 pods 351 4079 22660 65 StartJobRun Batch 110 jobs/min 1 1436 10 mins 10 pods 351 21861 15366"},{"location":"scalability/docs/load-test-for-start-job-run-api/#recommendations-to-meet-large-scale-needs","title":"Recommendations to meet large-scale needs","text":""},{"location":"scalability/docs/load-test-for-start-job-run-api/#workload-distribution","title":"Workload distribution","text":"<p>If the overall workload is larger than an individual EKS cluster, the customer needs to distribute the workload across multiple EKS clusters. Each EKS cluster can handle a portion of the workload, which is required to handle a large volume of EMR on EKS jobs without impacting the performance of the EKS clusters. For more details on how to split clusters, see here</p> <p>For estimating the number of clusters required to onboard all the expected workloads in the first 5 scenarios above, customers can use the following calculation:</p> <ul> <li>Weighted average runtime (WAR): Total weighted average job runtime of EMR jobs</li> <li>Number of pods per EMR on EKS job (NOE): This is the average number of pods for a single EMR on EKS job including executor pods, driver pod, job pods (2 in case of driver retries enabled).</li> <li>The Peak Submission Rate (PSR): it is calculated by summing the peak state job submit volume rate across all services. </li> <li>Recommended Concurrently Running EMR on EKS Pods (RCRP):  This is the total number of concurrently running pods in a single EKS cluster. The recommendation is to keep RCRP below 20000. RCRP = 20000,  we came to this conclusion by using the findings from the benchmark where it was observed that having concurrent EMR on EKS pods more than 20000 led to more strain on the etcd database that could lead to job failures.  <ul> <li>Note: EMR has made optimizations in its control plane and scale testing on the above number **** (RCRP) is in-progress. We plan to re-test these scenarios with the above mentioned optimization and share the updated number.</li> </ul> </li> </ul> <p>Formula:</p> <pre><code>Number of Clusters = (WAR * PSR * NOE) / RCRP\n</code></pre> <p>NOTE: For the streaming scenario, the recommendation is to look at the number of streaming jobs and the number of pods per one streaming job to estimate the number of clusters required.</p> <p>*NOTE: It is assumed the load is evenly distributed across all the shards. *</p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#details-about-eks-cluster-configuration","title":"Details about EKS Cluster configuration","text":""},{"location":"scalability/docs/load-test-for-start-job-run-api/#node-instance-size","title":"Node instance size","text":"<p>In general, fewer large instances are recommended over many small instances. From other Spark on EKS customers we see 500-600 nodes for when they begin distributing load to additional clusters. Each instance requires API calls to the API server, so the more instances you have, the more load on the API server. For right sizing the node and pod cpu/memory requests for your application, please follow this guide https://aws.github.io/aws-eks-best-practices/scalability/docs/node_efficiency.</p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#eks-control-plane-scale-config-for-etcd","title":"EKS Control plane scale config for Etcd","text":"<p>EKS actively monitors the load on control plane instances and automatically scales them to ensure high performance. However, high EMR job submission rates (similar to experiments in this doc) can cause etcd requests seeing high latency/timeouts, even when Etcd control plane instances are not being used to their peak performance in terms of cpu/memory (and thus are not automatically scaled by EKS control plane autoscaler). This latency issue is caused due to high network activity by the large number of Etcd objects when you are pushing the EMR load (in terms of job submission rate and the number of concurrent pods) to the above mentioned test scenarios. In this case, you may need to ensure your EKS control plane instances for etcd are properly scaled up. </p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#eks-api-server-latency","title":"EKS API Server Latency","text":"<p>It is important to minimize the EKS API server latencies. Webhooks can be one potential root cause for high API server latency. The recommendation is to improve the webhook latency to less than 50 milliseconds and monitor the latency to understand health of the cluster. K8s admission webhook best practice.</p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#image-pull-policy","title":"Image pull policy","text":"<p>In an EKS cluster, the imagePullPolicy determines how the container images are pulled from the ECR registry. There are two commonly used imagePullPolicies: Always and IfNotPresent.</p> <p>EMR on EKS allows customers to set the image pull policy for Job runner, driver and executors.</p> <p>For image pull policy, please check it out Kubernetes Image pull policy.</p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#emr-job-driver-retry-strategy","title":"EMR job driver retry strategy","text":"<p>In order to improve the EMR job throughput, disabling the EMR job driver retry strategy should be considered. This however, will shift the responsibility of managing retries to the customer if needed, but will reduce the number of EKS job events in the job controller queue and the number of etcd db objects.</p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#emr-job-timeout","title":"EMR job timeout","text":"<p>To enhance the success rate of EMR jobs, it is advisable that jobs that can withstand an increase in the EMR Job Timeout setting to consider doing so. This adjustment can lead to a higher probability of job completion, particularly when there is an accumulation of K8s Jobs pending in the Job Controller Queue. The EMR Job timeout setting can be configured by using the following Configuration Override while submitting the job</p> <pre><code>{\n\"configurationOverrides\": {\n  \"applicationConfiguration\": [{\n      \"classification\": \"emr-containers-defaults\",\n      \"properties\": {\n          \"job-start-timeout\":\"1800\"\n      }\n  }]\n}\n</code></pre>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#eks-version-upgrade","title":"EKS Version Upgrade","text":"<p>It is recommended to keep EKS version upgraded since the enhancement of concurrency will be improved in future versions.</p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#monitoring-insights-and-recommendations","title":"Monitoring Insights and Recommendations","text":"<p>There are many metrics on EKS to understand the health of the cluster. Monitoring and debugging generally starts with high level big picture metrics, then getting progressively more granular or scoped in a specific resource/actions to identify root cause. The recommendation is to couple the above recommendations with the monitoring insights below while onboarding workloads and running in production. The metrics section in the appendix cover critical cluster metrics that impact EMR job completion throughput, how to plot them and general guidelines for thresholds. There can be other EKS metrics that can be useful on a case by case basis. We also recommend an EMR on EKS scalability review where we can review existing dashboards, thresholds and provide more details on the metrics. </p> <ul> <li>Appendix A - Monitoring metrics to determine overall health and utilization of EKS cluster from EMR jobs standpoint</li> <li>Appendix B - Documentation and best practices on scalability </li> </ul>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#appendix","title":"Appendix","text":""},{"location":"scalability/docs/load-test-for-start-job-run-api/#appendix-a-monitoring-metrics-of-eks-cluster-from-emr-jobs-standpoint","title":"Appendix A - Monitoring metrics of EKS cluster from EMR jobs standpoint","text":"<p>We list the metrics below that can be used to catch scaling issues proactively, especially the ones that are important for a high EMR job submission throughput as discovered in our load-test experiments.</p> <ul> <li>API Server Request and Error counts total: These are the total number/rate of requests to API server that resulted in an error response code such as 4xx or 5xx. This metric helps monitoring API server health at a high level. Many different factors can be the root-cause for API server error count. Failures in API server requests will cause EMR job submission to fail or transition running EMR jobs to failed state. To resolve the API Server failures, you need to look at the underlying root-cause and resolve it.<ul> <li> <ul> <li>Prometheus query for number of API server request by return code by 5 mins duration:     <code>sum(rate``(apiserver_request_total[5m])) by (code) &gt; 0</code></li> </ul> </li> <li>If you find errors in the API server metrics. you can use audit logs to find more details about the errors and what client was involved.<ul> <li>Cloudwatch log insights query for finding 5xx error generators (loggroup: /aws/eks//cluster)<ul> <li>stats count(*) as count by requestURI, verb, responseStatus.code, userAgent     | filter @logStream =~ \"kube-apiserver-audit\"     | filter responseStatus.code &gt;= 500      | sort count desc</li> </ul> <li>Cloudwatch log insights query for finding 4xx error generators (loggroup: /aws/eks//cluster)<ul> <li>stats count(*) as count by requestURI, verb, responseStatus.code, userAgent     | filter @logStream =~ \"kube-apiserver-audit\"     | filter responseStatus.code &gt;= 400     | filter responseStatus.code &lt; 500     | sort count desc</li> </ul> <li>API Request Latency by verb: This will help show which API calls are the slowest by verb and scope. This can help narrow down which actions or resources are impacted compared to overall latency. As the EMR job submission rate increases, number of objects per resource type increases in the EKS cluster. This will cause espcially LIST calls latency to increase and in turn cause strain to etcd database and API server. This can further affect other API latencies such as POST to increase and cause EMR jobs to fail.<ul> <li>Prometheus query for P99 latency values by verb and scope (ignoring long running connections like Watch and Connect as they run longer than normal API calls):<ul> <li><code>histogram_quantile(0.99, sum(rate(apiserver_request_duration_seconds_bucket{verb!~\"CONNECT|WATCH\"}[5m])) by (verb, scope, le)) &gt; 0</code></li> </ul> </li> <li></li> <li>Adding the resource in the query can  give more granular information about latency by identifying when a single resource is slow or impacted:<ul> <li><code>histogram_quantile(0.99, sum(rate(apiserver_request_duration_seconds_bucket{verb!~\"CONNECT|WATCH\"}[5m])) by (resource, verb, scope, le)) &gt; 0</code></li> </ul> </li> <li></li> </ul> </li> <li>API \u2192 Etcd request latency by object/action : This metric can help to identify if the API Request latency is being driven by backend/etcd performance or if it\u2019s being introduced at the API server. This metric increases when the strain on Etcd db is causing API server requests to experience higher latency especially when the number of objects in Etcd increases. As Etcd request latency increases, api server requests can start timing out causing EMR jobs to fail to submit or transition from running to failed state. To recover, you will need to back off by reducing the EMR job submission rate or stopping the new job submissions completely.<ul> <li> <ul> <li><code>histogram_quantile(0.99, sum(rate(etcd_request_duration_seconds_bucket[5m])) by (type, operation, le)) &gt; 0</code></li> </ul> </li> </ul> </li> <li>Etcd database size:  When you create a cluster, Amazon EKS provisions the maximum recommended database size for etcd in Kubernetes, which is 8GB. When the database size limit is exceeded, etcd emits a no space alarm and stops taking further write requests. In other words, the cluster becomes read-only, and all requests to mutate objects such as creating new pods, scaling deployments, etc., will be rejected by the cluster\u2019s API server. Further, users won\u2019t be able to delete objects or object revisions to reclaim etcd storage space. This will cause all subsequent EMR jobs to fail. It is very important to monitor etcd database size to keep it under limit. If your Etcd db runs into no space alarm, EKS auto recovery workflow kicks in to recover some db space. Please check this blog post for more details on recovering Etcd db from no space alarm.<ul> <li>Etcd DB size metric<ul> <li>apiserver_storage_size_bytes</li> </ul> </li> </ul> </li> <li>Node utilization: The number of nodes, the instance types for those nodes, the EMR job submission rate combined with pods cpu/memory request limits will contribute to the node utilization going up or down. Ideally we need high node utilization for efficient EKS cluster compute usage. However, if you see all nodes in the cluster are being utilized near 100% in terms of cpu/memory, you may need to scale your EKS cluster further  by additional nodes (manually if not using an autoscaler).<ul> <li>node_cpu_seconds_total</li> <li>node_memory_MemFree_bytes</li> <li>node_memory_Cached_bytes</li> <li>node_memory_Buffers_bytes</li> <li>node_memory_MemTotal_bytes</li> <li>You need node_exporter addon for these metrics: https://aws-quickstart.github.io/cdk-eks-blueprints/addons/prometheus-node-exporter/</li> <li></li> <li>You can find queries for the above dashboard here: https://github.com/awslabs/data-on-eks/blob/main/analytics/terraform/emr-eks-karpenter/emr-grafana-dashboard/emr-eks-grafana-dashboard.json</li> </ul> </li> <li>[Only if you are using admission webhooks] Admission Webhook request Counts - This metric denotes the numbers of how many requests are hitting the admission webhooks by name. This can show a misconfiguration of webhooks if theres a single webhook that is both receiving a large number of requests. Misconfiguration of a webhook can cause unintended API server requests to see higher latency and cause slowness in job submission or even time-outs.<ul> <li> <ul> <li><code>sum(rate(apiserver_admission_webhook_request_total[5m])) by (name) &gt; 0</code></li> </ul> </li> <li> <ul> <li><code>sum(rate(apiserver_admission_webhook_request_total{rejected=\"true\"}[5m])) by (name) &gt; 0</code></li> </ul> </li> <li>You can also use the \u201coperation\u201d label to correlate by actions.</li> </ul> </li> <li>[Only if you are using admission webhooks] Admission Webhook request Latency This metric shows how long requests from the API servers to admission webhooks are taking. We can break that out by webhook name, success/failure, and operation.<ul> <li>This latency is useful in tandem with the API request latency metrics as the time it takes to handle webhook requests is included in the total latency. If the webhooks are taking ~3s to respond, we can expect ~3s of additional latency to those requests. High webhook latency can cause API server requests to time out causing EMR job failures.<ul> <li>Be wary on CPU throttling or overwhelming the Pods that are servicing webhooks. Delays or failures in admission can have a cluster wide performance impact (in worst cases it can grind a cluster to a halt) </li> </ul> </li> <li> <ul> <li><code>histogram_quantile(0.99, sum(rate(apiserver_admission_webhook_admission_duration_seconds_bucket[5m])) by (name, operation, le)) &gt; 0</code></li> </ul> </li> <li>You can add the rejected label to the output to also get an idea how often webhooks are allowing/rejecting requests. <ul> <li><code>histogram_quantile(0.99, sum(rate(apiserver_admission_webhook_admission_duration_seconds_bucket[5m])) by (name, operation, rejected, le)) &gt; 0</code></li> </ul> </li> <li></li> </ul> </li> <p>Dashboard that was demonstrated: https://github.com/RiskyAdventure/Troubleshooting-Dashboards/blob/main/api-troubleshooter.json</p> <p>EKS Performance Overview Grafana Dashboard: https://grafana.com/grafana/dashboards/6775-kubernetes-performance-overview/</p> <p>SLO / SLI reference from Upstream for baselines:  https://github.com/kubernetes/community/blob/master/sig-scalability/slos/api_call_latency.md</p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#appendix-b-documentation-and-best-practices-on-scalability","title":"Appendix B - Documentation and best practices on scalability","text":"<p>Below points link to several EKS scalability best practices documentation. Most of these references are for educational purpose on how to monitor, scale test, and autoscale EKS cluster and are not intended to be recommendations for EMR on EKS customers.</p> <ul> <li>Blog on how EKS does scalability testing https://aws.amazon.com/blogs/containers/deep-dive-into-amazon-eks-scalability-testing/<ul> <li>This best practices page dives deeper into the metrics and SLOs that K8s community measures https://aws.github.io/aws-eks-best-practices/scalability/docs/kubernetes_slos/</li> <li>We run 5,000 nodes and ~150k pods, churning at 50 pods/s in our load tests. But our node capacity is static and not autoscaling.</li> </ul> </li> <li>Kubernetes scalability thresholds https://github.com/kubernetes/community/blob/master/sig-scalability/configs-and-limits/thresholds.md<ul> <li>These are where Kubernetes Scalability SIG would expect performance degradation in the cluster</li> </ul> </li> <li>Some of the AWS quotas and other limitations we've seen customers hit https://aws.github.io/aws-eks-best-practices/scalability/docs/quotas/</li> <li>Reference Prometheus configuration is the kube-prometheus-stack https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack though it collects a ton of metrics and may hit issues with large clusters.</li> <li>This best practices page has some of the key metrics to gather for your cluster https://aws-observability.github.io/observability-best-practices/guides/containers/oss/eks/best-practices-metrics-collection/#control-plane-metrics</li> <li>This page discusses the prometheus metrics available from the AWS VPC CNI https://github.com/aws/amazon-vpc-cni-k8s/blob/master/cmd/cni-metrics-helper/README.md <ul> <li>You don\u2019t need to use the metrics helper application unless you want these available in CloudWatch. The prometheus endpoint should be available to your DataDog agents.</li> <li>You can annotate pods to use the autoscrape config https://github.com/aws/amazon-vpc-cni-k8s/issues/327#issuecomment-466913046</li> </ul> </li> <li>We also discussed that Kubernetes clients can impact the performance of the cluster with spammy or expensive API calls. Cloud Watch Log Insights is a powerful tool to query the audit events in your EKS clusters and can provide details like \u201cWhich userAgent is sending the slowest LIST calls in the cluster? and what are they listing?\u201d <ul> <li>The queries i use to troubleshoot and deep dive are listed here https://github.com/aws-samples/specialist-tam-container-dashboards/blob/main/troubleshooting-queries/CloudWatch-Logs-Troubleshooting-Queries.md</li> </ul> </li> <li>OpenAI has done a couple of blogs discussing their journey on huge K8s clusters: <ul> <li>https://openai.com/research/scaling-kubernetes-to-2500-nodes</li> <li>https://openai.com/research/scaling-kubernetes-to-7500-nodes</li> </ul> </li> <li>Kubernetes Fail stories, scale often plays a role in some of the nastier outages: https://k8s.af/</li> <li>Metrics to watch on CoreDNS https://www.datadoghq.com/blog/coredns-metrics/#metrics-to-watch-coredns_dns_responses_total-coredns_forward_responses_total</li> <li>EKS Blog on Managing and monitoring etcd DB size and Defrag: https://aws.amazon.com/blogs/containers/managing-etcd-database-size-on-amazon-eks-clusters/</li> <li>Shane\u2019s API server Dashboard https://aws.amazon.com/blogs/containers/troubleshooting-amazon-eks-api-servers-with-prometheus/</li> <li>EKS scaling theory: https://aws.github.io/aws-eks-best-practices/scalability/docs/scaling_theory/</li> <li>Kubernetes recommendations on scalability thresholds: https://github.com/kubernetes/community/blob/master/sig-scalability/configs-and-limits/thresholds.md</li> </ul>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#appendix-c-load-testing-cluster-configurations","title":"Appendix C -  Load Testing Cluster Configurations","text":"<p>The EKS cluster setup and EMR release are maintained across the different scenarios while performing the load test</p> <ul> <li>Number of nodes: 351</li> <li>Instance type: m5.24xlarge</li> <li>Instance number of cores: 16</li> <li>Instance memory: 128 Gb</li> <li>EMR Relaese: emr-7.0.0-latest</li> <li>Eks version: 1.30</li> <li>Region: us-west-2</li> <li>Number of executors: 10</li> <li>Executor Memory: 512M</li> <li>Executor Core: 1</li> <li>Driver Core: 1</li> <li>Driver Memory: 512</li> <li>Total number of configmaps per job: 7</li> </ul>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#appendix-d-image-pull-policies-and-proscons","title":"Appendix D - Image Pull Policies and pros/cons","text":"<p>Here are the advantages and disadvantages of each: </p>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#imagepullpolicy-always-default","title":"ImagePullPolicy: Always  (Default)","text":"<p>Advantages: </p> <ul> <li>Consistent behavior: Always pulling the latest image ensures consistent behavior across deployments, as all nodes will have the same version of the image. </li> <li>Easy to manage: With Always, you don't need to worry about image versions or caching, as the latest image will always be pulled. </li> </ul> <p>Disadvantages: </p> <ul> <li>Increased network traffic: Always pulling the latest image can result in increased network traffic, as the entire image is downloaded every time.</li> <li>Longer deployment times: Pulling the latest image can take longer, especially for large images, which can increase deployment times. </li> </ul>"},{"location":"scalability/docs/load-test-for-start-job-run-api/#imagepullpolicy-ifnotpresent","title":"ImagePullPolicy: IfNotPresent","text":"<p>Advantages: </p> <ul> <li>Faster deployments: IfNotPresent can lead to faster deployments, as the image is only pulled if it's not already present in the node's cache. </li> <li>Reduced network traffic: By only pulling the image when it's not present, you can reduce network traffic and save on data transfer costs. </li> <li>Improved performance: IfNotPresent can improve performance, as the image is cached on the node, reducing the need for subsequent pulls. </li> </ul> <p>Disadvantages: </p> <ul> <li>Inconsistent behavior: With IfNotPresent, nodes may have different versions of the image, leading to inconsistent behavior across deployments. </li> <li>More complex management: IfNotPresent requires more complex management, as you need to ensure that the image is properly cached and updated. </li> <li>Potential for outdated images: If an image is not properly updated, nodes may end up with outdated versions, leading to potential issues. </li> </ul>"},{"location":"scalability/docs/scalaiblity-glossary/","title":"EMR on EKS Glossary &amp; Terms","text":"<ul> <li>EMR on EKS Job: The Spark Job being submitted and executed by the EMR on EKS Control plane</li> <li>EMR on EKS Job types: Type of Spark job being submitted. It can be either batch job (having fixed job duration) or streaming job (continuously running job).</li> <li>Kubernetes (K8s) control plane: A K8s cluster consists of a control plane and one or more worker nodes. Control plane is responsible managing overall state of the cluster and includes components such as API server, etcd database, scheduler, and controller manager.</li> <li>K8s API request: The K8s API is a resource-based (RESTful) programmatic interface provided via HTTP. It supports retrieving, creating, updating, and deleting resources in K8s cluster via the standard HTTP verbs (POST, PUT, PATCH, DELETE, GET). </li> <li>K8s pod: Pods are the smallest deployable units of computing that you can create and manage in Kubernetes. </li> <li>K8s event: Event is a report of an event somewhere in the K8s cluster. It generally denotes some state change in the system. </li> <li>K8s config map: A ConfigMap is an API object used to store non-confidential data in key-value pairs. Pods can consume ConfigMaps as environment variables, command-line arguments, or as configuration files in a volume.</li> <li>K8s API Server: API server **** is an internal K8s component responsible to serve and process K8s API requests. EKS hosts this K8s control plane component on EKS owned infrastructure that is different from customer\u2019s EKS cluster.</li> <li>K8s Etcd database: Etcd is K8s internal database that stores information about K8s objects such as pods, events, config maps etc. EKS hosts this K8s control plane component on EKS owned infrastructure.</li> <li>K8s Job: A K8s Job object creates and monitors a pod until they complete successfully. It has a retry policy that helps ensuring completion. This is different from EMR on EKS job concept. An EMR on EKS job usually submits one or more K8s jobs in K8s cluster.</li> <li>K8s Job Controller: The K8s native controller is a component that interacts with the Kubernetes API server to create pods, update job status according to pod status, create events. Job controller monitors and updates K8s job objects.</li> <li>K8s Job Controller Work Queue (Depth): The backlog of K8s job object events accumulated, that need to be processed by job controller.</li> <li>EMR Spark Operator: A job submission model for Amazon EMR on EKS, which users can deploy and manage Spark applications with the Amazon EMR release runtime on the Amazon EKS clusters</li> <li>Job types:  Type of Spark job being submitted. It can be either batch job (having fixed job duration) or streaming job (continuously running job).</li> <li>Spark Operator Workqueue: The central component in the Spark Operator's control loop, managing the flow of SparkApplication resources that need to be processed, ensuring efficient, ordered, and reliable handling of these resources.</li> </ul>"},{"location":"security/docs/spark/data-encryption/","title":"EMR Containers Spark - In transit and At Rest data encryption","text":""},{"location":"security/docs/spark/data-encryption/#encryption-at-rest","title":"Encryption at Rest","text":""},{"location":"security/docs/spark/data-encryption/#amazon-s3-client-side-encryption","title":"Amazon S3 Client-Side Encryption","text":"<p>To utilize S3 Client side encryption, you will need to create a KMS Key to be used to encrypt and decrypt data. If you do not have an KMS key, please follow this guide - AWS KMS create keys. Also please note the job execution role needs access to this key, please see Add to Key policy for instructions on how to add these permissions.</p> <p>trip-count-encrypt-write.py:</p> <pre><code>cat&gt; trip-count-encrypt-write.py&lt;&lt;EOF\nimport sys\n\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"trip-count-join-fsx\")\\\n        .getOrCreate()\n\n    df = spark.read.parquet('s3://&lt;s3 prefix&gt;/trip-data.parquet')\n    print(\"Total trips: \" + str(df.count()))\n\n    df.write.parquet('s3://&lt;s3 prefix&gt;/write-encrypt-trip-data.parquet')\n    print(\"Encrypt - KMS- CSE writew to s3 compeleted\")\n    spark.stop()\n    EOF\n</code></pre> <p>Request: </p> <pre><code>cat &gt; spark-python-in-s3-encrypt-cse-kms-write.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;trip-count-encrypt-write.py\", \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n       },\n       {\n         \"classification\": \"emrfs-site\", \n         \"properties\": {\n          \"fs.s3.cse.enabled\":\"true\",\n          \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\",\n          \"fs.s3.cse.kms.keyId\":\"&lt;KMS Key Id&gt;\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\", \n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json\n</code></pre> <p>In the above request, EMRFS encrypts the parquet file with the specified KMS key and the encrypted object is persisted to the specified s3 location.</p> <p>To verify the encryption - use the same KMS key to decrypt - the KMS key used is a symmetric key ( the same key can be used to both encrypt and decrypt)</p> <p>trip-count-encrypt-read.py </p> <pre><code>cat &gt; trip-count-encrypt-read.py&lt;&lt;EOF\nimport sys\n\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"trip-count-join-fsx\")\\\n        .getOrCreate()\n\n    df = spark.read.parquet('s3://&lt;s3 prefix&gt;/trip-data.parquet')\n    print(\"Total trips: \" + str(df.count()))\n\n    df_encrypt = spark.read.parquet('s3://&lt;s3 prefix&gt;/write-encrypt-trip-data.parquet')\n    print(\"Encrypt data - Total trips: \" + str(df_encrypt.count()))\n    spark.stop()\n   EOF\n</code></pre> <p>Request</p> <pre><code>cat &gt; spark-python-in-s3-encrypt-cse-kms-read.json&lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-encrypt-cse-kms-read\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;trip-count-encrypt-write.py\", \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n       },\n       {\n         \"classification\": \"emrfs-site\", \n         \"properties\": {\n          \"fs.s3.cse.enabled\":\"true\",\n          \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\",\n          \"fs.s3.cse.kms.keyId\":\"&lt;KMS Key Id&gt;\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\", \n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-read.json\n</code></pre> <p>Validate encryption: Try to read the encrypted data without specifying <code>\"fs.s3.cse.enabled\":\"true\"</code> - will get an error message in the driver and executor logs because the content is encrypted and cannot be read without decryption.</p>"},{"location":"security/docs/spark/encryption/","title":"EMR on EKS - Encryption Best Practices","text":"<p>This document will describe how to think about security and its best practices when applying to EMR on EKS service. We will cover topics related to encryption at rest and in-transit when you run EMR on EKS jobs on EKS cluster.</p> <p>It's important to understand the shared responsibility model when using managed services such as EMR on EKS in order to improve the overall security posture of your environment. Generally speaking AWS is responsible for security \"of\" the cloud whereas you, the customer, are responsible for security \"in\" the cloud. The diagram below depicts this high level definition. </p>"},{"location":"security/docs/spark/encryption/#shared-responsibility-model","title":"Shared responsibility model","text":"<p>EMR on EKS provides simple way to run spark jobs on top of EKS clusters. The architecture itself is loosely coupled and is abstracted from customers so that they can run secure environment for running spark applications. Because EMR on EKS uses combination of two services (EMR and EKS) at a minimal, we will cover how EKS enables infrastructure components that are consumable by EMR spark workload and how to handle encryption for each service.</p> <p>AWS assumes different levels of responsibility depending on the features being consumed by EMR on EKS customers. At this time of writing, the features from EKS are managed node groups, self-managed workers, and Fargate. We won\u2019t go in-depth on these architectures as they are detailed in EKS best practices guide (https://aws.github.io/aws-eks-best-practices/security/docs/). Below diagrams depict how this responsibility changes between customer and AWS based on consumed features.</p> <p> </p>"},{"location":"security/docs/spark/encryption/#encryption-for-data-in-transit","title":"Encryption for data in-transit","text":"<p>In this section, we will cover encryption for data in-transit. We will highlight AWS platform capabilities from the physical layer and then review how AWS handles encryption in the EMR on EKS architecture layer. Lastly, we will cover how customers can enable encryption between spark drivers and executors.</p>"},{"location":"security/docs/spark/encryption/#aws-infrastructure-physical-layer","title":"AWS Infrastructure - Physical layer","text":"<p>AWS provides secure and private connectivity between EC2 instances of all types. All data flowing across AWS Regions over the AWS global network is automatically encrypted at the physical layer before it leaves AWS secured facilities. All traffic between AZs is encrypted. All cross-Region traffic that uses Amazon VPC and Transit Gateway peering is automatically bulk-encrypted when it exits a Region. In addition, if you use Nitro family of instances, all traffic between instances is encrypted in-transit using AEAD algorithms with 256-bit encryption. We highly recommend reviewing EC2 documentation for more information.</p>"},{"location":"security/docs/spark/encryption/#amazon-emr-on-eks","title":"Amazon EMR on EKS","text":"<p>Below diagram depicts high-level architecture implementation of EMR on EKS. In this section, we will cover encryption in-transit for communication between managed services such as EMR &amp; EKS. All traffic with AWS API\u2019s that support EMR and EKS are encrypted by default. EKS enables Kubernetes API server using https endpoint. Both the kubelet that runs on EKS worker nodes and Kubernetes client such as kubectl interacts with EKS cluster API using TLS. Amazon EMR on EKS uses the same secure channel to interact with EKS cluster API to run spark jobs on worker nodes. In addition, EMR on EKS provides an encrypted endpoint for accessing spark history server.  </p> <p></p> <p>Spark offers AES-based encryption for RPC connections. EMR on EKS customers may choose to encrypt the traffic between spark drivers and executors using this encryption mechanism. In order to enable encryption, RPC authentication must also be enabled in your spark configuration.</p> <pre><code>--conf spark.authenticate=true \\\n--conf spark.network.crypto.enabled=true \\\n</code></pre> <p>The encryption key is generated by the driver and distributed to executors via environment variables. Because these environment variables can be accessed by users who have access to Kubernetes API (kubectl), we recommend securing access so that only authorized users have access to your environment. You should also configure proper Kubernetes RBAC permissions so that only authorized service accounts can use these variables.</p>"},{"location":"security/docs/spark/encryption/#encryption-for-data-at-rest","title":"Encryption for data at-rest","text":"<p>In this section, we will cover encryption for data at-rest. We will review how to enable storage-level encryption so that it is transparent for spark application to use this data securely. We will also see how to enable encryption from spark application while using AWS native storage options.</p>"},{"location":"security/docs/spark/encryption/#amazon-s3","title":"Amazon S3","text":"<p>Amazon S3 offers server-side encryption for encrypting all data that is stored in an S3 bucket. You can enable default encryption using either S3 managed keys (SSE-S3) or KMS managed keys (SSE-KMS). Amazon S3 will encrypt all data before storing it on disks based on the keys specified. We recommend using server-side encryption at a minimum so that your data at-rest is encrypted. Please review Amazon S3 documentation and use the mechanisms that apply to your encryption standards and acceptable performance.</p> <p>Amazon S3 supports client-side encryption as well. Using this approach, you can let spark application to encrypt all data with desired KMS keys and upload this data to S3 buckets. Below examples shows spark application reading and writing parquet data in S3. During job submission, we use EMRFS encryption mechanism to encrypt all data with KMS key into the desired S3 location.</p> <pre><code>import sys\n\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"trip-count-join-fsx\")\\\n        .getOrCreate()\n\n    df = spark.read.parquet('s3://&lt;s3 prefix&gt;/trip-data.parquet')\n    print(\"Total trips: \" + str(df.count()))\n\n    df.write.parquet('s3://&lt;s3 prefix&gt;/write-encrypt-trip-data.parquet')\n    print(\"Encrypt - KMS- CSE writew to s3 compeleted\")\n    spark.stop()\n</code></pre> <p>Below is the job submission request that depicts KMS specification needed for EMRFS to perform this encryption. For complete end-to-end example, please see EMR on EKS best practices documentation</p> <pre><code>cat &gt; spark-python-in-s3-encrypt-cse-kms-write.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\",\n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\",\n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\",\n  \"releaseLabel\": \"emr-6.2.0-latest\",\n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;trip-count-encrypt-write.py\",\n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\"\n    }\n  },\n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\",\n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n       },\n       {\n         \"classification\": \"emrfs-site\",\n         \"properties\": {\n          \"fs.s3.cse.enabled\":\"true\",\n          \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\",\n          \"fs.s3.cse.kms.keyId\":\"&lt;KMS Key Id&gt;\"\n         }\n      }\n    ],\n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\",\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\",\n        \"logStreamNamePrefix\": \"demo\"\n      },\n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json\n</code></pre> <p>Amazon EKS offers three different storage offerings (EBS, EFS, FSx) that can be directly consumed by pods. Each storage offering provides encryption mechanism that can be enabled at the storage level.</p>"},{"location":"security/docs/spark/encryption/#amazon-ebs","title":"Amazon EBS","text":"<p>Amazon EBS supports default encryption that can be turned on a per-region basis. Once it's turned on, you can have newly created EBS volumes and snapshots encrypted using AWS managed KMS keys. Please review EBS documentation to learn more on how to enable this feature</p> <p>You can use Kubernetes (k8s) in-tree storage driver or choose to use EBS CSI driver to consume EBS volumes within your pods. Both choices offer options to enable encryption. In the below example, we use k8s in-tree storage driver to create storage class and persistent volume claim. You can create similar resources using EBS CSI driver as well.  </p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: encrypted-sc\nprovisioner: kubernetes.io/aws-ebs\nvolumeBindingMode: WaitForFirstConsumer\nparameters:\n  type: gp2\n  fsType: ext4\n  encrypted: \"true\"\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: spark-driver-pvc\nspec:\n  storageClassName: encrypted-sc\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 10Gi\n</code></pre> <p>Once these resources are created, you can specify them in your drivers and executors. You can see an example of this specification below. Keep in mind, you can only attach an EBS volume to single EC2 instance or a Kubernetes pod. Therefore, if you have multiple executor pods, you need to create multiple PVCs to fulfill this request </p> <pre><code>--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data\n...\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=spark-executor-pvc\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data\n</code></pre> <p>Another approach is to let k8s create EBS volumes dynamically based on your spark workload. You can do so by specifying just the storageClass  and sizeLimit  options and specify OnDemand for the persistent volume claim (PVC). This is useful in case of Dynamic Resource Allocation. Please be sure to use EMR 6.3.0 release and above to use this feature because dynamic PVC support was added in Spark 3.1. Below is an example for dynamically creating volumes for executors within your job</p> <pre><code>--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=OnDemand\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.storageClass=encrypted-sc\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.sizeLimit=10Gi\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName=OnDemand\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.storageClass=encrypted-sc\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.sizeLimit=10Gi\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path=/var/data/spill\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly=false\n</code></pre> <p>For a complete list of available options, please refer to the Spark Documentation</p>"},{"location":"security/docs/spark/encryption/#amazon-efs","title":"Amazon EFS","text":"<p>Similar to EBS, you can consume EFS volumes via EFS CSI driver and FSx for Lustre volumes via FSx CSI driver. There are two provisioning methods before these storage volumes are consumed by workloads, namely static provisioning and dynamic provisioning. For static provisioning, you have to pre-create volumes using AWS API\u2019s, CLI or AWS console. For dynamic provisioning, volume is created dynamically by the CSI drivers as workloads are deployed onto Kubernetes cluster. Currently, EFS CSI driver doesn\u2019t support dynamic volume provisioning. However, you can create the volume using EFS API or AWS console before creating a persistent volume (PV) that can be used within your spark application. If you plan to encrypt the data stored in EFS, you need to specify encryption during volume creation. For further information about EFS file encryption, please refer to Encrypting Data at Rest. One of the advantages of using EFS is that it provides encryption in transit support using TLS and it's enabled by default by the CSI driver. You can see the example below if you need to enforce TLS encryption during PV creation</p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: efs-pv\nspec:\n  capacity:\n    storage: 5Gi\n  volumeMode: Filesystem\n  accessModes:\n    - ReadWriteOnce\n  persistentVolumeReclaimPolicy: Retain\n  storageClassName: efs-sc\n  csi:\n    driver: efs.csi.aws.com\n    volumeHandle: fs-4af69aab\n    volumeAttributes:\n      encryptInTransit: \"true\"\n</code></pre>"},{"location":"security/docs/spark/encryption/#amazon-fsx-for-lustre","title":"Amazon FSx for Lustre","text":"<p>Amazon FSx CSI driversupports both static and dynamic provisioning. Encryption for data in-transit is automatically enabled from Amazon EC2 instances that support encryption in transit. To learn which EC2 instances support encryption in transit, see Encryption in Transit in the Amazon EC2 User Guide for Linux Instances. Encryption for data at rest is automatically enabled when you create the FSx filesystem. Amazon FSx for Lustre supports two types of filesystems, namely persistent and scratch. You can use the default encryption method where encryption keys are managed by Amazon FSx. However, if you prefer to manage your own KMS keys, you can do so for persistent filesystem. The example below shows how to create storage class using FSx for Lustre for persistent filesystem using your own KMS managed keys.</p> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\n  name: fsx-sc\nprovisioner: fsx.csi.aws.com\nparameters:\n  subnetId: subnet-056da83524edbe641\n  securityGroupIds: sg-086f61ea73388fb6b\n  deploymentType: PERSISTENT_1\n  kmsKeyId: &lt;kms_arn&gt;\n</code></pre> <p>You can then create persistent volume claim (see an example in FSx repo) and use within your spark application as below</p> <pre><code>--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=fsx-claim\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data\n</code></pre>"},{"location":"security/docs/spark/encryption/#using-spark-to-encrypt-data","title":"Using Spark to encrypt data","text":"<p>Apache Spark supports encrypting temporary data that is stored on storage volumes. These volumes can be instance storage such as NVMe SSD volumes, EBS, EFS or FSx volumes. Temporary data can be shuffle files, shuffle spills and data blocks stored on disk (for both caching and broadcast variables). It's important to note that the data on NVMe instance storage is encrypted using an XTS-AES-256 block cipher implemented in a hardware module on the instance. Even though, instance storage is available, you need to format and mount them while you bootstrap EC2 instances. Below is an example to show how to use instance storage using eksctl</p> <pre><code>managedNodeGroups:\n- name: nvme\n  minSize: 2\n  desiredCapacity: 2\n  maxSize: 10\n  instanceType: r5d.4xlarge\n  ssh:\n    enableSsm: true\n  preBootstrapCommands:\n    - IDX=1\n    - for DEV in /dev/disk/by-id/nvme-Amazon_EC2_NVMe_Instance_Storage_*-ns-1; do  mkfs.xfs ${DEV};mkdir -p /local${IDX};echo ${DEV} /local${IDX} xfs defaults,noatime 1 2 &gt;&gt; /etc/fstab; IDX=$((${IDX} + 1)); done\n    - mount -a\n</code></pre> <p>If you use non-NVMe SSD volumes, you can follow the best practice to encrypt shuffle data before you write them to disks. You can see an example below that shows this example. For more information about the type of instance store volume supported by each instance type, see Instance store volumes.</p> <pre><code>--conf spark.io.encryption.enabled=true\n</code></pre>"},{"location":"security/docs/spark/encryption/#conclusion","title":"Conclusion","text":"<p>In this document, we covered shared responsibility model for running EMR on EKS workload. We then reviewed platform capabilities available through AWS infrastructure and how to enable encryption for both storage-level and via spark application. To quote Werner Vogels, AWS CTO \u201cSecurity is everyone\u2019s job now, not just the security team\u2019s\u201d. We hope this document provides prescriptive guidance into how to enable encryption for running secure EMR on EKS workload.   </p>"},{"location":"security/docs/spark/network-security/","title":"** Managing VPC for EMR on EKS**","text":"<p>This section address network security at VPC level. If you want to read more on network security for Spark in EMR on EKS please refer to this section.</p>"},{"location":"security/docs/spark/network-security/#security-group","title":"Security Group","text":"<p>The applications running on your EMR on EKS cluster often would need access to services that are running outside the cluster,  for example, these can Amazon Redshift, Amazon Relational Database Service, a service self hosted on an EC2 instance. To access these resource you need to allow network traffic at the security group level. The default mechanism in EKS is using security groups at the node level,  this means all the pods running on the node will inherit the rules on the security group.  For security conscious customers, this is not a desired behavior and you would want to use security groups at the pod level.</p> <p>This section address how you can use Security Groups with EMR on EKS.</p>"},{"location":"security/docs/spark/network-security/#configure-eks-cluster-to-use-security-groups-for-pods","title":"Configure EKS Cluster to use Security Groups for Pods","text":"<p>In order to use Security Groups at the pod level, you need to configure the VPC CNI for EKS. The following link guide through the prerequisites as well as configuring the EKS Cluster.</p>"},{"location":"security/docs/spark/network-security/#define-securitygrouppolicy","title":"Define SecurityGroupPolicy","text":"<p>Once you have configured the VPC CNI, you need to create a SecurityGroupPolicy object.  This object define which security group (up to 5) to use, podselector to define which pod to apply the security group to and  the namespace in which the Security Group should be evaluated. Below you find an example of <code>SecurityGroupPolicy</code>.</p> <pre><code>apiVersion: vpcresources.k8s.aws/v1beta1\nkind: SecurityGroupPolicy\nmetadata:\n  name: &lt;&gt;\n  namespace: &lt;NAMESPACE FOR VC&gt;\nspec:\n  podSelector: \n    matchLabels:\n      role: spark\n  securityGroups:\n    groupIds:\n      - sg-xxxxx\n</code></pre>"},{"location":"security/docs/spark/network-security/#define-pod-template-to-use-security-group-for-pod","title":"Define pod template to use Security Group for pod","text":"<p>In order for the security group to be applied to the Spark driver and executors, you need to provide a podtemplate which add label(s) to the pods. The labels should match the one defined above in the <code>podSelector</code> in our example it is <code>role: spark</code>.  The snippet below define the pod template that you can upload in S3 and then reference when launching your job.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  labels:\n    role: spark\n</code></pre>"},{"location":"security/docs/spark/network-security/#launch-a-job","title":"Launch a job","text":"<p>The command below can be used to run a job.</p> <pre><code>    aws emr-containers start-job-run --virtual-cluster-id &lt;EMR-VIRTUAL-CLUSTER-ID&gt; --name spark-jdbc --execution-role-arn &lt;EXECUTION-ROLE-ARN&gt; --release-label emr-6.7.0-latest --job-driver '{\n    \"sparkSubmitJobDriver\": {\n    \"entryPoint\": \"&lt;S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE&gt;\",\n    \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1\"\n    }\n    }' --configuration-overrides '{\n    \"applicationConfiguration\": [\n    {\n    \"classification\": \"spark-defaults\", \n    \"properties\": {\n    \"spark.hadoop.hive.metastore.client.factory.class\": \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n    \"spark.sql.catalogImplementation\": \"hive\",\n    \"spark.dynamicAllocation.enabled\":\"true\",\n    \"spark.dynamicAllocation.minExecutors\": \"8\",\n    \"spark.dynamicAllocation.maxExecutors\": \"40\",\n    \"spark.kubernetes.allocation.batch.size\": \"8\",\n    \"spark.dynamicAllocation.executorAllocationRatio\": \"1\",\n    \"spark.dynamicAllocation.shuffleTracking.enabled\": \"true\",\n    \"spark.dynamicAllocation.shuffleTracking.timeout\": \"300s\",\n    \"spark.kubernetes.driver.podTemplateFile\":&lt;S3-URI-TO-DRIVER-POD-TEMPLATE&gt;,\n    \"spark.kubernetes.executor.podTemplateFile\":&lt;S3-URI-TO-EXECUTOR-POD-TEMPLATE&gt;\n    }\n    }\n    ],\n    \"monitoringConfiguration\": {\n        \"persistentAppUI\": \"ENABLED\",\n        \"cloudWatchMonitoringConfiguration\": {\n            \"logGroupName\": \"/aws/emr-containers/\",\n            \"logStreamNamePrefix\": \"default\"\n        }\n    }\n    }'\n</code></pre>"},{"location":"security/docs/spark/network-security/#verify-a-security-group-attached-to-the-pod-eni","title":"Verify a security group attached to the Pod ENI","text":"<p>To verify that spark driver and executor driver have the security group attached to, apply the first command to get the podname then the second one to see the annotation in pod with the ENI associated to the pod which has the secuity group defined in the SecurityGroupPolicy.</p> <pre><code>export POD_NAME=$(kubectl -n &lt;NAMESPACE&gt; get pods -l role=spark -o jsonpath='{.items[].metadata.name}')\n\nkubectl -n &lt;NAMESPACE&gt;  describe pod $POD_NAME | head -11\n</code></pre> <pre><code>Annotations:  kubernetes.io/psp: eks.privileged\n              vpc.amazonaws.com/pod-eni:\n                [{\"eniId\":\"eni-xxxxxxx\",\"ifAddress\":\"xx:xx:xx:xx:xx:xx\",\"privateIp\":\"x.x.x.x\",\"vlanId\":1,\"subnetCidr\":\"x.x.x.x/x\"}]\n</code></pre>"},{"location":"security/docs/spark/secrets/","title":"** Using Secrets in EMR on EKS**","text":"<p>Secrets can be credentials to APIs, Databases or other resources. There are various ways these secrets can be passed to your containers, some of them are pod environment variable or Kubernetes Secrets. These methods are not secure, as for environment variable, secrets are stored in clear text and any authorized user who has access to Kubernetes cluster with admin privileges can read those secrets. Storing secrets using Kubernetes secrets is also not secure because they are not encrypted and only base36 encoded.</p> <p>There is a secure method to expose these secrets in EKS through the Secrets Store CSI Driver. </p> <p>The Secrets Store CSI Driver integrate with a secret store like AWS Secrets manager and mount the secrets as volume that can be accessed through your application code. This document describes how to set and use AWS Secrets Manager with EMR on EKS through the Secrets Store CSI Driver.</p>"},{"location":"security/docs/spark/secrets/#deploy-secrets-store-csi-drivers-and-aws-secrets-and-configuration-provider","title":"Deploy Secrets Store CSI Drivers and AWS Secrets and Configuration Provider","text":""},{"location":"security/docs/spark/secrets/#secrets-store-csi-drivers","title":"Secrets Store CSI Drivers","text":"<p>Configure EKS Cluster with <code>Secrets Store CSI Driver</code>. </p> <p>To learn more about AWS Secrets Manager CSI Driver you can refer to this link</p> <pre><code>helm repo add secrets-store-csi-driver \\\n  https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts\n\nhelm install -n kube-system csi-secrets-store \\\n  --set syncSecret.enabled=true \\\n  --set enableSecretRotation=true \\\n  secrets-store-csi-driver/secrets-store-csi-driver\n</code></pre> <p>Deploy the <code>AWS Secrets and Configuration Provider</code> to use AWS Secrets Manager</p>"},{"location":"security/docs/spark/secrets/#aws-secrets-and-configuration-provider","title":"AWS Secrets and Configuration Provider","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/aws/secrets-store-csi-driver-provider-aws/main/deployment/aws-provider-installer.yaml\n</code></pre>"},{"location":"security/docs/spark/secrets/#define-the-secretproviderclass","title":"Define the <code>SecretProviderClass</code>","text":"<p>The <code>SecretProviderClass</code> is how you present your secret in Kubernetes, below you find a definition of a <code>SecretProviderClass</code>.  There are few parameters that are important:</p> <ul> <li>The <code>provider</code> must be set to <code>aws</code>.</li> <li>The <code>objectName</code> must be the name of the secret you want to use as defined in AWS.  Here the secret is called <code>db-creds</code>.</li> <li>The <code>objectType</code> must be set to <code>secretsmanager</code>.</li> </ul> <pre><code>cat &gt; db-cred.yaml &lt;&lt; EOF\n\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: mysql-spark-secret\nspec:\n  provider: aws\n  parameters:\n    objects: |\n        - objectName: \"db-creds\"\n          objectType: \"secretsmanager\"\nEOF\n</code></pre> <pre><code>kubectl apply -f db-cred.yaml -n &lt;NAMESPACE&gt;\n</code></pre> <p>In the terminal apply the above command to create <code>SecretProviderClass</code>,  The <code>kubectl</code> command must include the namespace where your job will be executed. </p>"},{"location":"security/docs/spark/secrets/#pod-template","title":"Pod Template","text":"<p>In the executor podtemplate you should define it as follows to mount the secret. The example below show how you can define it. There are few points that are important to mount the secret:</p> <ul> <li><code>secretProviderClass</code>: this should have the same name as the one define above. In this case it is <code>mysql-spark-secret</code>.</li> <li><code>mountPath</code>: Is where the secret is going to be available to the pod. In this example it will be in <code>/var/secrets</code> When defining the <code>mountPath</code> make sure you do not specify the ones reserved by EMR on EKS as defined here. </li> </ul> <pre><code>apiVersion: v1\nkind: Pod\n\nspec:\n  containers:\n    - name: spark-kubernetes-executors\n      volumeMounts:\n        - mountPath: \"/var/secrets\"\n          name: mysql-cred\n          readOnly: true\n  volumes:\n      - name: mysql-cred\n        csi:\n          driver: secrets-store.csi.k8s.io\n          readOnly: true\n          volumeAttributes:\n            secretProviderClass: mysql-spark-secret\n</code></pre> <p>This podtemplate must be uploaded to S3 and referenced in the job submit command as shown below.</p> <p>Note You must make sure that the RDS instance or your Database allow traffic from the instances where your driver and executors pods are running.  </p>"},{"location":"security/docs/spark/secrets/#pyspark-code","title":"PySpark code","text":"<p>The example below shows pyspark code for connecting with a MySQL DB. The example assume the secret is stored in AWS secrets manager as defined above. The <code>username</code> is the <code>key</code> to retrieve the database <code>user</code> as stored in AWS Secrets Manager, and <code>password</code> is the <code>key</code> to retrieve the database password.</p> <p>It shows how you can retrieve the credentials from the mount point <code>/var/secrets/</code>.  The secret is stored in a file with the same name as it is defined in AWS in this case it is <code>db-creds</code>. This has been set in the podTemplate above.</p> <pre><code>from pyspark.sql import SparkSession\nimport json\n\nsecret_path = \"/var/secrets/db-creds\"\n\nf = open(secret_path, \"r\")\nmySecretDict = json.loads(f.read())\n\nspark = SparkSession.builder.getOrCreate()\n\nstr_jdbc_url=\"jdbc:&lt;DB endpoint&gt;\"\nstr_Query= &lt;QUERY&gt;\nstr_username=mySecretDict['username']\nstr_password=mySecretDict['password']\ndriver = \"com.mysql.jdbc.Driver\"\n\njdbcDF = spark.read \\\n    .format(\"jdbc\") \\\n    .option(\"url\", str_jdbc_url) \\\n    .option(\"driver\", driver)\\\n    .option(\"query\", str_Query) \\\n    .option(\"user\", str_username) \\\n    .option(\"password\", str_password) \\\n    .load()\n\njdbcDF.show()\n</code></pre>"},{"location":"security/docs/spark/secrets/#execute-the-job","title":"Execute the job","text":"<p>The command below can be used to run a job.</p> <p>Note: The supplied execution role MUST have access an IAM policy that allow it to access to the secret defined in <code>SecretProviderClass</code> above.  The IAM policy below shows the IAM actions that are needed.</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [ {\n        \"Effect\": \"Allow\",\n        \"Action\": [\"secretsmanager:GetSecretValue\", \"secretsmanager:DescribeSecret\"],\n        \"Resource\": [&lt;SECRET-ARN&gt;]\n    }]\n}\n</code></pre> <pre><code>    aws emr-containers start-job-run --virtual-cluster-id &lt;EMR-VIRTUAL-CLUSTER-ID&gt; --name spark-jdbc --execution-role-arn &lt;EXECUTION-ROLE-ARN&gt; --release-label emr-6.7.0-latest --job-driver '{\n    \"sparkSubmitJobDriver\": {\n    \"entryPoint\": \"&lt;S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE&gt;\",\n    \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1 --conf spark.jars=&lt;S3-URI-TO-MYSQL-JDBC-JAR&gt;\"\n    }\n    }' --configuration-overrides '{\n    \"applicationConfiguration\": [\n    {\n    \"classification\": \"spark-defaults\", \n    \"properties\": {\n    \"spark.hadoop.hive.metastore.client.factory.class\": \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n    \"spark.sql.catalogImplementation\": \"hive\",\n    \"spark.dynamicAllocation.enabled\":\"true\",\n    \"spark.dynamicAllocation.minExecutors\": \"8\",\n    \"spark.dynamicAllocation.maxExecutors\": \"40\",\n    \"spark.kubernetes.allocation.batch.size\": \"8\",\n    \"spark.dynamicAllocation.executorAllocationRatio\": \"1\",\n    \"spark.dynamicAllocation.shuffleTracking.enabled\": \"true\",\n    \"spark.dynamicAllocation.shuffleTracking.timeout\": \"300s\",\n    \"spark.kubernetes.driver.podTemplateFile\":&lt;S3-URI-TO-DRIVER-POD-TEMPLATE&gt;,\n    \"spark.kubernetes.executor.podTemplateFile\":&lt;S3-URI-TO-EXECUTOR-POD-TEMPLATE&gt;\n    }\n    }\n    ],\n    \"monitoringConfiguration\": {\n        \"persistentAppUI\": \"ENABLED\",\n        \"cloudWatchMonitoringConfiguration\": {\n            \"logGroupName\": \"/aws/emr-containers/\",\n            \"logStreamNamePrefix\": \"default\"\n        }\n    }\n    }'\n</code></pre>"},{"location":"storage/docs/spark/ebs/","title":"Mount EBS Volume to spark driver and executor pods","text":"<p>Amazon EBS volumes can be mounted on Spark driver and executor pods through static and dynamic provisioning. </p> <p>Using dynamically-created PVC to mount EBS volumes per pod in a Spark offers significant benefit in terms of performance, scalability, and ease of management. However, it also introduces complexities and potential costs if EBS create/attach/detach/delete operation throttles when over 5000 EBS volumes were generated by Spark pods. It needs to be carefully managed. It's important to weigh the pros and cons against your specific use case requirements and constraints to determine if this technique is suitable for your scale of Spark workloads.</p>"},{"location":"storage/docs/spark/ebs/#pros","title":"Pros","text":"<ul> <li>Scalability: As Spark scales up and down automatically during a job execution, dynamic PVCs allow storage to scale seamlessly with the number of executor pods. This ensures that each new executor gets the necessary storage without manual intervention.</li> <li>Optimized Storage Allocation: Dynamically provisioning PVCs allows you to allocate exactly the amount of storage needed for each Spark's pod. This prevents over-provisioning and ensures efficient use of resources, potentially reducing storage costs. </li> <li>Cost efficient: Only pay for the storage you actually use, which can be more cost-effective than pre-allocating large, static volumes.</li> <li>High IO Performance: By giving each executor its own EBS volume, you avoid I/O contention among executors. This leads to more predictable and higher performance, especially for I/O-intensive tasks.</li> <li>Data Locality: With each executor having its own volume, data is stored locally to the executor\u2019s pod. It can reduce data transfer latency.</li> <li>Resilience for Spot Interruption: With the feature of \"PVC Reuse\" offered by Spark, EBS can persist shuffle data throughout a job lifetime, even if a pod is terminated in case of Spot interruption. You avoid creating new volumes instead re-attach them to new pods, which provides a faster recovery from a node failure or interruption event. This improves your application resilience while running Spot instances to reduce your compute cost.</li> </ul>"},{"location":"storage/docs/spark/ebs/#cons","title":"Cons","text":"<ul> <li>Storage Costs: EBS volumes can be expensive, especially if EBS volumes were provisioned more than necessary, due to this bug or EBS CSI controller's scalability issue.  </li> <li>Resource Utilization: Inefficient use of storage resources can occur if each pod is allocated a large EBS volume but only uses a fraction of it.</li> <li>Attachment Latency &amp; Limit: Frequently attaching and detaching EBS volumes can introduce latency and potentially exceed EBS limit. For most instance types, only 26 extra volumes can be attached to a single Amazon EC2 instance. </li> </ul>"},{"location":"storage/docs/spark/ebs/#prerequisite","title":"Prerequisite","text":"<p>Amazon EBS CSI driver is installed on an EKS cluster. Use this comand to check if the driver exists:</p> <pre><code>kubectl get csidriver\n</code></pre>"},{"location":"storage/docs/spark/ebs/#static-provisioning","title":"Static Provisioning","text":""},{"location":"storage/docs/spark/ebs/#eks-admin-tasks","title":"EKS Admin Tasks","text":"<p>First, create your EBS volumes:</p> <pre><code>aws ec2 --region &lt;region&gt; create-volume --availability-zone &lt;availability zone&gt; --size 50\n{\n    \"AvailabilityZone\": \"&lt;availability zone&gt;\", \n    \"MultiAttachEnabled\": false, \n    \"Tags\": [], \n    \"Encrypted\": false, \n    \"VolumeType\": \"gp2\", \n    \"VolumeId\": \"&lt;vol -id&gt;\", \n    \"State\": \"creating\", \n    \"Iops\": 150, \n    \"SnapshotId\": \"\", \n    \"CreateTime\": \"2020-11-03T18:36:21.000Z\", \n    \"Size\": 50\n}\n</code></pre> <p>Create Persistent Volume(PV) that has the EBS volume created above hardcoded:</p> <pre><code>cat &gt; ebs-static-pv.yaml &lt;&lt; EOF\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: ebs-static-pv\nspec:\n  capacity:\n    storage: 5Gi\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: gp2\n  awsElasticBlockStore:\n    fsType: ext4\n    volumeID: &lt;vol -id&gt;\nEOF\n\nkubectl apply -f ebs-static-pv.yaml -n &lt;namespace&gt;\n</code></pre> <p>Create Persistent Volume Claim(PVC) for the Persistent Volume created above:</p> <pre><code>cat &gt; ebs-static-pvc.yaml &lt;&lt; EOF\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: ebs-static-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  volumeName: ebs-static-pv\nEOF\n\nkubectl apply -f ebs-static-pvc.yaml -n &lt;namespace&gt;\n</code></pre> <p>PVC - <code>ebs-static-pvc</code> can be used by spark developer to mount to the spark pod  </p> <p>NOTE: Pods running in EKS worker nodes can only attach to the EBS volume provisioned in the same AZ as the EKS worker node. Use node selectors to schedule pods on EKS worker nodes the specified AZ.</p>"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks","title":"Spark Developer Tasks","text":"<p>Request</p> <pre><code>cat &gt;spark-python-in-s3-ebs-static-localdir.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-ebs-static-localdir\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.15.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-fsx.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\": \"ebs-static-pvc\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\": \"/var/spark/spill/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\": \"false\",\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-ebs-static-localdir.json\n</code></pre> <p>Observed Behavior: When the job gets started, the pre-provisioned EBS volume is mounted to driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also you can verify the mount from the driver pod's spec.</p> <pre><code>kubectl get pod &lt;driver pod name&gt; -n &lt;namespace&gt; -o yaml --export\n</code></pre>"},{"location":"storage/docs/spark/ebs/#dynamic-provisioning","title":"Dynamic Provisioning","text":"<p>Dynamic Provisioning PVC/Volumes is supported for both Spark driver and executors for EMR versions &gt;= 6.3.0.</p>"},{"location":"storage/docs/spark/ebs/#eks-admin-tasks_1","title":"EKS Admin Tasks","text":"<p>Create a new \"gp3\" EBS Storage Class or use an existing one:</p> <pre><code>cat &gt;demo-gp3-sc.yaml &lt;&lt; EOF\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: demo-gp3-sc\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp3\nreclaimPolicy: Retain\nallowVolumeExpansion: true\nmountOptions:\n  - debug\nvolumeBindingMode: Immediate\nEOF\n\nkubectl apply -f demo-gp3-sc.yaml\n</code></pre>"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks_1","title":"Spark Developer Tasks","text":"<p>Request</p> <pre><code>cat &gt;spark-python-in-s3-ebs-dynamic-localdir.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-ebs-dynamic-localdir\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.15.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-fsx.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-1.options.claimName\": \"OnDemand\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-1.options.storageClass\": \"demo-gp3-sc\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-1.mount.path\":\"/data\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-1.mount.readOnly\": \"false\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-1.options.sizeLimit\": \"10Gi\",\n\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-1.options.claimName\":\"OnDemand\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-1.options.storageClass\": \"demo-gp3-sc\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-1.mount.path\": \"/data\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-1.mount.readOnly\": \"false\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-1.options.sizeLimit\": \"50Gi\",\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-ebs-dynamic-localdir.json\n</code></pre> <p>Observed Behavior: When the job gets started, an EBS volume is provisioned dynamically by the EBS CSI driver and mounted to Spark's driver and  executor pods. You can exec into the driver / executor container to verify that the EBS volume is mounted. Also, you can verify the mount from driver / executor pod spec.  </p> <pre><code># verify the EBS volume is mounted or not\nkubectl get pod &lt;driver pod name&gt; -n &lt;namespace&gt; -c spark-kubernetes-driver -- df -h\n\n# export the driver pod spec to a yaml file\nkubectl get pod &lt;driver pod name&gt; -n &lt;namespace&gt; -o yaml --export\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/","title":"EMR Containers integration with FSx for Lustre","text":"<p>Amazon EKS clusters provide the compute and ephemeral storage for Spark workloads. Ephemeral storage provided by EKS is allocated from the EKS worker node's disk storage and the lifecycle of the storage is bound by the lifecycle of the driver and executor pod.</p> <p>Need for durable storage: When multiple spark applications are executed as part of a data pipeline, there are scenarios where data from one spark application is passed to subsequent spark applications - in this case data can be persisted in S3. Alternatively, this data can also be persisted in FSx for Lustre. FSx for Lustre provides a fully managed, scalable, POSIX compliant native filesystem interface for the data in s3. With FSx, your torage is decoupled from your compute and has its own lifecycle. </p> <p>FSx for Lustre Volumes can be mounted on spark driver and executor pods through static and dynamic provisioning.</p> <p>Data used in the below example is from AWS Open data Registry</p>"},{"location":"storage/docs/spark/fsx-lustre/#fsx-for-lustre-posix-permissions","title":"FSx for Lustre POSIX permissions","text":"<p>When a Lustre filesystem is mounted to driver and executor pods, and if the S3 objects does not have required metadata, the mounted volume defaults  ownership of the file system to <code>root</code>. EMR on EKS executes the driver and executor pods with UID(999), GID (1000) and groups(1000 and 65534). In this scenario, the spark application has read only access to the mounted Lustre file system. Below are a few approaches that can be considered:</p>"},{"location":"storage/docs/spark/fsx-lustre/#tag-metadata-to-s3-object","title":"Tag Metadata to S3 object","text":"<p>Applications writing to S3 can tag the S3 objects with the metadata that FSx for Lustre requires.  </p> <p>Walkthrough: Attaching POSIX permissions when uploading objects into an S3 bucket provides a guided tutorial. FSx for Lustre will convert this tagged metadata to corresponding POSIX permissions when mounting Lustre file system to the driver and executor pods.       </p> <p>EMR on EKS spawns the driver and executor pods as non-root user(<code>UID -999, GID - 1000, groups - 1000, 65534</code>). To enable the spark application to write to the mounted file system, (UID - <code>999</code>) can be made as the <code>file-owner</code> and supplemental group <code>65534</code> be made as the <code>file-group</code>.</p> <p>For S3 objects that already exists with no metadata tagging, there can be a process that recursively tags all the S3 objects with the required metadata. Below is an example:   1. Create FSx for Lustre file system to the S3 prefix.   2. Create Persistent Volume and Persistent Volume claim for the created FSx for Lustre file system  3. Run a pod as root user with FSx for Lustre mounted with the PVC created in Step 2.    </p> <pre><code>```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: chmod-fsx-pod\n  namespace: test-demo\nspec:\n  containers:\n  - name: ownership-change\n    image: amazonlinux:2\n    command: [\"sh\", \"-c\", \"chown -hR +999:+65534 /data\"]\n    volumeMounts:\n    - name: persistent-storage\n      mountPath: /data\n  volumes:\n  - name: persistent-storage\n    persistentVolumeClaim:\n      claimName: fsx-static-root-claim\n```\n</code></pre> <p>Run a data repository task with import path and export path pointing to the same S3 prefix. This will export the POSIX permission from FSx for Lustre file system as metadata, that is tagged on S3 objects.</p> <p>Now that the S3 objects are tagged with metadata, the spark application with FSx for Lustre filesystem mounted will have write access.</p>"},{"location":"storage/docs/spark/fsx-lustre/#static-provisioning","title":"Static Provisioning","text":""},{"location":"storage/docs/spark/fsx-lustre/#provision-a-fsx-for-lustre-cluster","title":"Provision a FSx for Lustre cluster","text":"<p>FSx for Luster can also be provisioned through aws cli</p> <p>How to decide what type of FSx for Lustre file system you need ? Create a Security Group to attach to FSx for Lustre file system as below Points to Note: Security group attached to the EKS worker nodes is given access on port number 988, 1021-1023 in inbound rules. Security group specified when creating the FSx for Lustre filesystem is given access on port number 988, 1021-1023 in inbound rules.</p> <p>Fsx for Lustre Provisioning through aws cli </p> <pre><code>cat fsxLustreConfig.json &lt;&lt; EOF \n{\n    \"ClientRequestToken\": \"EMRContainers-fsxLustre-demo\", \n    \"FileSystemType\": \"LUSTRE\",\n    \"StorageCapacity\": 1200, \n    \"StorageType\": \"SSD\", \n    \"SubnetIds\": [\n        \"&lt;subnet-id&gt;\"\n    ], \n    \"SecurityGroupIds\": [\n        \"&lt;securitygroup-id&gt;\"\n    ], \n    \"LustreConfiguration\": {\n        \"ImportPath\": \"s3://&lt;s3 prefix&gt;/\", \n        \"ExportPath\": \"s3://&lt;s3 prefix&gt;/\", \n        \"DeploymentType\": \"PERSISTENT_1\", \n        \"AutoImportPolicy\": \"NEW_CHANGED\",\n        \"PerUnitStorageThroughput\": 200\n    }\n}\nEOF\n</code></pre> <p>Run the aws-cli command to create the FSx for Lustre filesystem as below.</p> <pre><code>aws fsx create-file-system --cli-input-json file:///fsxLustreConfig.json\n</code></pre> <p>Response is as below</p> <pre><code>{\n    \"FileSystem\": {\n        \"VpcId\": \"&lt;vpc id&gt;\", \n        \"Tags\": [], \n        \"StorageType\": \"SSD\", \n        \"SubnetIds\": [\n            \"&lt;subnet-id&gt;\"\n        ], \n        \"FileSystemType\": \"LUSTRE\", \n        \"CreationTime\": 1603752401.183, \n        \"ResourceARN\": \"&lt;fsx resource arn&gt;\", \n        \"StorageCapacity\": 1200, \n        \"LustreConfiguration\": {\n            \"CopyTagsToBackups\": false, \n            \"WeeklyMaintenanceStartTime\": \"7:11:30\", \n            \"DataRepositoryConfiguration\": {\n                \"ImportPath\": \"s3://&lt;s3 prefix&gt;\", \n                \"AutoImportPolicy\": \"NEW_CHANGED\", \n                \"ImportedFileChunkSize\": 1024, \n                \"Lifecycle\": \"CREATING\", \n                \"ExportPath\": \"s3://&lt;s3 prefix&gt;/\"\n            }, \n            \"DeploymentType\": \"PERSISTENT_1\", \n            \"PerUnitStorageThroughput\": 200, \n            \"MountName\": \"mvmxtbmv\"\n        }, \n        \"FileSystemId\": \"&lt;filesystem id&gt;\", \n        \"DNSName\": \"&lt;filesystem id&gt;.fsx.&lt;region&gt;.amazonaws.com\", \n        \"KmsKeyId\": \"arn:aws:kms:&lt;region&gt;:&lt;account&gt;:key/&lt;key id&gt;\", \n        \"OwnerId\": \"&lt;account&gt;\", \n        \"Lifecycle\": \"CREATING\"\n    }\n}\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks","title":"EKS admin tasks","text":"<ol> <li>Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre</li> <li>Install the FSx CSI Driver in EKS </li> <li>Configure Storage Class for FSx for Lustre</li> <li>Configure Persistent Volume and Persistent Volume Claim for FSx for Lustre</li> </ol> <p>FSx for Lustre file system is created as described above -Provision a FSx for Lustre cluster Once provisioned, a persistent volume - as specified below is created with a direct (hard-coded) reference to the created lustre file system. A Persistent Volume claim for this persistent volume will always use the same file system.</p> <pre><code>cat &gt;fsxLustre-static-pv.yaml &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: fsx-pv\nspec:\n  capacity:\n    storage: 1200Gi\n  volumeMode: Filesystem\n  accessModes:\n    - ReadWriteMany\n  mountOptions:\n    - flock\n  persistentVolumeReclaimPolicy: Recycle\n  csi:\n    driver: fsx.csi.aws.com\n    volumeHandle: &lt;filesystem id&gt;\n    volumeAttributes:\n      dnsname: &lt;filesystem id&gt;.fsx.&lt;region&gt;.amazonaws.com\n      mountname: mvmxtbmv\nEOF\n</code></pre> <pre><code>kubectl apply -f fsxLustre-static-pv.yaml\n</code></pre> <p>Now, a Persistent Volume Claim (PVC) needs to be created that references PV created above.</p> <pre><code>cat &gt;fsxLustre-static-pvc.yaml &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: fsx-claim\n  namespace: ns1\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: \"\"\n  resources:\n    requests:\n      storage: 1200Gi\n  volumeName: fsx-pv\nEOF\n</code></pre> <pre><code>kubectl apply -f fsxLustre-static-pvc.yaml -n &lt;namespace registered with EMR on EKS Virtual Cluster&gt;\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks","title":"Spark Developer Tasks","text":"<p>Now spark applications can use <code>fsx-claim</code> in their spark application config to mount the FSx for Lustre filesystem to driver and executor container volumes. </p> <pre><code>cat &gt;spark-python-in-s3-fsx.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-fsx\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-repartition-fsx.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n</code></pre> <pre><code>aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx.json\n</code></pre> <p>Expected Behavior: All spark jobs that are run with persistent volume claims as <code>fsx-claim</code> will mount to the statically created FSx for Lustre file system. </p> <p>Use case:</p> <ol> <li>A data pipeline consisting of 10 spark applications can all be mounted to the statically created FSx for Lustre file system and can write the intermediate output to a particular folder. The next spark job in the data pipeline that is dependent on this data can read from FSx for Lustre. Data that needs to be persisted beyond the scope of the data pipeline can be exported to S3 by creating data repository tasks</li> <li>Data that is used often by multiple spark applications can also be stored in FSx for Lustre for improved performance.</li> </ol>"},{"location":"storage/docs/spark/fsx-lustre/#dynamic-provisioning","title":"Dynamic Provisioning","text":"<p>A FSx for Lustre file system can be provisioned on-demand. A Storage-class resource is created and that provisions FSx for Lustre file system dynamically. A PVC is created and refers to the storage class resource that was created. Whenever a pod refers to the PVC, the storage class invokes the FSx for Lustre Container Storage Interface (CSI) to provision a Lustre file system on the fly dynamically. In this model,  FSx for Lustre of type <code>Scratch File Systems</code> is  provisioned.  </p>"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks_1","title":"EKS Admin Tasks","text":"<ol> <li>Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre</li> <li>Install the FSx CSI Driver in EKS</li> <li>Configure Storage Class for FSx for Lustre</li> <li>Configure Persistent Volume Claim(<code>fsx-dynamic-claim</code>) for FSx for Lustre.</li> </ol> <p>Create PVC for dynamic provisioning with <code>fsx-sc</code> storage class.  </p> <pre><code>cat &gt;fsx-dynamic-claim.yaml &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: fsx-dynamic-claim\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: fsx-sc\n  resources:\n    requests:\n      storage: 3600Gi\nEOF \n</code></pre> <pre><code>kubectl apply -f fsx-dynamic-pvc.yaml -n &lt;namespace registered with EMR on EKS Virtual Cluster&gt;\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks_1","title":"Spark Developer Tasks","text":"<pre><code>cat &gt;spark-python-in-s3-fsx-dynamic.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-fsx-dynamic\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-repartition-fsx.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.local.dir\":\"/var/spark/spill/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName\":\"fsx-dynamic-claim\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path\":\"/var/spark/spill/\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n</code></pre> <pre><code>aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx-dynamic.json\n</code></pre> <p>Expected Result: Statically provisioned FSx for Lustre is mounted to <code>/var/data/</code> as before for the driver pod. For all the executors a <code>SCRATCH 1</code> deployment type FSx for Lustre is provisioned on the fly dynamically by the Storage class that was created. There will be a latency before the first executor can start running - because the Lustre has to be created. Once it is created the same Lustre file system is mounted to all the executors. Also note - <code>\"spark.local.dir\":\"/var/spark/spill/\"</code> is used to force executor to use this folder mounted to Lustre for all spill and shuffle data. Once the spark job is completed, the Lustre file system is deleted or retained based on the PVC configuration. This dynamically created Lustre file system is mapped to a S3 path like the statically created filesystem. FSx-csi user guide</p>"},{"location":"storage/docs/spark/instance-store/","title":"Instance Store Volumes","text":"<p>When working with Spark workloads, it might be useful to use instances powered by SSD instance store volumes to improve the performance of your jobs. This storage is located on disks that are physically attached to the host computer and can provide better performance compared to traditional EBS volumes. In the context of Spark, this might be beneficial for wide transformations (e.g. JOIN, GROUP BY) that generate a significant amount of shuffle data that Spark persists on the local filesystem of the instances where the executors are running.</p> <p>In this document, we highlight two approaches to leverage NVMe disks in your workloads when using EMR on EKS. For a list of instances supporting NVMe disks, see Instance store volumes in the Amazon EC2 documentation.</p>"},{"location":"storage/docs/spark/instance-store/#mount-kubelet-pod-directory-on-nvme-disks","title":"Mount kubelet pod directory on NVMe disks","text":"<p>The kublet service manages the lifecycle of pod containers that are created using Kubernetes. When a pod is launched on an instance, an ephemeral volume is automatically created for the pod, and this volume is mapped in a subdirectory within the path <code>/var/lib/kubelet</code> of the host node. This volume folder exists for the lifetime of K8s pod, and it will be automatically deleted once the pod ceases to exist.</p> <p>In order to leverage NVMe disk attached to an EC2 node in our Spark application, we should perform the following actions during node bootstrap:</p> <ul> <li>Prepare the NVMe disks attached to the instance (format disks and create a partition)</li> <li>Mount the <code>/var/lib/kubelet/pods</code> path on the NVMe</li> </ul> <p>By doing this, all local files generated by your Spark job (blockmanager data, shuffle data, etc.) will be automatically written to NVMe disks. This way, you don't have to configure Spark volume path when launching the pod (driver or executor). This approach is easier to adopt because it doesn\u2019t require any additional configuration in your job. Besides, once the job is completed, all the data stored in ephemeral volumes will be automatically deleted when the EC2 instance is deleted.</p> <p>However, if you have multiple NVMe disks attached to the instance, you need to create RAID0 configuration of all the disks before mounting the <code>/var/lib/kubelet/pods</code> directory on the RAID partition. Without a RAID setup, it will not be possible to leverage all the disks capacity available on the node.</p> <p>The following example shows how to create a node group in your cluster using this approach. In order to prepare our NVMe disks, we can use the eksctl preBootstrapCommands definition while creating the node group. The script will perform the following actions:</p> <ul> <li>For instances with a single NVMe disk, format the filesystem, create a Linux partition (e.g. ext4, xfs, etc.)</li> <li>For instances with multiple NVMe disks, create a RAID 0 configuration across all available volumes</li> </ul> <p>Once the disks are formatted and ready to use, we will mount the folder /var/lib/kubelet/pods using the filesystem and setup correct permissions. Below, you can find an example of an eksctl configuration to create a managed node group using this approach.</p> <p>Example</p> <pre><code>apiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\n\nmetadata:\n  name: YOUR_CLUSTER_NAME\n  region: YOUR_REGION\n\nmanagedNodeGroups:\n  - name: ng-c5d-9xlarge\n    instanceType: c5d.9xlarge\n    desiredCapacity: 1\n    privateNetworking: true\n    subnets:\n      - YOUR_NG_SUBNET\n    preBootstrapCommands: # commands executed as root\n      - yum install -y mdadm nvme-cli\n      - nvme_disks=($(nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk -F'[[:space:]][[:space:]]+' '{print $1}')) &amp;&amp; [[ ${#nvme_disks[@]} -eq 1 ]] &amp;&amp; mkfs.ext4 -F ${nvme_disks[*]} &amp;&amp; systemctl stop docker &amp;&amp; mkdir -p /var/lib/kubelet/pods &amp;&amp; mount ${nvme_disks[*]} /var/lib/kubelet/pods &amp;&amp; chmod 750 /var/lib/docker &amp;&amp; systemctl start docker\n      - nvme_disks=($(nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk -F'[[:space:]][[:space:]]+' '{print $1}')) &amp;&amp; [[ ${#nvme_disks[@]} -ge 2 ]] &amp;&amp; mdadm --create --verbose /dev/md0 --level=0 --raid-devices=${#nvme_disks[@]} ${nvme_disks[*]} &amp;&amp; mkfs.ext4 -F /dev/md0 &amp;&amp; systemctl stop docker &amp;&amp; mkdir -p /var/lib/kubelet/pods &amp;&amp; mount /dev/md0 /var/lib/kubelet/pods &amp;&amp; chmod 750 /var/lib/docker &amp;&amp; systemctl start docker\n</code></pre> <p>Benefits</p> <ul> <li>No need to mount the disk using Spark configurations or pod templates</li> <li>Data generated by the application, will immediately be deleted at the pod termination. Data will be also purged in case of pod failures.</li> <li>One time configuration for the node group</li> </ul> <p>Cons</p> <ul> <li>If multiple jobs are allocated on the same EC2 instance, contention of disk resources will occur because it is not possible to allocate instance store volume resources across jobs</li> </ul>"},{"location":"storage/docs/spark/instance-store/#mount-nvme-disks-as-data-volumes","title":"Mount NVMe disks as data volumes","text":"<p>In this section, we\u2019re going to explicitly mount instance store volumes as the mount path in Spark configuration for drivers and executors</p> <p>As in the previous example, this script will automatically format the instance store volumes and create an xfs partition. The disks are then mounted in local folders called /spark_data_IDX where IDX is an integer that corresponds to the disk mounted.</p> <p>Example</p> <pre><code>apiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\n\nmetadata:\n  name: YOUR_CLUSTER_NAME\n  region: YOUR_REGION\n\nmanagedNodeGroups:\n  - name: ng-m5d-4xlarge\n    instanceType: m5d.4xlarge\n    desiredCapacity: 1\n    privateNetworking: true\n    subnets:\n      - YOUR_NG_SUBNET\n    preBootstrapCommands: # commands executed as root\n      - \"IDX=1;for DEV in /dev/nvme[1-9]n1;do mkfs.xfs ${DEV}; mkdir -p /spark_data_${IDX}; echo ${DEV} /spark_data_${IDX} xfs defaults,noatime 1 2 &gt;&gt; /etc/fstab; IDX=$((${IDX} + 1)); done\"\n      - \"mount -a\"\n      - \"chown 999:1000 /spark_data_*\"\n</code></pre> <p>In order to successfully use ephemeral volumes within Spark, you need to specify additional configurations. In addition to spark configuration, the mounted volume name should start with <code>spark-local-dir-</code>.</p> <p>Below an example configuration provided during the EMR on EKS job submission, that shows how to configure Spark to use 2 volumes as local storage for the job.</p> <p>Spark Configurations</p> <pre><code>{\n  \"name\": ....,\n  \"virtualClusterId\": ....,\n  \"executionRoleArn\": ....,\n  \"releaseLabel\": ....,\n  \"jobDriver\": ....,\n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\",\n        \"properties\": {\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.path\": \"/spark_data_1\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.readOnly\": \"false\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.options.path\": \"/spark_data_1\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.path\": \"/spark_data_2\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.readOnly\": \"false\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.options.path\": \"/spark_data_2\"\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Please note that for this approach it is required to specify the following configurations for each volume that you want to use. (IDX is a label to identify the volume mounted)</p> <pre><code># Mount path on the host node\nspark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.options.path\n\n# Mount path on the k8s pod\nspark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.path\n\n# (boolean) Should be defined as false to allow Spark to write in the path\nspark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.readOnly\n</code></pre> <p>Benefits</p> <ul> <li>You can allocate dedicated resources of instance store volumes across your Spark jobs (For example, lets take a scenario where an EC2 instance has two instance store volumes. If you run two spark jobs on this node, you can dedicate one volume per Spark job)</li> </ul> <p>Cons</p> <ul> <li>Additional configurations are required for Spark jobs to use instance store volumes. This approach can be error-prone if you don\u2019t control the instance types being used (for example, multiple node groups with different instance types). You can mitigate this issue by using k8s node selectors and specify instance type in your spark configuraiton: spark.kubernetes.node.selector.node.kubernetes.io/instance-type</li> <li>Data created on the volumes is automatically deleted once the job is completed and instance is terminated. However, you need to extra measures to delete the data on instance store volumes if EC2 instance is re-used or is not terminated.</li> </ul>"},{"location":"submit-applications/docs/spark/multi-arch-image/","title":"Build a Multi-architecture Docker Image Supporting arm64 &amp; amd64","text":""},{"location":"submit-applications/docs/spark/multi-arch-image/#pre-requisites","title":"Pre-requisites","text":"<p>We can complete all the steps either from a local desktop or using AWS Cloud9.  If you\u2019re using AWS Cloud9, follow the instructions in the \"Setup AWS Cloud9\" to create and configure the environment first, otherwise skip to the next section.</p>"},{"location":"submit-applications/docs/spark/multi-arch-image/#setup-aws-cloud9","title":"Setup AWS Cloud9","text":"<p>AWS Cloud9 is a cloud-based IDE that lets you write, run, and debug your code via just a browser. AWS Cloud9 comes preconfigured with some of AWS dependencies we require to build our application, such ash the AWS CLI tool.</p>"},{"location":"submit-applications/docs/spark/multi-arch-image/#1-create-a-cloud9-instance","title":"1. Create a Cloud9 instance","text":"<p>Instance type - Create an AWS Cloud9 environment from the AWS Management Console with an instance type of <code>t3.small or larger</code>. In our example, we used <code>m5.xlarge</code> for adequate memory and CPU to compile and build a large docker image. </p> <p>VPC - Follow the launch wizard and provide the required name. To interact with an existing EKS cluster in the same region later on, recommend to use the same VPC to your EKS cluster in the Cloud9 environment. Leave the remaining default values as they are. </p> <p>Storage size - You must increase the Cloud9's EBS volume size (pre-attached to your AWS Cloud9 instance) to 30+ GB, because the default disk space ( 10 GB with ~72% used) is not enough for building a container image. Refer to Resize an Amazon EBS volume used by an environment document, download the script <code>resize.sh</code> to your cloud9 environment.</p> <pre><code>touch resize.sh\n# Double click the file name in cloud9\n# Copy and paste the content from the official document to your file, save and close it\n</code></pre> <p>Validate the disk size is 10GB currently:</p> <pre><code>admin:~/environment $ df -h\nFilesystem        Size  Used Avail Use% Mounted on\ndevtmpfs          4.0M     0  4.0M   0% /dev\ntmpfs             951M     0  951M   0% /dev/shm\ntmpfs             381M  5.3M  376M   2% /run\n/dev/nvme0n1p1     10G  7.2G  2.9G  72% /\ntmpfs             951M   12K  951M   1% /tmp\n/dev/nvme0n1p128   10M  1.3M  8.7M  13% /boot/efi\ntmpfs             191M     0  191M   0% /run/user/1000\n</code></pre> <p>Increase the disk size:</p> <pre><code>bash resize.sh 30\n</code></pre> <pre><code>admin:~/environment $ df -h\nFilesystem        Size  Used Avail Use% Mounted on\ndevtmpfs          4.0M     0  4.0M   0% /dev\ntmpfs             951M     0  951M   0% /dev/shm\ntmpfs             381M  5.3M  376M   2% /run\n/dev/nvme0n1p1     30G  7.3G   23G  25% /\ntmpfs             951M   12K  951M   1% /tmp\n/dev/nvme0n1p128   10M  1.3M  8.7M  13% /boot/efi\ntmpfs             191M     0  191M   0% /run/user/1000\n</code></pre>"},{"location":"submit-applications/docs/spark/multi-arch-image/#2-install-docker-and-buildx-if-required","title":"2. Install Docker and Buildx if required","text":"<ul> <li> <p>Installing Docker - a Cloud9 EC2 instance comes with a Docker daemon pre-installed. Outside of the Cloud9, your environment may or may not need to install Docker. If needed, follow the instructions in the Docker Desktop page to install.</p> </li> <li> <p>Installing Buildx (pre-installed in Cloud9) - To build a single multi-arch Docker image (x86_64 and arm64), we may or may not need to install an extra Buildx plugin that extends the Docker CLI to support the multi-architecture feature. Docker Buildx is installed by default with a Docker Engine since version 23.0+. For an earlier version, it requires you grab a binary from GitHub repository and install it manually, or get it from a separate package. See docker/buildx README for more information. </p> </li> </ul> <p>Once the buildx CLI is available, we can create a builder instance which gives access to the new multi-architecture features.You only have to perform this task once.</p> <pre><code># create a builder\ndocker buildx create --name mybuilder --use\n# boot up the builder and inspect\ndocker buildx inspect --bootstrap\n\n\n# list builder instances\n# the asterisk (*) next to a builder name indicates the selected builder.\ndocker buildx ls\n</code></pre> <p>If your builder doesn't support QEMU, only limited platform types are supported as below. For example, the current builder instance created in Cloud9 doesn't support QEMU, so we can't build the docker image for the arm64 CPU type yet. </p> <pre><code>NAME/NODE       DRIVER/ENDPOINT      STATUS   BUILDKIT PLATFORMS\ndefault        docker\ndefault       default              running  v0.11.6  linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/386\nmybuilder *    docker-container\nmy_builder0   default              running  v0.11.6  linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/386\n</code></pre> <ul> <li>Installing QEMU for Cloud9 - Building multi-platform images under emulation with QEMU is the easiest way to get started if your builder already supports it. However, AWS Cloud9 isn't preconfigured with the binfmt_misc support. We must install compiled QEMU binaries.  The installations can be easily done via the docker run CLI:</li> </ul> <pre><code> docker run --privileged --rm tonistiigi/binfmt --install all\n</code></pre> <p>List the builder instance again. Now we see the full list of platforms are supported,including arm-based CPU:</p> <pre><code>docker buildx ls\n\nNAME/NODE     DRIVER/ENDPOINT             STATUS   BUILDKIT PLATFORMS\nmybuilder *   docker-container                              \n  mybuilder20 unix:///var/run/docker.sock running  v0.13.2  linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/mips64le, linux/mips64, linux/arm/v7, linux/arm/v6     \ndefault       docker                                        \n  default     default                     running  v0.12.5  linux/amd64, linux/amd64/v2, linux/amd64/v3, linux/amd64/v4, linux/386, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/mips64le, linux/mips64, linux/arm/v7, linux/arm/v6\n</code></pre>"},{"location":"submit-applications/docs/spark/multi-arch-image/#build-a-docker-image-supporting-multi-arch","title":"Build a docker image supporting multi-arch","text":"<p>In this example, we will create a spark-benchmark-utility container image. We are going to reuse the source code from the EMR on EKS benchmark Github repo.</p>"},{"location":"submit-applications/docs/spark/multi-arch-image/#1-download-the-source-code-from-the-github","title":"1. Download the source code from the Github:","text":"<pre><code>git clone https://github.com/aws-samples/emr-on-eks-benchmark.git\ncd emr-on-eks-benchmark\n</code></pre>"},{"location":"submit-applications/docs/spark/multi-arch-image/#2-setup-required-environment-variables","title":"2. Setup required environment variables","text":"<p>We will build an image to test EMR 6.15's performance. The equivalent versions are Spark 3.4.1 and Hadoop 3.3.4. Change them accordingly if needed.</p> <pre><code>export SPARK_VERSION=3.4.1\nexport HADOOP_VERSION=3.3.6\n</code></pre> <p>Log in to your own Amazon ECR registry: </p> <pre><code>export AWS_REGION=us-east-1\nexport ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)\nexport ECR_URL=$ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com\n\naws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_URL\n</code></pre>"},{"location":"submit-applications/docs/spark/multi-arch-image/#3-build-oss-spark-base-image-if-required","title":"3. Build OSS Spark base image if required","text":"<p>If you want to test open-source Apache Spark's performance, build a base Spark image first. Otherwise skip this step.</p> <pre><code>docker buildx build --platform linux/amd64,linux/arm64 \\\n-t $ECR_URL/spark:${SPARK_VERSION}_hadoop_${HADOOP_VERSION} \\\n-f docker/hadoop-aws-3.3.1/Dockerfile \\\n--build-arg HADOOP_VERSION=${HADOOP_VERSION} --build-arg SPARK_VERSION=${SPARK_VERSION} --push .\n</code></pre>"},{"location":"submit-applications/docs/spark/multi-arch-image/#4-get-emr-spark-base-image-from-aws","title":"4. Get EMR Spark base image from AWS","text":"<pre><code>export SRC_ECR_URL=755674844232.dkr.ecr.us-east-1.amazonaws.com\naws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin $SRC_ECR_URL\n\ndocker pull $SRC_ECR_URL/spark/emr-6.15.0:latest\n</code></pre>"},{"location":"submit-applications/docs/spark/multi-arch-image/#5-build-the-benchmark-utility-image","title":"5. Build the Benchmark Utility image","text":"<p>Build and push the docker image based the OSS Spark engine built before (Step #3):</p> <pre><code>docker buildx build --platform linux/amd64,linux/arm64 \\\n-t $ECR_URL/eks-spark-benchmark:${SPARK_VERSION}_hadoop_${HADOOP_VERSION} \\\n-f docker/benchmark-util/Dockerfile \\\n--build-arg SPARK_BASE_IMAGE=$ECR_URL/spark:${SPARK_VERSION}_hadoop_${HADOOP_VERSION} \\\n--push .\n</code></pre> <p>Build and push the benchmark docker image based EMR's Spark runtime (Step #4):</p> <pre><code>docker buildx build --platform linux/amd64,linux/arm64 \\\n-t $ECR_URL/eks-spark-benchmark:emr6.15 \\\n-f docker/benchmark-util/Dockerfile \\\n--build-arg SPARK_BASE_IMAGE=$SRC_ECR_URL/spark/emr-6.15.0:latest \\\n--push .\n</code></pre>"},{"location":"submit-applications/docs/spark/multi-arch-image/#benchmark-application-based-on-the-docker-images-built","title":"Benchmark application based on the docker images built","text":"<p>Based on the mutli-arch docker images built previously, now you can start to run benchmark applications on both intel and arm-based CPU nodes.</p> <p>In Cloud9, the following extra steps are required to configure the environment, before you can submit the applications. </p> <ol> <li> <p>Install kkubectl/helm/eksctl CLI tools. refer to this sample scirpt</p> </li> <li> <p>Modify the IAM role attached to the Cloud9 EC2 instance, allowing it has enough privilege to assume an EKS cluster's admin role or has the permission to submit jobs against the EKS cluster.</p> </li> <li> <p>Upgrade AWS CLI and turn off the AWS managed temporary credentials in Cloud9:</p> </li> </ol> <pre><code>curl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"awscliv2.zip\"\nunzip awscliv2.zip\nsudo ./aws/install --update\n/usr/local/bin/aws cloud9 update-environment  --environment-id $C9_PID --managed-credentials-action DISABLE\nrm -vf ${HOME}/.aws/credentials\n</code></pre> <ol> <li>Connect to the EKS cluster</li> </ol> <pre><code># a sample connection string\naws eks update-kubeconfig --name YOUR_EKS_CLUSTER_NAME --region us-east-1 --role-arn arn:aws:iam::ACCOUNTID:role/SparkOnEKS-iamrolesclusterAdmin-xxxxxx\n\n# validate the connection\nkubectl get svc\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/","title":"Pyspark Job submission","text":"<p>Python interpreter is bundled in the EMR containers spark image that is used to run the spark job.Python code and dependencies can be provided with the below options.</p>"},{"location":"submit-applications/docs/spark/pyspark/#python-code-self-contained-in-a-single-py-file","title":"Python code self contained in a single .py file","text":"<p>To start with, in the simplest scenario - the example below shows how to submit a pi.py file that is self-contained and doesn't need any other dependencies.    </p>"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-s3","title":"Python file from S3","text":"<p>Request  pi.py used in the below request payload is from spark examples</p> <pre><code>cat &gt; spark-python-in-s3.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-image\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/pi.py\", \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-mounted-volume","title":"Python file from mounted volume","text":"<p>In the below example - pi.py is placed in a mounted volume. FSx for Lustre filesystem is mounted as a Persistent Volume on the driver pod under <code>/var/data/</code> and will be referenced by <code>local://</code> file prefix. For more information on how to mount FSx for lustre - EMR-Containers-integration-with-FSx-for-Lustre</p> <p>This approach can be used to provide spark application code and dependencies for execution. Persistent Volume mounted  to the driver and executor pods lets you access the application code and dependencies with <code>local://</code> prefix. </p> <pre><code>cat &gt; spark-python-in-FSx.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-FSx\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"local:///var/data/FSxLustre-pi.py\", \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-Fsx.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#python-code-with-python-dependencies","title":"Python code with python dependencies","text":"<p>Info</p> <p>boto3 will only work with 'Bundled as a .pex file'  or with 'Custom docker image'</p>"},{"location":"submit-applications/docs/spark/pyspark/#list-of-py-files","title":"List of .py files","text":"<p>This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all the transitive dependencies.  </p> <pre><code>cat &gt; py-files-pi.py &lt;&lt;EOF\nfrom __future__ import print_function\n\nimport sys\nfrom random import random\nfrom operator import add\n\nfrom pyspark.sql import SparkSession\nfrom pyspark import SparkContext\n\nimport dependentFunc\n\nif __name__ == \"__main__\":\n    \"\"\"\n        Usage: pi [partitions]\n    \"\"\"\n    spark = SparkSession.builder.getOrCreate()\n    sc = spark.sparkContext\n    partitions = int(sys.argv[1]) if len(sys.argv) &gt; 1 else 2\n    n = 100000 * partitions\n\n    def f(_):\n        x = random() * 2 - 1\n        y = random() * 2 - 1\n        return 1 if x ** 2 + y ** 2 &lt;= 1 else 0\n\n    count = spark.sparkContext.parallelize(range(1, n + 1), partitions).map(f).reduce(add)\n    dependentFunc.message()\n    print(\"Pi is roughly %f\" % (4.0 * count / n))\n\n    spark.stop()\n\n  EOF\n</code></pre> <pre><code>cat &gt; dependentFunc.py &lt;&lt;EOF\ndef message():\n  print(\"Printing from inside the dependent python file\")\n\nEOF\n</code></pre> <p>Upload dependentFunc.py and py-files-pi.py to s3  </p> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-files &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-files\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/dependentFunc.py --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-files.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-zip-file","title":"Bundled as a zip file","text":"<p>In this approach all the dependent python files are bundled as a zip file. Each folder should have <code>__init__.py</code> file as documented in  zip python dependencies. Zip should be done at the top folder level and using the -r option.</p> <pre><code>zip -r pyspark-packaged-dependency-src.zip . \n  adding: dependent/ (stored 0%)\n  adding: dependent/__init__.py (stored 0%)\n  adding: dependent/dependentFunc.py (deflated 7%)\n</code></pre> <p>dependentFunc.py from earlier example has been bundled as  pyspark-packaged-dependency-src.zip. Upload this file to a S3 location</p> <pre><code>cat &gt; py-files-zip-pi.py &lt;&lt;EOF\nfrom __future__ import print_function\n\nimport sys\nfrom random import random\nfrom operator import add\n\nfrom pyspark.sql import SparkSession\nfrom pyspark import SparkContext\n\n**from dependent import dependentFunc**\n\nif __name__ == \"__main__\":\n    \"\"\"\n        Usage: pi [partitions]\n    \"\"\"\n    spark = SparkSession.builder.getOrCreate()\n    sc = spark.sparkContext\n    partitions = int(sys.argv[1]) if len(sys.argv) &gt; 1 else 2\n    n = 100000 * partitions\n\n    def f(_):\n        x = random() * 2 - 1\n        y = random() * 2 - 1\n        return 1 if x ** 2 + y ** 2 &lt;= 1 else 0\n\n    count = spark.sparkContext.parallelize(range(1, n + 1), partitions).map(f).reduce(add)\n    dependentFunc.message()\n    print(\"Pi is roughly %f\" % (4.0 * count / n))\n\n    spark.stop()\n  EOF\n</code></pre> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-zip.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-zip\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-zip-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/pyspark-packaged-dependency-src.zip --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-zip.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-egg-file","title":"Bundled as a .egg file","text":"<p>Create a folder structure as in the below screenshot with the code from the previous example - <code>py-files-zip-pi.py, dependentFunc.py</code> </p> <p>Steps to create .egg file</p> <pre><code>cd /pyspark-packaged-example\npip install setuptools\npython setup.py bdist_egg\n</code></pre> <p>Upload <code>dist/pyspark_packaged_example-0.0.3-py3.8.egg</code> to a S3 location  </p> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-egg.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-egg\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-zip-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/pyspark_packaged_example-0.0.3-py3.8.egg --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-egg.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-whl-file","title":"Bundled as a .whl file","text":"<p>Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py  </p> <p>Steps to create .whl file</p> <pre><code>cd /pyspark-packaged-example\n`pip install wheel`\npython setup.py bdist_wheel\n</code></pre> <p>Upload <code>dist/pyspark_packaged_example-0.0.3-py3-none-any.whl</code> to a s3 location</p> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-wheel.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-wheel\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-zip-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/pyspark_packaged_example-0.0.3-py3-none-any.whl --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-wheel.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-pex-file","title":"Bundled as a .pex file","text":"<p>pex is a library for generating .pex (Python EXecutable) files which are executable Python environments.PEX files can be created as below</p> <pre><code>docker run -it -v $(pwd):/workdir python:3.7.9-buster /bin/bash #python 3.7.9 is installed in EMR 6.1.0\npip3 install pex\npex --python=python3 --inherit-path=prefer -v numpy -o numpy_dep.pex\n</code></pre> <p>To read more about PEX: PEX PEX documentation Tips on PEX pex packaging for pyspark </p> <p>Approach 1: Using Persistent Volume - FSx for Lustre cluster</p> <p>Upload <code>numpy_dep.pex</code> to a s3 location that is mapped to a FSx for Lustre cluster. <code>numpy_dep.pex</code> can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod. Request: <code>kmeans.py</code> used in the below request is from spark examples</p> <pre><code>cat &gt; spark-python-in-s3-pex-fsx.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-pex-fsx\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/kmeans.py\",\n      \"entryPointArguments\": [\n        \"s3://&lt;s3 prefix&gt;/kmeans_data.txt\",\n        \"2\",\n        \"3\"\n       ], \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.pyspark.pythonVersion\":\"3\",\n          \"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\",\n          \"spark.executorEnv.PEX_ROOT\":\"./tmp\",\n          \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\",\n          \"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\",\n          \"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\",\n          \"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\",\n          \"spark.executorEnv.PEX_PYTHON\":\"python3\",\n          \"spark.pyspark.driver.python\":\"/var/data/numpy_dep.pex\",\n          \"spark.pyspark.python\":\"/var/data/numpy_dep.pex\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": { \n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\n\naws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-fsx.json\n</code></pre> <p>Approach 2: Using Custom Pod Templates</p> <p>Upload <code>numpy_dep.pex</code> to a s3 location. Create custom pod templates for driver and executor pods. Custom pod templates allows running a command through initContainers before the main application container is created. In this case, the command will download the <code>numpy_dep.pex</code> file to the <code>/tmp/numpy_dep.pex</code> path of the driver and executor pods.</p> <p>Note: This approach is only supported for release image 5.33.0 and later or 6.3.0 and later.</p> <p>Sample driver pod template YAML file:</p> <pre><code>cat &gt; driver_pod_tenplate.yaml &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nspec:\n containers:\n   - name: spark-kubernetes-driver\n initContainers: \n   - name: my-init-container\n     image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla\n     volumeMounts:\n       - name: temp-data-dir\n         mountPath: /tmp\n     command:\n       - sh\n       - -c\n       - aws s3api get-object --bucket &lt;s3-bucket&gt; --key &lt;s3-key-prefix&gt;/numpy_dep.pex /tmp/numpy_dep.pex &amp;&amp; chmod u+x /tmp/numpy_dep.pex\nEOF\n</code></pre> <p>Sample executor pod template YAML file:</p> <pre><code>cat &gt; executor_pod_tenplate.yaml &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: spark-kubernetes-executor\n  initContainers: \n    - name: my-init-container\n      image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla\n      volumeMounts:\n        - name: temp-data-dir\n          mountPath: /tmp\n      command:\n        - sh\n        - -c\n        - aws s3api get-object --bucket &lt;s3-bucket&gt; --key &lt;s3-key-prefix&gt;/numpy_dep.pex /tmp/numpy_dep.pex &amp;&amp; chmod u+x /tmp/numpy_dep.pex\nEOF\n</code></pre> <p>Replace initContainer's <code>image</code> with the respective release label's container image. In this case we are using the image of release <code>emr-5.33.0-latest</code>. Upload the driver and executor custom pod templates to S3</p> <p>Request: <code>kmeans.py</code> used in the below request is from spark examples</p> <pre><code>cat &gt; spark-python-in-s3-pex-pod-templates.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-pex-pod-templates\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-5.33.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/kmeans.py\",\n      \"entryPointArguments\": [\n        \"s3://&lt;s3 prefix&gt;/kmeans_data.txt\",\n        \"2\",\n        \"3\"\n       ], \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.pyspark.pythonVersion\":\"3\",\n          \"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\",\n          \"spark.executorEnv.PEX_ROOT\":\"./tmp\",\n          \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\",\n          \"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\",\n          \"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\",\n          \"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\",\n          \"spark.executorEnv.PEX_PYTHON\":\"python3\",\n          \"spark.pyspark.driver.python\":\"/tmp/numpy_dep.pex\",\n          \"spark.pyspark.python\":\"/tmp/numpy_dep.pex\",\n          \"spark.kubernetes.driver.podTemplateFile\": \"s3://&lt;s3-prefix&gt;/driver_pod_template.yaml\",\n          \"spark.kubernetes.executor.podTemplateFile\": \"s3://&lt;s3-prefix&gt;/executor_pod_template.yaml\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": { \n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\n\naws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-pod-templates.json\n</code></pre> <p>Point to Note: PEX files don\u2019t have the python interpreter bundled with it. Using the PEX env variables, we pass in the python interpreter installed in the spark driver and executor docker image.</p> <p>pex vs conda-pack A pex file contain only dependent Python packages but not a Python interpreter in it while a conda-pack environment has a Python interpreter as well, so with the same Python packages a conda-pack environment is much larger than a pex file. A conda-pack environment is a tar.gz file and need to be decompressed before being used while a pex file can be used directly. If a Python interpreter exists, pex is a better option than conda-pack. However, conda-pack is the ONLY CHOICE if you need a specific version of Python interpreter which does not exist and you do not have permission to install one (e.g., when you need to use a specific version of Python interpreter with an enterprise PySpark cluster). If the pex file or conda-pack environment needs to be distributed to machines on demand, there are some overhead before running your application. With the same Python packages, a conda-pack environment has large overhead/latency than the pex file as the conda-pack environment is usually much larger and need to be decompressed before being used.</p> <p>For more information - Tips on PEX </p>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-targz-file-with-conda-pack","title":"Bundled as a tar.gz file with conda-pack","text":"<p>conda-pack for spark Install conda through Miniconda Open a new terminal and execute the below commands</p> <pre><code>conda create -y -n example python=3.5 numpy\nconda activate example\npip install conda-pack\nconda pack -f -o numpy_environment.tar.gz\n</code></pre> <p>Upload <code>numpy_environment.tar.gz</code> to a s3 location that is mapped to a FSx for Lustre cluster. <code>numpy_environment.tar.gz</code> can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod.Alternatively, S3 path for <code>numpy_environment.tar.gz</code> can also be passed using --py-files </p> <p>Request:</p> <pre><code>{\n  \"name\": \"spark-python-in-s3-conda-fsx\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/kmeans.py\",\n      \"entryPointArguments\": [\n        \"s3://&lt;s3 prefix&gt;/kmeans_data.txt\",\n        \"2\",\n        \"3\"\n       ], \n       \"sparkSubmitParameters\": \"--verbose --archives /var/data/numpy_environment.tar.gz#environment --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.executor.instances\": \"3\",\n          \"spark.dynamicAllocation.enabled\":\"false\",\n          \"spark.files\":\"/var/data/numpy_environment.tar.gz#environment\",\n          \"spark.kubernetes.pyspark.pythonVersion\":\"3\",\n          \"spark.pyspark.driver.python\":\"./environment/bin/python\",\n          \"spark.pyspark.python\":\"./environment/bin/python\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\n</code></pre> <p>The above request doesn't work with spark on kubernetes</p>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-virtual-env","title":"Bundled as virtual env","text":"<p>Warning</p> <p>This will not work with spark on kubernetes</p> <p>This feature only works with YARN - cluster mode In this implementation for YARN - the dependencies will be installed from the repository for every driver and executor. This might not be a more scalable model as per SPARK-25433. Recommended solution is to pass in the dependencies as PEX file.</p>"},{"location":"submit-applications/docs/spark/pyspark/#custom-docker-image","title":"Custom docker image","text":"<p>See the details in the official documentation.  </p> <p>Dockerfile</p> <pre><code>FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0\nUSER root\nRUN pip3 install boto3\nUSER hadoop:hadoop\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#python-code-with-java-dependencies","title":"Python code with java dependencies","text":""},{"location":"submit-applications/docs/spark/pyspark/#list-of-packages","title":"List of packages","text":"<p>Warning</p> <p>This will not work with spark on kubernetes</p> <p>This feature only works with YARN - cluster mode</p> <p>kafka integration example</p> <pre><code>./bin/spark-submit --packages org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#list-of-jar-files","title":"List of .jar files","text":"<p>This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all the transitive dependencies.</p> <p>How to find all the .jar files which belongs to given package?</p> <ol> <li>Go to Maven Repository</li> <li>Search for the package name</li> <li>Select the matching Spark and Scala version</li> <li>Copy the URL of the jar file</li> <li>Copy the URL of the jar file of all compile dependencies</li> </ol> <p>Request:</p> <pre><code>cat &gt; Spark-Python-with-jars.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-with-jars\",\n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\",\n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\",\n  \"releaseLabel\": \"emr-6.2.0-latest\",\n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/pi.py\",\n      \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar,https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar --conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\"\n    }\n  },\n  \"configurationOverrides\": {\n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\",\n        \"logStreamNamePrefix\": \"demo\"\n      },\n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-with-jars.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#custom-docker-image_1","title":"Custom docker image","text":"<p>See the basics in the official documentation.  </p> <p>Approach 1: List of .jar files </p> <p>This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all the transitive dependencies.</p> <p>How to find all the .jar files which belongs to given package?</p> <ol> <li>Go to Maven Repository</li> <li>Search for the package name</li> <li>Select the matching Spark and Scala version</li> <li>Copy the URL of the jar file</li> <li>Copy the URL of the jar file of all compile dependencies</li> </ol> <p>Dockerfile</p> <pre><code>FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0\n\nUSER root\n\nARG JAR_HOME=/usr/lib/spark/jars/\n\n# Kafka\nADD https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar $JAR_HOME\n\nRUN chmod -R +r  /usr/lib/spark/jars\n\nUSER hadoop:hadoop\n</code></pre> <p>Observed Behavior: Spark automatically installs all the .jar files from <code>/usr/lib/spark/jars/</code> directory. In Dockerfile we are adding these  file as root user and these file will get <code>-rw-------</code> permission while the original files have <code>-rw-r--r--</code> permission.  EMR on EKS uses hadoop:hadoop to run spark jobs and files with <code>-rw-------</code> permission are hidden from this user and can  not be imported. To make these file readable for all the users run the following command <code>chmod -R +r /usr/lib/spark/jars</code> and the files will have <code>-rw-r--r--</code> permission.</p> <p> Approach 2: List of packages </p> <p>This approach is a resource intensive (min 1vCPU, 2GB RAM) solution, because it will run a dummy spark job. Scale your local or CI/CD resources according to it. </p> <p>Dockerfile</p> <pre><code>FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0\n\nUSER root\n\nARG KAFKA_PKG=\"org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2\"\n\nRUN spark-submit run-example --packages $KAFKA_PKG --deploy-mode=client --master=local[1] SparkPi\nRUN mv /root/.ivy2/jars/* /usr/lib/spark/jars/\n\nUSER hadoop:hadoop\n</code></pre> <p>Observed Behavior:  Spark runs ivy to get all of its dependencies (packages) when <code>--packages</code> are defined in the submit command. We can run a \"dummy\" spark job to make spark downloads its packages. These .jars are saved in <code>/root/.ivy2/jars/</code> which  we can move to <code>/usr/lib/spark/jars/</code> for further use. These jars having <code>-rw-r--r--</code> permission and does not require further modifications. The advantage of this method is ivy download the dependencies of the package as well, and we needed to specify only  <code>org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2</code> instead of 5 jars files above.</p>"},{"location":"submit-applications/docs/spark/pyspark/#import-of-dynamic-modules-pyd-so","title":"Import of Dynamic Modules (.pyd, .so)","text":"<p>Import of dynamic modules(.pyd, .so) is disallowed when bundled as a zip </p> <p>Steps to create a .so file example.c</p> <pre><code>/* File : example.c */\n\n #include \"example.h\"\n unsigned int add(unsigned int a, unsigned int b)\n {\n    printf(\"\\n Inside add function in C library \\n\");\n    return (a+b);\n }\n</code></pre> <p>example.h</p> <pre><code>/* File : example.h */\n#include&lt;stdio.h&gt;\n extern unsigned int add(unsigned int a, unsigned int b);\n</code></pre> <pre><code>gcc  -fPIC -Wall -g -c example.c\ngcc -shared -fPIC -o libexample.so example.o\n</code></pre> <p>Upload <code>libexample.so</code> to a S3 location.</p> <p>pyspark code to be executed - py_c_call.py</p> <pre><code>import sys\nimport os\n\nfrom ctypes import CDLL\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"py-c-so-example\")\\\n        .getOrCreate()\n\n    basedir = os.path.abspath(os.path.dirname(__file__))\n    libpath = os.path.join(basedir, 'libexample.so')\n    sum_list = CDLL(libpath)\n    data = [(1,2),(2,3),(5,6)]\n    columns=[\"a\",\"b\"]\n    df = spark.sparkContext.parallelize(data).toDF(columns)\n    df.withColumn('total', sum_list.add(df.a,df.b)).collect()\n    spark.stop()\n</code></pre> <p>Request: </p> <pre><code>cat &gt; spark-python-in-s3-Clib.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-Clib\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py_c_call.py\", \n       \"sparkSubmitParameters\": \"--files s3://&lt;s3 prefix&gt;/libexample.so --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-Clib.json\n</code></pre> <p>Configuration of interest: <code>--files s3://&lt;s3 prefix&gt;/libexample.so</code> distributes the <code>libexample.so</code> to the working directory of all executors. Dynamic modules(.pyd, .so) can also be imported by bundling within  .egg (SPARK-6764), .whl and .pex files.</p>"},{"location":"troubleshooting/docs/change-log-level/","title":"Change Log level for Spark application on EMR on EKS","text":"<p>To obtain more detail about their application or job submission, Spark application developers can change the log level of their job to different levels depending on their requirements. Spark uses apache log4j for logging.</p>"},{"location":"troubleshooting/docs/change-log-level/#change-log-level-to-debug","title":"Change log level to DEBUG","text":""},{"location":"troubleshooting/docs/change-log-level/#using-emr-classification","title":"Using EMR classification","text":"<p>Log level of spark applications can be changed using the EMR spark-log4j configuration classification.</p> <p>Request The <code>pi.py</code> application script is from the spark examples. EMR on EKS has included the example located at<code>/usr/lib/spark/examples/src/main</code> for you to try.</p> <p><code>spark-log4j</code> classification can be used to configure values in log4j.properties for EMR releases 6.7.0 or lower , and log4j2.properties for EMR releases 6.8.0+ .</p> <pre><code>cat &gt; Spark-Python-in-s3-debug-log.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-debug-log-classification\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"local:///usr/lib/spark/examples/src/main/python/pi.py\",\n      \"entryPointArguments\": [ \"200\" ],\n       \"sparkSubmitParameters\": \"--conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.memory=2G --conf spark.executor.instances=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      },\n      {\n        \"classification\": \"spark-log4j\", \n        \"properties\": {\n          \"log4j.rootCategory\":\"DEBUG, console\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json\n</code></pre> <p>The above request will print DEBUG logs in the spark driver and executor containers. The generated logs will be pushed to S3 and AWS Cloudwatch logs as configured in the request.</p> <p>Starting from the version 3.3.0, Spark has been migrated from log4j1 to log4j2. EMR on EKS allows you still write the log4j properties to the same <code>\"classification\": \"spark-log4j\"</code>, however it now needs to be log4j2.properties, such as </p> <pre><code>      {\n        \"classification\": \"spark-log4j\",\n        \"properties\": {\n          \"rootLogger.level\" : \"DEBUG\"\n          }\n      }\n</code></pre>"},{"location":"troubleshooting/docs/change-log-level/#custom-log4j-properties","title":"Custom log4j properties","text":"<p>Download log4j properties from here. Edit log4j.properties with log level as required. Save the edited log4j.properties in a mounted volume. In this example log4j.properties is placed in a s3 bucket that is mapped to a FSx for Lustre filesystem. </p> <p>Request pi.py used in the below request payload is from spark examples</p> <pre><code>cat &gt; Spark-Python-in-s3-debug-log.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-debug-log\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/pi.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.driver.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n          \"spark.executor.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n          \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json\n</code></pre> <p>Configurations of interest:  Below configuration enables spark driver and executor to pick up the log4j configuration file from <code>/var/data/</code> folder mounted to the driver and executor containers. For guide to mount FSx for Lustre to driver and executor containers - refer to EMR Containers integration with FSx for Lustre</p> <pre><code>\"spark.driver.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n\"spark.executor.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n</code></pre>"},{"location":"troubleshooting/docs/connect-spark-ui/","title":"Connect to Spark UI running on the Driver Pod","text":"<p>To obtain more detail about their application or monitor their job execution, Spark application developers can connect to Spark-UI running on the Driver Pod.</p> <p>Spark UI (Spark history server) is packaged with EMR on EKS out of the box. Alternatively, if you want to see Spark UI immediately after the driver is spun up, you can use the instructions in this page to connect.</p> <p>This page shows how to use <code>kubectl port-forward</code> to connect to the Job's Driver Pod running in a Kubernetes cluster. This type of connection is useful for debugging purposes.</p> <p>Pre-Requisites</p> <ul> <li>AWS cli should be installed</li> <li>\"kubectl\" should be installed</li> <li>If this is the first time you are connecting to your EKS cluster from your machine, you should run <code>aws eks update-kubeconfig --name --region</code> to download kubeconfig file and use correct context to talk to API server.</li> </ul>"},{"location":"troubleshooting/docs/connect-spark-ui/#submitting-the-job-to-a-virtual-cluster","title":"Submitting the job to a virtual cluster","text":"<p>Request </p> <pre><code>cat &gt;spark-python.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=4  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python.json\n</code></pre> <p>Once the job is submitted successfully, run <code>kubectl get pods -n &lt;virtual-cluster-k8s-namespace&gt; -w</code> command to watch all the pods, until you observe the driver pod is in the \"Running\" state. The Driver pod's name usually is in <code>spark-&lt;job-id&gt;-driver</code> format.</p>"},{"location":"troubleshooting/docs/connect-spark-ui/#connecting-to-the-driver-pod","title":"Connecting to the Driver Pod","text":"<p>Spark Driver Pod hosts Spark-UI on port <code>4040</code>. However the pod runs within the internal Kubernetes network. To get access to the internal Kubernetes resources, <code>kubectl</code> provides a tool (\"Port Forwarding\") that allows access from your localhost. To get access to the driver pod in your cluster:</p> <p>1- Run <code>kubectl port-forward &lt;driver-pod-name&gt; 4040:4040</code></p> <p>The result should be the following:</p> <pre><code>Forwarding from 127.0.0.1:28015 -&gt; 27017\nForwarding from [::1]:28015 -&gt; 27017\n</code></pre> <p>2- Open a browser and type <code>http://localhost:4040</code> in the Address bar.</p> <p>You should be able to connect to the Spark UI:</p> <p></p>"},{"location":"troubleshooting/docs/connect-spark-ui/#consideration","title":"Consideration","text":"<p>In some cases like long-running Spark jobs, such as Spark streaming or large Spark SQL queries can generate large event logs. With large events logs, it might happen quickly use up storage space on running pods and sometimes encounter to experience blank UI or even OutOfMemory errors when you load Persistent UIs. To avoid these issues, we recommend that you follow either by turn on the Spark event log rolling and compaction feature (default emr-container-event-log-dir - /var/log/spark/apps) or use S3 location to parse the log using self hosted of Spark history server. </p>"},{"location":"troubleshooting/docs/eks-cluster-auto-scaler/","title":"EKS Cluster Auto-Scaler","text":"<p>Kubernetes provisions nodes using CAS (Cluster Autoscaler). AWS EKS has its own implementation of K8 CAS, and EKS uses Managed-Nodegroups to spuns of Nodes.  </p>"},{"location":"troubleshooting/docs/eks-cluster-auto-scaler/#logs-of-eks-cluster-auto-scaler","title":"Logs of EKS Cluster Auto-scaler.","text":"<p>On AWS, Cluster Autoscaler utilizes Amazon EC2 Auto Scaling Groups to provision nodes. This section will help you identify the error message when a AutoScaler fails to provision nodes.   </p> <p>An example scenario, where the NodeGroup would fail due to non-supported nodes in certain AZs.  </p> <pre><code>Could not launch On-Demand Instances. Unsupported - Your requested instance type (g4dn.xlarge) is not supported in your requested Availability Zone (ca-central-1d). Please retry your request by not specifying an Availability Zone or choosing ca-central-1a, ca-central-1b. Launching EC2 instance failed.\n</code></pre> <p>The steps to find the logs for AutoScalingGroups are, </p> <p>Step 1: Login to AWS Console, and select <code>Elastic Kubernetes Service</code></p> <p>Step 2: Select <code>Compute</code> tab, and select the <code>NodeGroup</code> that fails.</p> <p>Step 3: Select the <code>Autoscaling group name</code> from the NodeGroup's section, which will direct you to <code>EC2 --&gt; AutoScaling Group</code> page.</p> <p>Step 4: Click the Tab <code>Activity</code> of the <code>AutoScaling Group</code>, and the <code>Activity History</code> would give provide the details of the error. </p> <pre><code>- Status\n- Description\n- Cause\n- Start Time\n- End Time\n</code></pre> <p>Alternatively, the activities/logs can be found via CLI as well </p> <pre><code>aws autoscaling describe-scaling-activities \\\n  --region &lt;region&gt; \\\n  --auto-scaling-group-name &lt;NodeGroup-AutoScaling-Group&gt;\n</code></pre> <p>In the above error scenario, the <code>ca-central-1d</code> availability zone doesn't support <code>g4dn.xlarge</code>.  The solution is</p> <p>Step 1: Identify the Subnets of the Availability zones that supports the GPU node type. The NodeGroup Section would list all the subnets, and you can click each subnet to see which AZ it is deployed to.</p> <p>Step 2: Create a NodeGroup only in the Subnets identified in the above step</p> <pre><code>aws eks create-nodegroup \\\n    --region &lt;region&gt; \\ \n    --cluster-name &lt;cluster-name&gt; \\\n    --nodegroup-name &lt;nodegroup-name&gt; \\\n    --scaling-config minSize=10,maxSize=10,desiredSize=10 \\\n    --ami-type AL2_x86_64_GPU \\\n    --node-role &lt;NodeGroupRole&gt; \\\n    --subnets &lt;subnet-1-that-supports-gpu&gt; &lt;subnet-2-that-supports-gpu&gt; \\\n    --instance-types g4dn.xlarge \\\n    --disk-size &lt;disk size&gt;\n</code></pre>"},{"location":"troubleshooting/docs/karpenter/","title":"Karpenter","text":"<p>Karpenter is an open-source cluster autoscaler for kubernetes (EKS) that automatically provisions new nodes in response to unschedulable pods. Until Karpenter was introduced, EKS would use its implementation of \"CAS\" Cluster Autoscaler, which creates Managed-NodeGroups to provision nodes.</p> <p>The challenge with Managed-NodeGroups is that, it can only create nodes with a single instance-type. In-order to provision nodes with different instance-types for different workloads, multiple nodegroups have to be created. Karpenter on the other hand can provision nodes of different types by working with EC2-Fleet-API.  The best practices to configure the Provisioners are documented at https://aws.github.io/aws-eks-best-practices/karpenter/</p> <p>This guide helps the user troubleshoot common problems with Karpenter.</p>"},{"location":"troubleshooting/docs/karpenter/#logs-of-karpenter-controller","title":"Logs of Karpenter Controller","text":"<p>Karpenter is a Custom Kubernetes Controller, and the following steps would help find Karpenter Logs.</p> <p>Step 1: Identify the namespace where Karpenter is running. In most cases, <code>helm</code> would be used to deploy Karpenter packages. The <code>helm ls</code> command would list the namespace where karpenter would be installed.</p> <pre><code># Example\n\n% helm ls --all-namespaces\nNAME        NAMESPACE   REVISION    UPDATED                                 STATUS      CHART               APP VERSION\nkarpenter   karpenter   1           2023-05-15 14:16:03.726908 -0500 CDT    deployed    karpenter-v0.27.3   0.27.3\n</code></pre> <p>Step 2: Setup kubectl</p> <pre><code>brew install kubectl\n\naws --region &lt;region&gt; eks update-kubeconfig --name &lt;eks-cluster-name&gt;\n</code></pre> <p>Step 3: Check the status of the pods of Karpenter</p> <pre><code># kubectl get pods -n &lt;namespace&gt;\n\n% kubectl get pods -n karpenter\nNAME                         READY   STATUS    RESTARTS   AGE\nkarpenter-7b455dccb8-prrzx   1/1     Running   0          7m18s\nkarpenter-7b455dccb8-x8zv8   1/1     Running   0          7m18s\n</code></pre> <p>Step 4: The <code>kubectl logs</code> command would help read the Karpenter logs. The below example, karpenter pod logs depict that an <code>t3a.large</code> instance was launched.</p> <pre><code># kubectl logs &lt;karpenter pod name&gt; -n &lt;namespace&gt;\n\n% kubectl logs karpenter-7b455dccb8-prrzx -n karpenter\n..\n..\n\n2023-05-15T19:16:20.546Z    DEBUG   controller  discovered region   {\"commit\": \"***-dirty\", \"region\": \"us-west-2\"}\n2023-05-15T19:16:20.666Z    DEBUG   controller  discovered cluster endpoint {\"commit\": \"**-dirty\", \"cluster-endpoint\": \"https://******.**.us-west-2.eks.amazonaws.com\"}\n..\n..\n2023-05-15T19:16:20.786Z    INFO    controller.provisioner  starting controller {\"commit\": \"**-dirty\"}\n2023-05-15T19:16:20.787Z    INFO    controller.deprovisioning   starting controller {\"commit\": \"**-dirty\"}\n..\n2023-05-15T19:16:20.788Z    INFO    controller  Starting EventSource    {\"commit\": \"**-dirty\", \"controller\": \"node\", \"controllerGroup\": \"\", \"controllerKind\": \"Node\", \"source\": \"kind source: *v1.Pod\"}\n..\n2023-05-15T20:34:56.718Z    INFO    controller.provisioner.cloudprovider    launched instance   {\"commit\": \"d7e22b1-dirty\", \"provisioner\": \"default\", \"id\": \"i-03146cd4d4152a935\", \"hostname\": \"ip-*-*-*-*.us-west-2.compute.internal\", \"instance-type\": \"t3a.large\", \"zone\": \"us-west-2d\", \"capacity-type\": \"on-demand\", \"capacity\": {\"cpu\":\"2\",\"ephemeral-storage\":\"20Gi\",\"memory\":\"7577Mi\",\"pods\":\"35\"}}\n</code></pre>"},{"location":"troubleshooting/docs/karpenter/#error-while-decoding-json-json-unknown-field-iamidentitymappings","title":"Error while decoding JSON: json: unknown field \"iamIdentityMappings\"","text":"<p>Problem The Create-Cluster command https://karpenter.sh/v0.27.3/getting-started/getting-started-with-karpenter/#3-create-a-cluster throws an error</p> <pre><code>Error: loading config file \"karpenter.yaml\": error unmarshaling JSON: while decoding JSON: json: unknown field \"iamIdentityMappings\"\n</code></pre> <p>Solution The <code>eksctl</code> cli was not able to understand the kind <code>iamIdentityMappings</code>. This is because, the <code>eksctl</code> version is old, and its schema doesn't support this kind. </p> <p>The solution is to upgrade the <code>eksctl</code> cli, and re-run the cluster creation commands</p> <pre><code>brew upgrade eksctl\n</code></pre>"},{"location":"troubleshooting/docs/rbac-permissions-errors/","title":"RBAC Permission Errors","text":"<p>The following sections provide solutions to common RBAC authorization errors.</p>"},{"location":"troubleshooting/docs/rbac-permissions-errors/#persistentvolumeclaims-is-forbidden","title":"PersistentVolumeClaims is forbidden","text":"<p>Error: Spark jobs that require creation, listing or deletion of Persistent Volume Claims (PVC) was not supported before EMR6.8. Jobs that require these permissions will fail with the exception \u201cpersistentvolumeclaims is forbidden\". Looking into driver logs, you may see an error like this: </p> <pre><code>persistentvolumeclaims is forbidden. User \"system:serviceaccount:emr:emr-containers-sa-spark-client-93ztm12rnjz163mt3rgdb3bjqxqfz1cgvqh1e9be6yr81\" cannot create resource \"persistentvolumeclaims\" in API group \"\" in namesapce \"emr\".\n</code></pre> <p>You may encounter this error because the default Kubernetes role <code>emr-containers</code> is missing the required RBAC permissions. As a result, the <code>emr-containers</code> primary role can\u2019t dynamically create necessary permissions for additional roles such as Spark driver, Spark executor or Spark client when you submit a job. </p> <p>Solution: Add the required permissions to <code>emr-containers</code>. </p> <p>Here are the complete RBAC permissions for EMR on EKS: </p> <ul> <li>emr-containers.yaml</li> </ul> <p>You can compare whether you have complete RBAC permissions using the steps below, </p> <pre><code>export NAMESPACE=YOUR_VALUE\nkubectl describe role emr-containers -n ${NAMESPACE}\n</code></pre> <p>If the permissions don't match, proceed to apply latest permissions</p> <pre><code>export NAMESPACE=YOUR_VALUE\nkubectl apply -f https://github.com/aws/aws-emr-containers-best-practices/blob/main/tools/k8s-rbac-policies/emr-containers.yaml -n ${NAMESPACE}\n</code></pre> <p>You can delete the spark driver and client roles because they will be dynamically created when the job is run next time. </p>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/","title":"Connect to SparkUI without Port Fowarding","text":"<p>This is an example of connecting to SparkUI running on Spark's driver pod via a reserve proxy solution, without an access to the kubectl tool or AWS console. </p> NOTE: We don't maintain the reverse proxy solution's docker image.   <p>A reverse proxy sits between a single Ingress ALB and multiple driver pods. The ALB forwards all incoming traffic to the reverse proxy, which then directs requests to the appropriate driver pods based on the URI path in each request. This routing occurs via Kubernetes service objects, with one service object required for each driver pod. These service objects should be named using the format <code>&lt;last-segment-of-URI-path&gt;-ui-svc</code>. To complete this setup, the following properties must be configured in the Spark configuration:</p> Configuratin Example Description spark.ui.proxyBase /sparkui/my-spark-app The URI path on which to access the particular job's spark UI. This is divided into two parts, first is base URI (i.e. /sparkui) and second is the name used to redirect the traffic to corresponding kubernetes service. e.g. if URI path is \"/sparkui/my-spark-app\" then reverse proxy redirects the traffic to Kubernetes service named \"my-spark-app-ui-svc\".  Note: Don't change the /sparkui/ base URI as its a default base URI used by Spark revserve proxy spark.ui.proxyRedirectUri / Redirect URI. Keep it \"/\". <p>The URL to access Spark UI is, <code>http://YOUR_INGRESS_ADDRESS:PORT/&lt;spark.ui.proxyBase&gt;</code> e.g. http://k8s-default-sparkui-2d325c0434-124141735.us-west-2.elb.amazonaws.com:80/sparkui/my-spark-app</p> <p>Where,  YOUR_INGRESS_ADDRESS:PORT :- Ingress ALB's DNS name and port. </p> <p>We demostrate how to set up Ingress and Reverse Proxy. Then launch the jobs via three EMR on EKS deployment methods: Spark Operator, JobRun API, and spark-submit. The spark operator creates the Kubernetes service object with target as driver pod for each job. However, JobRun API and spark-submit do not create Kubernetes service object so we use driver pod's \"postStart\" lifecycle hook to create the service object in driver pod's template.</p>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#deploy-sparkui-reserve-proxy-and-an-ingress-in-a-default-namespace","title":"Deploy SparkUI reserve proxy and an Ingress in a default namespace","text":"<p>Create a SparkUI reverse proxy and an Ingress (ALB) in a default namespace, which is a different namespace from your EMR on EKS virtual cluster environment. It can be configured to the EMR's namespace if neccessary.</p> <p>The sample yaml file is in the Appendix section. Make sure the EMR on EKS's namespace at the line #25 in <code>deployment.yaml</code> is updated if needed:</p> <pre><code>kubectl apply -f deployment.yaml\n</code></pre> NOTE: The example file is not production ready. This solution doesn't have authenticate on spark UI in place. Also, the listen port 80 is not recommended. Make sure to strengthen your Application Load Balance's security posture before deploying it to your production environment.  <p>EKS Admin can provide the ALB endpoint address to users via the command: </p> <pre><code>kubectl get ingress\n\nNAME       CLASS               HOSTS   ADDRESS                                                                PORTS   AGE\nspark-ui   alb-ingress-class   *       k8s-default-sparkui-627e515973-123456789.us-west-2.elb.amazonaws.com   80      14d\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#grant-permissions-to-driver-pods-service-account","title":"Grant permissions to Driver pod's Service Account","text":"NOTE: This step is required for JobRun API or spark-submit. It is NOT required for spark operator.  <p>If you are going to use JobRun API or spark-submit to launch the jobs then grant permissions to Kubernetes role bound to Driver pod's Service Account to be able to manage Kubernetes Service Object.</p> <p>The client &amp; driver roles and corresponding service accounts are can be queried via command:</p> <pre><code>export EMR_CONTAINERS_NAMESPACE=emr-on-eks\n\nkubectl get role -n $EMR_CONTAINERS_NAMESPACE                                                                                                                     \nNAME                               CREATED AT\nemr-containers                     2024-10-19T08:56:15Z\nemr-containers-role-spark-client   2024-10-19T09:57:37Z\nemr-containers-role-spark-driver   2024-10-19T09:57:37Z\n\nkubectl get serviceaccount -n $EMR_CONTAINERS_NAMESPACE \nNAME                                                                           SECRETS   AGE\ndefault                                                                        0         62m\nemr-containers-sa-spark-client-1234567890-abcdefgh123456ijklmno7890prrst       0         28s\nemr-containers-sa-spark-driver-1234567890-abcdefgh123456ijklmno7890prrst       0         28s\nemr-containers-sa-spark-executor-1234567890-abcdefgh123456ijklmno7890prrst     0         28s\n\nkubectl get rolebindings.rbac.authorization.k8s.io -n $EMR_CONTAINERS_NAMESPACE \nNAME                                                                       ROLE                                    AGE\nemr-containers                                                             Role/emr-containers                     62m\nemr-containers-rb-spark-client-1234567890-abcdefgh123456ijklmno7890prrst   Role/emr-containers-role-spark-client   46s\nemr-containers-rb-spark-driver-1234567890-abcdefgh123456ijklmno7890prrst   Role/emr-containers-role-spark-driver   46s\n</code></pre> <p>EKS Admin can grant the list, create, update, delete and patch for Kubernetes Service Object to spark driver role via the command:  </p> <p>Ensure to set <code>EMR_CONTAINERS_ROLE_SPARK_DRIVER</code> to Kubernetes role binded to driver pod's service account and <code>EMR_CONTAINERS_NAMESPACE</code> to Kubernetes namespace in which EMR on EKS is running.</p> <pre><code>export EMR_CONTAINERS_ROLE_SPARK_DRIVER=emr-containers-role-spark-driver\nexport EMR_CONTAINERS_NAMESPACE=emr-on-eks\nkubectl patch role $EMR_CONTAINERS_ROLE_SPARK_DRIVER -n $EMR_CONTAINERS_NAMESPACE --type='json' -p='[{\"op\": \"add\", \"path\": \"/rules/-\", \"value\": {\"apiGroups\": [\"\"], \"resources\": [\"services\"], \"verbs\": [\"list\", \"create\", \"update\", \"delete\", \"patch\"]}}]'\n</code></pre> <p>EKS Admin can varify the access to Driver Pod's Service Account via the command:  </p> <p>Ensure to set <code>EMR_CONTAINERS_SA_SPARK_DRIVER</code> to service account binded to above role. The output of each command should be \"yes\"</p> <pre><code>export EMR_CONTAINERS_SA_SPARK_DRIVER=emr-containers-sa-spark-driver-1234567890-abcdefgh123456ijklmno7890prrst\nkubectl auth can-i list   service -n $EMR_CONTAINERS_NAMESPACE --as=system:serviceaccount:$EMR_CONTAINERS_NAMESPACE:$EMR_CONTAINERS_SA_SPARK_DRIVER\nkubectl auth can-i create service -n $EMR_CONTAINERS_NAMESPACE --as=system:serviceaccount:$EMR_CONTAINERS_NAMESPACE:$EMR_CONTAINERS_SA_SPARK_DRIVER\nkubectl auth can-i update service -n $EMR_CONTAINERS_NAMESPACE --as=system:serviceaccount:$EMR_CONTAINERS_NAMESPACE:$EMR_CONTAINERS_SA_SPARK_DRIVER\nkubectl auth can-i delete service -n $EMR_CONTAINERS_NAMESPACE --as=system:serviceaccount:$EMR_CONTAINERS_NAMESPACE:$EMR_CONTAINERS_SA_SPARK_DRIVER\nkubectl auth can-i patch  service -n $EMR_CONTAINERS_NAMESPACE --as=system:serviceaccount:$EMR_CONTAINERS_NAMESPACE:$EMR_CONTAINERS_SA_SPARK_DRIVER\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#launch-emr-on-eks-jobs-via-spark-operator","title":"Launch EMR on EKS jobs via Spark Operator","text":"<p>1.Submit two test jobs using EMR on EKS's Spark Operator. The sample job scripts spark-operator-example-01.yaml and spark-operator-example-02.yaml can be found in the Appendix section. </p> <ul> <li>The <code>spec.driver.Serviceaccount</code> attribute should be updated based on your own IAM Role for Service Account (IRSA) setup in EMR on EKS.</li> <li>The <code>namespace</code> attribute should be updated to namespace where EMR on EKS is running</li> <li>Remember to specify the Spark configuration at line #16 <code>spark.ui.proxyBase: /sparkui/YOUR_SPARK_APP_NAME</code>, eg. <code>spark.ui.proxyBase: /sparkui/spark-example-01</code>.</li> </ul> <pre><code>kubectl apply -f spark-operator-example-01.yaml\nkubectl apply -f spark-operator-example-02.yaml\n</code></pre> <p>2.Go to a web browser, then access their Spark Web UI while jobs are still running.</p> <p>The Web UI address is in the format of <code>http://YOUR_INGRESS_ADDRESS:PORT/sparkui/YOUR_SPARK_APP_NAME</code>. For example:</p> <pre><code>http://k8s-default-sparkui-2d325c0434-124141735.us-west-2.elb.amazonaws.com:80/sparkui/spark-example-01\nhttp://k8s-default-sparkui-2d325c0434-124141735.us-west-2.elb.amazonaws.com:80/sparkui/spark-example-02\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#launch-emr-on-eks-jobs-via-job-run-api","title":"Launch EMR on EKS jobs via Job Run API","text":"<p>1.Upload the driver pod template to S3 bucket. It is assumed that template is copied under prefix (folder) <code>/templates</code> inside bucket.</p> <pre><code>aws s3 cp driver-pod-template.yaml YOUR_S3_BUCKET/templates\n</code></pre> <p>2.Ensure that Job execution role has access to above S3 bucket.</p> <p>3.Set the values for <code>YOUR_APP_NAME</code>, <code>YOUR_S3_BUCKET</code>, <code>YOUR_EMR_VIRTUAL_CLUSTER_NAME</code>, <code>YOUR_EMR_JOB_EXECUTION_ROLE</code> and run the sample job submission script below:</p> <pre><code>export YOUR_APP_NAME=start-job-run-pi\nexport S3BUCKET=YOUR_S3_BUCKET\n\nexport EMR_VIRTUAL_CLUSTER_NAME=YOUR_EMR_VIRTUAL_CLUSTER_NAME\nexport VIRTUAL_CLUSTER_ID=$(aws emr-containers list-virtual-clusters --query \"virtualClusters[?name == '$EMR_VIRTUAL_CLUSTER_NAME' &amp;&amp; state == 'RUNNING'].id\" --output text)\n\nexport ACCOUNTID=$(aws sts get-caller-identity --query Account --output text)\nexport EMR_ROLE_ARN=arn:aws:iam::$ACCOUNTID:role/YOUR_EMR_JOB_EXECUTION_ROLE\n\naws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name $YOUR_APP_NAME \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-7.1.0-latest \\\n--job-driver '{\n\"sparkSubmitJobDriver\": {\n    \"entryPoint\": \"local:///usr/lib/spark/examples/jars/spark-examples.jar\", \n    \"entryPointArguments\": [\"100000\"],\n    \"sparkSubmitParameters\": \"--class org.apache.spark.examples.SparkPi --conf spark.executor.instances=1 --conf spark.kubernetes.driver.podTemplateFile=s3://'${S3BUCKET}'/templates/driver-pod-template.yaml\" }}' \\\n--configuration-overrides '{\n\"applicationConfiguration\": [\n    {\n    \"classification\": \"spark-defaults\", \n    \"properties\": {\n        \"spark.ui.proxyBase\": \"/sparkui/'${YOUR_APP_NAME}'\",\n        \"spark.ui.proxyRedirectUri\": \"/\"\n    }}]}'\n</code></pre> <p>2.Go to a web browser, then access their Spark Web UI while jobs are still running.</p> <pre><code>http://&lt;YOUR_INGRESS_ADDRESS&gt;/sparkui/&lt;YOUR_APP_NAME&gt;\n</code></pre> <p>Admin can get the ingress address by the CLI:</p> <pre><code>kubectl get ingress\n</code></pre> <p>The SparkUI service is created on postStart event of driver container and looks like this:</p> <pre><code>kubectl get service -n $EMR_CONTAINERS_NAMESPACE\n\nNAME                  TYPE      CLUSTER-IP  EXTERNAL-IP   PORT(S)  AGE\nYOUR_APP_NAME-ui-svc ClusterIP 10.100.233.186  &lt;none&gt;      4040/TCP   9s\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#launch-emr-on-eks-jobs-by-spark-submit","title":"Launch EMR on EKS jobs by Spark Submit:","text":"<p>1.Create an EMR on EKS pod with a service account that has the IRSA associated and have permission to access the S3 bucket which has pod template.</p> <pre><code>export EMR_CONTAINERS_NAMESPACE=emr-on-eks\nexport EMR_CONTAINERS_SA_SPARK_CLIENT=emr-containers-sa-spark-client-1234567890-abcdefgh123456ijklmno7890prrst\n\nkubectl run -it emrekspod \\\n--image=public.ecr.aws/emr-on-eks/spark/emr-7.1.0:latest \\\n--overrides='{ \"spec\": {\"serviceAccount\": \"'${EMR_CONTAINERS_SA_SPARK_CLIENT}'\"}}' \\\n--command -n $EMR_CONTAINERS_NAMESPACE /bin/bash\n</code></pre> <p>2.After login into the \"emrekspod\" pod, submit the job:</p> <pre><code>export YOUR_APP_NAME=spark-submit-pi\nexport S3BUCKET=YOUR_S3_BUCKET\nexport EMR_CONTAINERS_NAMESPACE=emr-on-eks\nexport EMR_CONTAINERS_SA_SPARK_DRIVER=emr-containers-sa-spark-driver-1234567890-abcdefgh123456ijklmno7890prrst\n\nspark-submit \\\n--master k8s://$KUBERNETES_SERVICE_HOST:443 \\\n--deploy-mode cluster \\\n--name $YOUR_APP_NAME \\\n--class org.apache.spark.examples.SparkPi \\\n--conf spark.kubernetes.driver.podTemplateFile=s3://$S3BUCKET/templates/driver-pod-template.yaml \\\n--conf spark.kubernetes.driver.podTemplateContainerName=spark-kubernetes-driver \\\n--conf spark.ui.proxyBase=/sparkui/$YOUR_APP_NAME \\\n--conf spark.ui.proxyRedirectUri=\"/\" \\\n--conf spark.kubernetes.container.image=public.ecr.aws/emr-on-eks/spark/emr-7.1.0:latest \\\n--conf spark.kubernetes.authenticate.driver.serviceAccountName=$EMR_CONTAINERS_SA_SPARK_DRIVER \\\n--conf spark.kubernetes.namespace=$EMR_CONTAINERS_NAMESPACE \\\nlocal:///usr/lib/spark/examples/jars/spark-examples.jar 100000\n</code></pre> <p>3.Go to a web browser, then access their Spark Web UI while jobs are still running.</p> <pre><code>http://&lt;YOUR_INGRESS_ADDRESS&gt;/sparkui/&lt;YOUR_APP_NAME&gt;\n</code></pre> <p>Admin can get the ingress address by the CLI:</p> <pre><code>kubectl get ingress\n</code></pre> <p>The SparkUI service looks like this:</p> <pre><code>kubectl get svc -n emr\n\nNAME                  TYPE      CLUSTER-IP  EXTERNAL-IP   PORT(S)  AGE\njob-run-api-ui-svc ClusterIP 10.100.233.186  &lt;none&gt;      4040/TCP   9s\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#appendix","title":"Appendix","text":""},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#deploymentyaml","title":"deployment.yaml","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: spark-ui-reverse-proxy\n  labels:\n    app: spark-ui-reverse-proxy\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: spark-ui-reverse-proxy\n  template:\n    metadata:\n      labels:\n        app: spark-ui-reverse-proxy\n    spec:\n      containers:\n      - name: spark-ui-reverse-proxy\n        image: ghcr.io/datapunchorg/spark-ui-reverse-proxy:main-1652762636\n        imagePullPolicy: IfNotPresent\n        command:\n          - '/usr/bin/spark-ui-reverse-proxy'\n        args:\n          # EMR on EKS's namespace\n          - -namespace=emr-on-eks\n        resources:\n          requests:\n            cpu: 500m\n            memory: 512Mi\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: spark-ui-reverse-proxy\n  labels:\n    app: spark-ui-reverse-proxy\nspec:\n  type: ClusterIP\n  ports:\n    - name: http\n      protocol: TCP\n      port: 8080\n      targetPort: 8080\n  selector:\n    app: spark-ui-reverse-proxy\n\n---\napiVersion: networking.k8s.io/v1\nkind: IngressClass\nmetadata:\n  name: alb-ingress-class\nspec:\n  controller: ingress.k8s.aws/alb\n\n--- \napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: spark-ui\n  annotations:\n    # kubernetes.io/ingress.class: alb\n    alb.ingress.kubernetes.io/scheme: internet-facing\n    alb.ingress.kubernetes.io/target-type: ip\n    alb.ingress.kubernetes.io/success-codes: 200,301,302\n    alb.ingress.kubernetes.io/listen-ports: '[{\"HTTP\": 80}]'\n    alb.ingress.kubernetes.io/manage-backend-security-group-rules: \"true\"\n    # alb.ingress.kubernetes.io/security-groups: {{INBOUND_SG}}\n  # labels:\n  #   app: spark-ui-reverse-proxy\nspec:\n  ingressClassName: \"alb-ingress-class\"\n  rules:\n  - host: \"\"\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n              name: spark-ui-reverse-proxy\n              port:\n                number: 8080\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#spark-operator-example-01yaml","title":"spark-operator-example-01.yaml","text":"<pre><code>apiVersion: \"sparkoperator.k8s.io/v1beta2\"\nkind: SparkApplication\nmetadata:\n  name: spark-example-01\n  namespace: emr-on-eks\nspec:\n  type: Scala\n  image: public.ecr.aws/emr-on-eks/spark/emr-7.1.0:latest\n  mainClass: org.apache.spark.examples.SparkPi\n  mainApplicationFile: \"local:///usr/lib/spark/examples/jars/spark-examples.jar\"\n  arguments: [\"100000\"]\n  sparkVersion: 3.5.0\n  restartPolicy:\n    type: Never\n  sparkConf:\n    spark.ui.proxyBase: /sparkui/spark-example-01\n    spark.ui.proxyRedirectUri: /\n  driver:\n    cores: 1\n    coreLimit: \"1200m\"\n    memory: \"1g\"\n    serviceAccount: emr-containers-sa-spark\n  executor:\n    cores: 1\n    instances: 2\n    memory: \"2g\"\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#spark-operator-example-02yaml","title":"spark-operator-example-02.yaml","text":"<pre><code>apiVersion: \"sparkoperator.k8s.io/v1beta2\"\nkind: SparkApplication\nmetadata:\n  name: spark-example-02\n  namespace: emr-on-eks\nspec:\n  type: Scala\n  image: public.ecr.aws/emr-on-eks/spark/emr-7.1.0:latest\n  mainClass: org.apache.spark.examples.SparkPi\n  mainApplicationFile: \"local:///usr/lib/spark/examples/jars/spark-examples.jar\"\n  arguments: [\"1000000\"]\n  sparkVersion: 3.5.0\n  restartPolicy:\n    type: Never\n  sparkConf:\n    spark.ui.proxyBase: /sparkui/spark-example-02\n    spark.ui.proxyRedirectUri: /\n  driver:\n    cores: 1\n    coreLimit: \"1200m\"\n    memory: \"1g\"\n    serviceAccount: emr-containers-sa-spark\n  executor:\n    cores: 1\n    instances: 1\n    memory: \"2120m\"\n</code></pre>"},{"location":"troubleshooting/docs/reverse-proxy-sparkui/#driver-pod-templateyaml","title":"driver-pod-template.yaml","text":"<pre><code>apiVersion: v1\nkind: Pod\nspec:\n  containers:\n  - name: spark-kubernetes-driver # This will be interpreted as driver Spark main container\n    lifecycle:\n      postStart:\n        exec:\n          command: \n            - /bin/bash\n            - -c\n            - |\n              # Set Variables\n              export K8S_NAMESPACE=`cat  /run/secrets/kubernetes.io/serviceaccount/namespace`\n              export SPARK_UI_PROXYBASE=`grep spark.ui.proxyBase ${SPARK_CONF_DIR}/spark.properties | rev |  cut -d/ -f1 | rev`\n              export SPARK_UI_SERVICE_NAME=${SPARK_UI_PROXYBASE}-ui-svc\n\n              cat &gt; /tmp/service.yaml &lt;&lt; EOF\n              apiVersion: v1\n              kind: Service\n              metadata:\n                name: ${SPARK_UI_SERVICE_NAME}\n                namespace: $K8S_NAMESPACE\n                labels:\n                  spark-app-selector: ${SPARK_APPLICATION_ID}\n                  spark-role: driver\n              spec:\n                ports:\n                - port: 4040\n                  targetPort: 4040\n                  protocol: TCP\n                selector:\n                  spark-app-selector: ${SPARK_APPLICATION_ID}\n                  spark-role: driver\n                type: ClusterIP\n              EOF\n\n              if [ -n \"${SPARK_UI_PROXYBASE:-}\" ]; then\n                # Create or replace the service \n                curl -X PUT https://${KUBERNETES_SERVICE_HOST}/api/v1/namespaces/${K8S_NAMESPACE}/services/${SPARK_UI_SERVICE_NAME} -H \"Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)\" -H \"Content-Type: application/yaml\" --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt --data-binary @/tmp/service.yaml &gt; /tmp/service.out\n              else\n                echo spark.ui.proxyBase is NOT set in ${SPARK_CONF_DIR}/spark.properties &gt; /tmp/service.out\n              fi\n</code></pre>"},{"location":"troubleshooting/docs/self-hosted-shs/","title":"Self Hosted Spark History Server","text":"<p>In this section, you will learn how to self host Spark History Server instead of using the Persistent App UI on the AWS Console.</p> <ol> <li> <p>In your StartJobRun call for EMR on EKS, set the following conf. to point to an S3 bucket where you would like your event logs to go : <code>spark.eventLog.dir</code> and <code>spark.eventLog.enabled</code> as such:</p> <pre><code>\"configurationOverrides\": {\n  \"applicationConfiguration\": [{\n    \"classification\": \"spark-defaults\",\n    \"properties\": {\n      \"spark.eventLog.enabled\": \"true\",\n      \"spark.eventLog.dir\": \"s3://your-bucket-here/some-directory\"\n...\n</code></pre> </li> <li> <p>Take note of the S3 bucket specified in #1, and use it in the instructions on step #3 wherever you are asked for <code>path_to_eventlog</code> and make sure it is prepended with <code>s3a://</code>, not <code>s3://</code>. An example is <code>-Dspark.history.fs.logDirectory=s3a://path_to_eventlog</code>.</p> </li> <li> <p>Follow instructions here to launch Spark History Server using a Docker image.</p> </li> <li> <p>After following the above steps, event logs should flow to the specified S3 bucket and the docker container should spin up Spark History Server (which will be available at <code>127.0.0.1:18080</code>). This instance of Spark History Server will pick up and parse event logs from the S3 bucket specified.</p> </li> </ol>"},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/","title":"Spark Driver and Executor Logs","text":"<p>The status of the spark jobs can be monitored via EMR on EKS describe-job-run API.</p> <p>To be able to monitor the job progress and to troubleshoot failures, you must configure your jobs to send log information to Amazon S3, Amazon CloudWatch Logs, or both</p>"},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#send-spark-logs-to-s3","title":"Send Spark Logs to S3","text":""},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#update-the-iam-role-with-s3-write-access","title":"Update the IAM role with S3 write access","text":"<p>Configure the IAM Role passed in StartJobRun input <code>executionRoleArn</code> with access to S3 buckets.</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"s3:PutObject\",\n                \"s3:GetObject\",\n                \"s3:ListBucket\"\n            ],\n            \"Resource\": [\n                \"arn:aws:s3:::my_s3_log_location\",\n                \"arn:aws:s3:::my_s3_log_location/*\",\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#configure-the-startjobrun-api-with-s3-buckets","title":"Configure the StartJobRun API with S3 buckets","text":"<p>Configure the <code>monitoringConfiguration</code> with <code>s3MonitoringConfiguration</code>, and configure the S3 location where the logs would be synced.</p> <pre><code>{\n  \"name\": \"&lt;job_name&gt;\", \n  \"virtualClusterId\": \"&lt;vc_id&gt;\",  \n  \"executionRoleArn\": \"&lt;iam_role_name_for_job_execution&gt;\", \n  \"releaseLabel\": \"&lt;emr_release_label&gt;\", \n  \"jobDriver\": {\n\n  }, \n  \"configurationOverrides\": {\n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\",\n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://my_s3_log_location\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#log-location-of-jobrunner-driver-executor-in-s3","title":"Log location of JobRunner, Driver, Executor in S3","text":"<p>The JobRunner (pod that does spark-submit), Spark Driver, and Spark Executor logs would be found in the following S3 locations.</p> <pre><code>JobRunner/Spark-Submit/Controller Logs - s3://my_s3_log_location/${virtual-cluster-id}/jobs/${job-id}/containers/${job-runner-pod-id}/(stderr.gz/stdout.gz)\n\nDriver Logs - s3://my_s3_log_location/${virtual-cluster-id}/jobs/${job-id}/containers/${spark-application-id}/${spark-job-id-driver-pod-name}/(stderr.gz/stdout.gz)\n\nExecutor Logs - s3://my_s3_log_location/${virtual-cluster-id}/jobs/${job-id}/containers/${spark-application-id}/${spark-job-id-driver-executor-id}/(stderr.gz/stdout.gz)\n</code></pre>"},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#send-spark-logs-to-cloudwatch","title":"Send Spark Logs to CloudWatch","text":""},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#update-the-iam-role-with-cloudwatch-access","title":"Update the IAM role with CloudWatch access","text":"<p>Configure the IAM Role passed in StartJobRun input <code>executionRoleArn</code> with access to CloudWatch Streams.</p> <pre><code>{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"logs:CreateLogStream\",\n        \"logs:DescribeLogGroups\",\n        \"logs:DescribeLogStreams\"\n      ],\n      \"Resource\": [\n        \"arn:aws:logs:*:*:*\"\n      ]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"logs:PutLogEvents\"\n      ],\n      \"Resource\": [\n        \"arn:aws:logs:*:*:log-group:my_log_group_name:log-stream:my_log_stream_prefix/*\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#configure-startjobrun-api-with-cloudwatch","title":"Configure StartJobRun API with CloudWatch","text":"<p>Configure the <code>monitoringConfiguration</code> with <code>cloudWatchMonitoringConfiguration</code>, and configure the CloudWatch <code>logGroupName</code> and <code>logStreamNamePrefix</code> where the logs should be pushed.</p> <pre><code>{\n  \"name\": \"&lt;job_name&gt;\", \n  \"virtualClusterId\": \"&lt;vc_id&gt;\",  \n  \"executionRoleArn\": \"&lt;iam_role_name_for_job_execution&gt;\", \n  \"releaseLabel\": \"&lt;emr_release_label&gt;\", \n  \"jobDriver\": {\n\n  }, \n  \"configurationOverrides\": {\n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\",\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"my_log_group_name\",\n        \"logStreamNamePrefix\": \"my_log_stream_prefix\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"troubleshooting/docs/where-to-look-for-spark-logs/#log-location-of-jobrunner-driver-executor","title":"Log location of JobRunner, Driver, Executor","text":"<p>The JobRunner (pod that does spark-submit), Spark Driver, and Spark Executor logs would be found in the following AWS CloudWatch locations.</p> <pre><code>JobRunner/Spark-Submit/Controller Logs - ${my_log_group_name}/${my_log_stream_prefix}/${virtual-cluster-id}/jobs/${job-id}/containers/${job-runner-pod-id}/(stderr.gz/stdout.gz)\n\nDriver Logs - ${my_log_group_name}/${my_log_stream_prefix}/${virtual-cluster-id}/jobs/${job-id}/containers/${spark-application-id}/${spark-job-id-driver-pod-name}/(stderr.gz/stdout.gz)\n\nExecutor Logs - ${my_log_group_name}/${my_log_stream_prefix}/${virtual-cluster-id}/jobs/${job-id}/containers/${spark-application-id}/${spark-job-id-driver-executor-id}/(stderr.gz/stdout.gz)\n</code></pre>"}]}