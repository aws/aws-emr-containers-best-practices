{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the EMR Containers Best Practices Guide. The primary goal of this project is to offer a set of best practices and templates to get started with Amazon EMR on EKS. We publish this guide on GitHub so we could iterate the content quickly, provide timely and effective recommendations for variety of concerns, and easily incorporate suggestions from the broader community.</p>"},{"location":"#amazon-emr-on-eks-workshop","title":"Amazon EMR on EKS Workshop","text":"<p>If you are interested in step-by-step tutorials that leverage the best practices contained in this guide, please visit the Amazon EMR on EKS Workshop.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We encourage you to contribute to these guides. If you have implemented a practice that has proven to be effective, please share it with us by opening an issue or a pull request. Similarly, if you discover an error or flaw in the guide, please submit a pull request to correct it.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/","title":"EKS Best Practices and Recommendations","text":"<p>Amazon EMR on EKS team has run scale tests on EKS cluster and has compiled a list of recommendations. The purpose of this document is to share our recommendations for running large scale EKS clusters supporting EMR on EKS.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#amazon-vpc-cni-best-practices","title":"Amazon VPC CNI Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-1-improve-ip-address-utilization","title":"Recommendation 1: Improve IP Address Utilization","text":"<p>EKS clusters can run out of IP addresses for pods when they reached between 400 and 500 nodes. With the default CNI settings, each node can request more IP addresses than is required. To ensure that you don\u2019t run out of IP addresses, there are two solutions:</p> <ol> <li> <p>Set MINIMUM_IP_TARGET and WARM_IP_TARGET instead of the default setting of WARM_ENI_TARGET=1. The values of these settings will depend on your instance type, expected pod density, and workload. More info about these CNI settings can be found here. The maximum number of IP addresses per node (and thus maximum number of pods per node) depends on instance type and can be looked up here.</p> </li> <li> <p>If you have found the right CNI settings as described above, the subnets created by eksctl still do not provide enough addresses (by default eksctl creates a \u201c/19\u201d subnet for each nodegroup, which contains ~8.1k addresses). You can configure CNI to take addresses from (larger) subnets that you create. For example, you could create a few \u201c/16\u201d subnets, which contain ~65k IP addresses per subnet. You should implement this option after you have configured the CNI settings as described in #1. To configure your pods to use IP addresses from larger manually-created subnets, use CNI custom networking (see below for more information):</p> </li> </ol> <p>CNI custom networking</p> <p>By default, the CNI assigns the Pod\u2019s IP address from the worker node's primary elastic network interface's (ENI) security groups and subnet. If you don\u2019t have enough IP addresses in the worker node subnet, or prefer that the worker nodes and Pods reside in separate subnets to avoid IP address allocation conflicts between Pods and other resources in the VPC, you can use CNI custom networking.</p> <p>Enabling a custom network removes an available elastic network interface (and all of its available IP addresses for pods) from each worker node that uses it. The worker node's primary network interface is not used for pod placement when a custom network is enabled.</p> <p>If you want the CNI to assign IP addresses for Pods from a different subnet, you can set <code>AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG</code> environment variable to <code>true</code>.</p> <pre><code>kubectl set env daemonset aws-node \\\n-n kube-system AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true\n</code></pre> <p>When <code>AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true</code>, the CNI will assign Pod IP address from a subnet defined in <code>ENIConfig</code>. The <code>ENIConfig</code> custom resource is used to define the subnet in which Pods will be scheduled. </p> <pre><code>apiVersion: crd.k8s.amazonaws.com/v1alpha1\nkind: ENIConfig\nmetadata: name: us-west-2a\nspec: securityGroups: - sg-0dff111a1d11c1c11\nsubnet: subnet-011b111c1f11fdf11\n</code></pre> <p>You will need to create an <code>ENIconfig</code> custom resource for each subnet you want to use for Pod networking. </p> <ul> <li> <p>The <code>securityGroups</code> field should have the ID of the security group attached to the worker nodes. </p> </li> <li> <p>The <code>name</code> field should be the name of the Availability Zone in your VPC. If you name your ENIConfig custom resources after each Availability Zone in your VPC, you can enable Kubernetes to automatically apply the corresponding ENIConfig for the worker node Availability Zone with the following command.</p> </li> </ul> <pre><code>kubectl set env daemonset aws-node \\\n-n kube-system ENI_CONFIG_LABEL_DEF=failure-domain.beta.kubernetes.io/zone\n</code></pre> <p>Note</p> <p>Upon creating the <code>ENIconfig</code> custom resources, you will need to create new worker nodes. The existing worker nodes and Pods will remain unaffected.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-2-prevent-ec2-vpc-api-throttling-from-assignprivateipaddresses-attachnetworkinterface","title":"Recommendation 2: Prevent EC2 VPC API throttling from AssignPrivateIpAddresses &amp; AttachNetworkInterface","text":"<p>Often EKS cluster scale-out time can increase because the CNI is being throttled by the EC2 VPC APIs. The following steps can be taken to prevent these issues:</p> <ol> <li> <p>Use CNI version 1.8.0 or later as it reduces the calls to EC2 VPC APIs than earlier versions.</p> </li> <li> <p>Configure the MINIMUM_IP_TARGET and WARM_IP_TARGET parameters instead of the default parameter of WARM_ENI_TARGET=1. Only those IP addresses that are necessary are requested from EC2. The values of these settings will depend on your instance type and expected pod density. More info about these settings here.</p> </li> <li> <p>Request an API limit increase on the EC2 VPC APIs that are getting throttled. This option should be considered only after steps 1 &amp; 2 have been done.</p> </li> </ol>"},{"location":"best-practices-and-recommendations/eks-best-practices/#other-recommendations-for-amazon-vpc-cni","title":"Other Recommendations for Amazon VPC CNI","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#plan-for-growth","title":"Plan for growth","text":"<p>Size the subnets you will use for Pod networking for growth. If you have insufficient IP addresses available in the subnet that the CNI uses, your pods will not get an IP address. The pods will remain in the pending state until an IP address becomes available. This may impact application autoscaling and compromise its availability.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-ip-address-inventory","title":"Monitor IP address inventory","text":"<p>You can monitor the IP addresses inventory of subnets using the CNI Metrics Helper, and set CloudWatch alarms to get notified if a subnet is running out of IP addresses.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#snat-setting","title":"SNAT setting","text":"<p>Source Network Address Translation (source-nat or SNAT) allows traffic from a private network to go out to the internet. Virtual machines launched on a private network can get to the internet by going through a gateway capable of performing SNAT. If your Pods with private IP address need to communicate with other private IP address spaces (for example, Direct Connect, VPC Peering or Transit VPC), then you should enable external SNAT in the CNI:</p> <pre><code>kubectl set env daemonset \\\n-n kube-system aws-node AWS_VPC_K8S_CNI_EXTERNALSNAT=true\n</code></pre>"},{"location":"best-practices-and-recommendations/eks-best-practices/#coredns-best-practices","title":"CoreDNS Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#prevent-coredns-from-being-overwhelmed-unknownhostexception-in-spark-jobs-and-other-pods","title":"Prevent CoreDNS from being overwhelmed (UnknownHostException in spark jobs and other pods)","text":"<p>CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can be a problem for workloads that do a lot of DNS lookups. One simple solution is to install dns-autoscaler, which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-coredns-metrics","title":"Monitor CoreDNS metrics","text":"<p>CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can cause workloads to timeout with unknownHostException as spark-executors will do a lot of DNS lookups which registering themselves to spark-driver. One simple solution to fix this is to install dns-autoscaler, which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#cluster-autoscaler-best-practices","title":"Cluster Autoscaler Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#increase-cluster-autoscaler-memory-to-avoid-unnecessary-exceptions","title":"Increase cluster-autoscaler memory to avoid unnecessary exceptions","text":"<p>Cluster-autoscaler can require a lot of memory to run because it stores a lot of information about the state of the cluster, such as data about every pod and every node. If the cluster-autoscaler has insufficient memory, it can lead to the cluster-autoscaler crashing.  Ensure that you provide the cluster-autoscaler deployment more memory, e.g., 1Gi memory instead of the default 300Mi. Useful information about configuring the cluster-autoscaler for improved scalability and performance can be found here</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#avoid-job-failures-when-cluster-autoscaler-attempts-scale-in","title":"Avoid job failures when Cluster Autoscaler attempts scale-in","text":"<p>Cluster Autoscaler will attempt scale-in action for any under utilized instance within your EKScluster. When scale-in action is performed, all pods from that instance is relocated to another node. This could cause disruption for critical workloads. For example, if driver pod is restarted, the entire job needs to restart. For this reason, we recommend using Kubernetes annotations on all critical pods (especially driver pods) and for cluster autoscaler deployment. Please see here for more info</p> <pre><code>cluster-autoscaler.kubernetes.io/safe-to-evict=false\n</code></pre>"},{"location":"best-practices-and-recommendations/eks-best-practices/#configure-overprovisioning-with-cluster-autoscaler-for-higher-priority-jobs","title":"Configure overprovisioning with Cluster Autoscaler for higher priority jobs","text":"<p>If the required resources is not available in the cluster, pods go into pending state. Cluster Autoscaler uses this metric to scale out the cluster and this activity can be time-consuming (several minutes) for higher priority jobs. In order to minimize time required for scaling, we recommend overprovisioning resources. You can launch pause pods(dummy workloads which sleeps until it receives SIGINT or SIGTERM) with negative priority to reserve EC2 capacity. Once the higher priority jobs are scheduled, these pause pods are preempted to make room for high priority pods which in turn scales out additional capacity as a buffer. You need to be aware that this is a trade-off as it adds slightly higher cost while minimizing scheduling latency. You can read more about over provisioning best practice here.</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#eks-control-plane-best-practices","title":"EKS Control Plane Best practices","text":""},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server-overwhelmed","title":"API server overwhelmed","text":"<p>System pods, workload pods, and external systems can make many calls to the Kubernetes API server. This can decrease performance and also increase EMR on EKS job failures. There are multiple ways to avoid API server availability issues including but not limited to:</p> <ul> <li> <p>By default, the EKS API servers are automatically scaled to meet your workload demand. If you see increased latencies, please contact AWS via a support ticket and work with engineering team to resolve the issue.</p> </li> <li> <p>Consider reducing the scan interval of cluster-autoscaler from the 10 second default value. Each time the cluster-autoscaler runs, it makes many calls to the API server. However, this will result in the cluster scaling-out less frequently and in larger steps (and same with scaling back in when load is reduced). More information can be found about the cluster-autoscaler here. This is not recommended if you need jobs to start ASAP.</p> </li> <li> <p>If you are running your own deployment of fluentd, an increased load on the APIserver can be observed. Consider using fluent-bit instead which makes fewer calls to the API server. More info can be found here</p> </li> </ul>"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-control-plane-metrics","title":"Monitor Control Plane Metrics","text":"<p>Monitoring Kubernetes API metrics can give you insights into control plane performance and identify issues. An unhealthy control plane can compromise the availability of the workloads running inside the cluster. For example, poorly written controllers can overload the API servers, affecting your application's availability.</p> <p>Kubernetes exposes control plane metrics at the  <code>/metrics</code> endpoint. </p> <p>You can view the metrics exposed using <code>kubectl</code>:</p> <pre><code>kubectl get --raw /metrics\n</code></pre> <p>These metrics are represented in a Prometheus text format. </p> <p>You can use Prometheus to collect and store these metrics. In May 2020, CloudWatch added support for monitoring Prometheus metrics in CloudWatch Container Insights. So you can also use Amazon CloudWatch to monitor the EKS control plane. You can follow the Tutorial for Adding a New Prometheus Scrape Target: Prometheus KPI Server Metrics to collect metrics and create CloudWatch dashboard to monitor your cluster\u2019s control plane.</p> <p>You can also find Kubernetes API server metrics here. For example, <code>apiserver_request_duration_seconds</code> can indicate how long API requests are taking to run. </p> <p>Consider monitoring these control plane metrics:</p>"},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server","title":"API Server","text":"Metric Description <code>apiserver_request_total</code> Counter of apiserver requests broken out for each verb, dry run value, group, version, resource, scope, component, client, and HTTP response contentType and code. <code>apiserver_request_duration_seconds*</code> Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope, and component. <code>rest_client_request_duration_seconds</code> Request latency in seconds. Broken down by verb and URL. <code>apiserver_admission_controller_admission_duration_seconds</code> Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). <code>rest_client_request_duration_seconds</code> Request latency in seconds. Broken down by verb and URL. <code>rest_client_requests_total</code> Number of HTTP requests, partitioned by status code, method, and host."},{"location":"best-practices-and-recommendations/eks-best-practices/#etcd","title":"etcd","text":"Metric Description <code>etcd_request_duration_seconds</code> Etcd request latency in seconds for each operation and object type. <p>You can visualize and monitor these Kubernetes API server requests, latency and etcD metrics on Grafana via Grafana dashboard 12006.</p>"},{"location":"cost-optimization/docs/cost-optimization/","title":"Cost Optimization using EC2 Spot Instances","text":""},{"location":"cost-optimization/docs/cost-optimization/#ec2-spot-best-practices","title":"EC2 Spot Best Practices","text":"<p>Amazon EMR on Amazon EKS enables you to submit Apache Spark jobs on demand on Amazon Elastic Kubernetes Service (EKS) without provisioning dedicated EMR clusters. With EMR on EKS, you can consolidate analytical workloads with your other Kubernetes-based applications on the same Amazon EKS cluster to improve resource utilization and simplify infrastructure management. Cost Optimization of the underlying infrastructure is often the key requirement for our customers, and this can be achieved by using Amazon EC2 Spot Instances. Spot Instances are spare EC2 capacity and is available at up to 90% discount compared to On-Demand Instance prices. If EC2 needs capacity back for On-Demand Instance usage, Spot Instances can be interrupted. Handling interruptions to build resilient workloads is simple and there are best practices to manage interruption by automation or AWS services like EKS. </p> <p>This document will describe how to architect with EC2 spot best practices and apply to EMR on EKS jobs. We will also cover Spark features related to EC2 Spot when you run EMR on EKS jobs</p>"},{"location":"cost-optimization/docs/cost-optimization/#ec2-spot-capacity-provisioning","title":"EC2 Spot Capacity Provisioning","text":"<p>EMR on EKS runs open-source big data framework like Spark on Amazon EKS, so basically when you are run on Spot instances you are, provisioning capacity for the underlying EKS cluster. The key point to remember when you are using Spot instances is instance diversification. There are three ways that EC2 Spot capacity can be provisioned in an EKS cluster.</p> <p>EKS Managed Nodegroup:</p> <p>We highly recommend to use Managed Nodegroup for provisioning Spot instances. This requires significantly less operational effort when compared to self-managed nodegroups. The Spot instance interruption is handled proactively using the Instance Rebalancing Recommendation and Spot best practice of using Capacity Optimized Allocation strategy is adopted by default along with other useful features. If you are planning to scale your cluster then Cluster Autoscaler can be used but keep in mind, one caveat with this approach is to maintain same vCPU to memory ratio for nodes defined in a nodegroup.</p> <p>Karpenter:</p> <p>An open-source node provisioning tool for Kubernetes which works seamlessly with EMR on EKS. Karpenter can help to improve the efficiency and cost of running workloads. It provisions nodes based on pod resource requirements. The key advantage of Karpenter is flexibility not only in terms of EC2 pricing (Spot/On-Demand) but it also aligns with the Spot best practice of instance diversification, and uses capacity optimized prioritized allocation strategy; more details can be found in this workshop. Karpenter will also be useful to scale the infrastructure which will be further discussed under the scaling section below.</p> <p>Self-Managed Nodegroup:</p> <p>EMR on EKS clusters can also run on self-managed nodegroups on EKS. You need to manage the Spot instance lifecycle if there is an interruption by installing an open-source tool named AWS Node Termination Handler. AWS Node Termination Handler ensures that the Kubernetes control plane responds appropriately to events that can cause your EC2 instance to become unavailable, such as EC2 maintenance events, EC2 Spot interruptions, ASG Scale-In, ASG AZ Rebalance, and EC2 Instance Termination via the API or Console. Please remember you need to manage all the software updates manually if you plan to use this. When you are using dynamic allocation the nodegroups needs to autoscale, and if you are using cluster autoscaler then you need to maintain the vCPU to memory ratio for nodes defined in a nodegroup.</p>"},{"location":"cost-optimization/docs/cost-optimization/#spot-interruption-and-spark","title":"Spot Interruption and Spark","text":"<p>EC2 Spot instances are suitable for flexible and fault tolerant workloads. Spark is a semi-resilient by design because if the executor fails, new executors are spun up by the driver to continue the job. However, if the driver fails, the entire job fails. For added resiliency, EMR of EKS retries up to 5 times for driver pods so that the k8s can find suitable host and job starts successfully. If k8s fails to find a host, job is cancelled after 15 min timeout. If driver pod fails for other reasons, job is cancelled with an error message for troubleshooting. Hence, we recommend to run Spark driver on On-Demand instances and executors on Spot instances to cost optimize the workloads. You can use PodTemplates to configure this scheduling constraint. NodeSelector can be used  as the node selection constraint to run executors on Spot instances as in the example below. This is simple to use and works well with Karpenter too. The pod template for this would look like </p> <pre><code>apiVersion: v1\nkind: Pod\nspec:\nnodeSelector:\neks.amazonaws.com/capacityType: SPOT\ncontainers:\n- name: spark-kubernetes-executor\n</code></pre> <p>Node affinity can also be used here, this allows for more flexibility for the constraints defined. We recommend to use \u2018hard affinity\u2019 as highlighted in the code below for this purpose. For jobs which have strict SLA and are not suitable to run on Spot we suggest to use NoSchedule taint effect to ensure no Pods are scheduled. The key thing to note here is that the bulk of the compute required in a Spark job runs on executors and if they can be run on EC2 Spot instances you can benefit from the steep discount available with Spot instances.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\nlabels:\nspark-role: driver\nnamespace: emr-eks-workshop-namespace\nspec:\naffinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: 'eks.amazonaws.com/capacityType' operator: In values: - ON_DEMAND\n</code></pre> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\nlabels:\nspark-role: executor\nnamespace: emr-eks-workshop-namespace\nspec:\naffinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: 'eks.amazonaws.com/capacityType' operator: In values: - SPOT\n</code></pre> <p>When Spot instances are interrupted the executors running on them may lose (if any) the shuffle and cached RDDs which would require re-computation. This requires more compute cycles to be spent which will impact the overall SLA of the EMR on EKS jobs. EMR on EKS has incorporated two new Spark features which can help to address these issues. In the following sections we will discuss them.</p> <p>Node Decommissioning:</p> <p>Node decommissioning is a Spark feature that enables the removal of an executor gracefully, by preserving its state before removing it and not scheduling any new jobs on it. This feature is particularly useful when the Spark executors are running on Spot instances, and the Spark executor node is interrupted via a \u2018rebalance recommendation\u2019 or \u2018instance termination\u2019 notice to reclaim the instance. </p> <p>Node decommission begins when a Spark executor node receives a Spot Interruption Notice or Spot Rebalance Recommendation signal. The executor node immediately starts the process of decommissioning by sending a message to the Spark driver. The driver will identify the RDD/Shuffle files that it needs to migrate off the executor node in question, and will try to identify another Executor node which can take over the execution. If an executor is identified, the RDD/Shuffle files are copied to the new executor and the job execution continues on the new executor. If all the executors are busy, the RDD/Shuffle files are copied to an external storage.</p> <p> </p> <p>The key advantage of this process is that it enables block and shuffle data of a Spark executor that receives EC2 Spot Interruption signal to be migrated, reducing the re-computation of the Spark tasks. The reduction in the re-computation for the interrupted Spark tasks improves the resiliency of the system and reduces overall execution time. We recommend to enable node decommissioning feature because it would help to reduce the overall compute cycles when there is a Spot interruption.</p> <p>This feature is available on Amazon EMR version 6.3 and above. To set up this feature, add this configuration to the Spark job under the executor section:</p> <pre><code>\"spark.decommission.enabled\": \"true\"\n\"spark.storage.decommission.rddBlocks.enabled\": \"true\"\n\"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\"\n\"spark.storage.decommission.enabled\": \"true\"\n\"spark.storage.decommission.fallbackStorage.path\": \"s3://&lt;&lt;bucket&gt;&gt;\"\n</code></pre> <p>The Spark executor logs sample shown below shows the process of decommission and sending message to the driver:</p> <pre><code>21/05/05 17:41:41 WARN KubernetesClusterSchedulerBackend$KubernetesDriverEndpoint: Received executor 7 decommissioned message\n21/05/05 17:41:41 DEBUG TaskSetManager: Valid locality levels for TaskSet 2.0: NO_PREF, ANY\n21/05/05 17:41:41 INFO KubernetesClusterSchedulerBackend: Decommission executors: 7\n21/05/05 17:41:41 DEBUG TaskSchedulerImpl: parentName: , name: TaskSet_2.0, runningTasks: 10\n21/05/05 17:41:41 INFO BlockManagerMasterEndpoint: Mark BlockManagers (BlockManagerId(7, 192.168.82.107, 39007, None)) as being decommissioning.\n</code></pre> <pre><code>21/05/05 20:22:17 INFO CoarseGrainedExecutorBackend: Decommission executor 1.\n21/05/05 20:22:17 INFO CoarseGrainedExecutorBackend: Will exit when finished decommissioning\n21/05/05 20:22:17 INFO BlockManager: Starting block manager decommissioning process...\n21/05/05 20:22:17 DEBUG FileSystem: Looking for FS supporting s3a\n</code></pre> <p>The Spark driver logs sample below shows the process of looking for an executor to migrate the shuffle data:</p> <pre><code>22/06/07 20:41:38 INFO ShuffleStatus: Updating map output for 46 to BlockManagerId(4, 192.168.13.235, 34737, None)\n22/06/07 20:41:38 DEBUG BlockManagerMasterEndpoint: Received shuffle data block update for 0 46, ignore.\n22/06/07 20:41:38 DEBUG BlockManagerMasterEndpoint: Received shuffle index block update for 0 46, updating.\n</code></pre> <p>The Spark executor logs sample below shows the process of reusing the shuffle files:</p> <pre><code>22/06/07 20:42:50 INFO BasicExecutorFeatureStep: Adding decommission script to lifecycle\n22/06/07 20:42:50 DEBUG ExecutorPodsAllocator: Requested executor with id 19 from Kubernetes.\n22/06/07 20:42:50 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-bfd0a5813fd1b80f-exec-19, action ADDED\n22/06/07 20:42:50 DEBUG BlockManagerMasterEndpoint: Received shuffle index block update for 0 52, updating.\n22/06/07 20:42:50 INFO ShuffleStatus: Recover 52 BlockManagerId(fallback, remote, 7337, None)\n</code></pre> <p>More details on this can be found here</p> <p>PVC Reuse:</p> <p>A PersistentVolume is a Kubernetes feature to provide persistent storage to container Pods running stateful workloads, and PersistentVolumeClaim (PVC) is to request the above storage in the container Pod for storage by a user. Apache Spark 3.1.0 introduced the ability to dynamically generate, mount, and remove Persistent Volume Claims, SPARK-25299 for Kubernetes workloads, which are basically volumes mounted into your Spark pods. This means Apache Spark does not have to pre-create the claims/volumes for the executors and delete it during the executor decommissioning.</p> <p>If a Spark executor is killed due to EC2 Spot interruption or any other failure then the PVC is not deleted but persisted and reattached to another executor. If there are shuffle files in that volume then they are reused. Previously if an external shuffle service process or node became unavailable, the executors were killed and all the shuffle blocks were lost, which needed to be recomputed.</p> <p> </p> <p>This feature is available on Amazon EMR version 6.8 and above. To set up this feature, you can add these lines to the executor configuration:</p> <pre><code>\"spark.kubernetes.driver.ownPersistentVolumeClaim\": \"true\"\n\"spark.kubernetes.driver.reusePersistentVolumeClaim\": \"true\n</code></pre> <p>One key benefit is that if any Executor running on EC2 Spot becomes unavailable, the new executor replacement can reuse the shuffle files from the PVC, avoiding recompute of the shuffle block. Dynamic PVC or persistence volume claim enables \u2018true\u2019 decoupling of data and processing when we are running Spark jobs on Kubernetes, as it can be used as a local storage to spill in-process files too. We recommend to enable PVC reuse feature because the time taken to resume the task when there is a Spot interruption is optimized as the files are used in-situ and there is no time required to move the files around.</p> <p>If one or more of the nodes which are running executors is interrupted the underlying pods gets deleted and the driver gets the update. Note the driver is the owner of the PVC of the executors and they are not deleted.</p> <pre><code>22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-3, action DELETED\n22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-6, action MODIFIED\n22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-6, action DELETED\n22/06/15 23:25:07 DEBUG ExecutorPodsWatchSnapshotSource: Received executor pod update for pod named amazon-reviews-word-count-9ee82b8169a75183-exec-3, action MODIFIED\n</code></pre> <p>The ExecutorPodsAllocator tries to allocate new executor pods to replace the ones killed due to interruption. During the allocation it tries to figure out how many of the existing PVC has some files and can be reused.</p>"},{"location":"cost-optimization/docs/cost-optimization/#scaling-emr-on-eks-and-ec2-spot","title":"Scaling EMR on EKS and EC2 Spot","text":"<p>One of the key advantages of using Spot instances is it helps to increase the throughput of Big Data workloads at a fraction of the cost of On-Demand instances. There are spark workloads where there is a need to scale the \u2018number of executors\u2019 and the infrastructure dynamically. Scaling in a Spark process is done by spawning pod replicas and when they cannot be scheduled in the existing cluster the cluster need to be scaled up by adding more nodes. When you scale up using Spot instances you get the cost benefits of using the lowest price for EC2 Compute and thus increase the throughput of the job at a lower cost, as you can provision more compute capacity (at the same cost of On-Demand instances) to reduce the time taken to process large data sets.</p> <p>Dynamic Resource Allocation (DRA) enables the Spark driver to spawn the initial number of executors (pod replicas) and then scale up the number until the specified maximum number of executors is met to process the pending tasks. When the executors have no tasks running on them, they are terminated. This enables the nodes deployed in the Amazon EKS cluster to be better utilized while running multiple Spark jobs. DRA has mechanisms to dynamically adjust the resources your application occupies based on the workload. Idle executors are terminated when there are no pending tasks. This feature is available on Amazon EMR version 6.x. More details can be found here.</p> <p>Scaling of the infrastructure by adding more nodes can be achieved by using Cluster Autoscaler or Karpenter.</p> <p>Cluster Autoscaler:</p> <p>Cluster Autoscaler (CAS) is a Kubernetes open-source tool that automatically scale-out the size of the Kubernetes cluster when there are pending pods due to insufficient capacity on existing cluster, or scale-in when there are underutilized nodes in a cluster for extended period of time. The configuration below shows multiple Nodegroups with different vCPU and RAM configurations which adheres to the Spot best practice of diversification. Note each nodegroup has the same vCPU to memory ratio as discussed above. CAS works with EKS Managed and Self-Managed Nodegroups.</p> <p> </p> <p>Karpenter</p> <p>Karpenter is an open-source, flexible, high-performance auto-scaler built for Kubernetes. Karpenter automatically launches just the right compute resources to handle your cluster's applications. Karpenter observes aggregate resource requests of un-schedulable pods, computes and launches best-fit new capacity.</p> <p> </p> <p>The Provisioner CRD\u2019s configuration flexibility is very useful in adopting Spot best practices of diversification. It can include as many Spot Instance types as possible as we do not restrict specific instance types in the configuration. This approach is also future-proof when AWS launches new instance types. It also manages Spot instance lifecycle management through Spot interruptions. We recommend to use Karpenter with Spot Instances as it has faster node scheduling with early pod binding and binpacking to optimize the resource utilization. An example of a Karpenter provisioner with Spot instances below.</p> <pre><code>apiVersion: karpenter.sh/v1alpha5\nkind: Provisioner\nmetadata:\nname: default\nspec:\nlabels:\nintent: apps\nrequirements:\n- key: karpenter.sh/capacity-type\noperator: In\nvalues: [\"spot\"]\n- key: karpenter.k8s.aws/instance-size\noperator: NotIn\nvalues: [nano, micro, small, medium, large]\nlimits:\nresources:\ncpu: 1000\nmemory: 1000Gi\nttlSecondsAfterEmpty: 30\nttlSecondsUntilExpired: 2592000\nproviderRef:\nname: default\n</code></pre>"},{"location":"cost-optimization/docs/cost-optimization/#emr-on-eks-and-ec2-spot-instances-best-practices","title":"EMR on EKS and EC2 Spot Instances: Best Practices","text":"<p>To summarize here are our recommendations  - Use EC2 Spot instances for Spark executors and On-Demand instances for drivers.   - Diversify the instances types (Instance family and size) used in a cluster.  - Use a single AZ to launch a cluster to save Inter-AZ data transfer cost. - Use Karpenter for capacity provisioning and scaling when running EMR on EKS jobs - If using EKS nodegroups use EKS Managed Nodegroups with Cluster Autoscaler. - If using EKS self-managed nodegroups use Capacity Optimized Allocation strategy with the nodegroup and AWS Node Termination Handler. - Use Node decommission/PVC Reuse features, they help to reduce the time taken to complete EMR on EKS jobs running on EC2 Spot. - Use Dynamic Resource Allocation, this feature is particularly useful if multiple applications share resources in your Spark cluster, and Spot helps to improve the throughput at a low cost.  - Decouple Compute and Storage (S3 for Input/Output data). It allows independent scaling of processing and storage. There is low chance of losing data in case of a Spot interruption too.  - Reduce Spark\u2019s Shuffle Size and Blast Radius. This allows to select more Spot instances for diversification and also reduces the time taken to recompute/move the shuffle files in case of an interruption. - Automate Spot Interruption handling using existing tools and services.</p>"},{"location":"cost-optimization/docs/cost-optimization/#conclusion","title":"Conclusion","text":"<p>In this document, we covered best practices to cost effectively run EMR on EKS workloads using EC2 Spot Instances. We covered three key aspects of Provisioning, Interruption Handling and Scaling and the best practices under each of them. We hope this document provides prescriptive guidance on running EMR workload on EKS with significant cost savings by utilizing Spot instances.</p>"},{"location":"cost-optimization/docs/node-decommission/","title":"Node Decommission","text":"<p>This section shows how to use an Apache Spark feature that allows you to store the shuffle data and cached RDD blocks present on the terminating executors to peer executors before a Spot node gets decommissioned. Consequently, your job does not need to recalculate the shuffle and RDD blocks of the terminating executor that would otherwise be lost, thus allowing the job to have minimal delay in completion. </p> <p>This feature is supported for releases EMR 6.3.0+.</p>"},{"location":"cost-optimization/docs/node-decommission/#how-does-it-work","title":"How does it work?","text":"<p>When <code>spark.decommission.enabled</code> is true, Spark will try its best to shut down the executor gracefully. <code>spark.storage.decommission.enabled</code> will enable migrating data stored on the executor. Spark will try to migrate all the cached RDD blocks (controlled by <code>spark.storage.decommission.rddBlocks.enabled</code>) and shuffle blocks (<code>controlled by spark.storage.decommission.shuffleBlocks.enabled</code>) from the decommissioning executor to all remote executors when spark decommission is enabled. Relevant Spark configurations for using node decommissioning in the jobs are</p> Configuration Description Default Value spark.decommission.enabled Whether to enable decommissioning false spark.storage.decommission.enabled Whether to decommission the block manager when decommissioning executor false spark.storage.decommission.rddBlocks.enabled Whether to transfer RDD blocks during block manager decommissioning. false spark.storage.decommission.shuffleBlocks.enabled Whether to transfer shuffle blocks during block manager decommissioning. Requires a migratable shuffle resolver (like sort based shuffle) false spark.storage.decommission.maxReplicationFailuresPerBlock Maximum number of failures which can be handled for migrating shuffle blocks when block manager is decommissioning and trying to move its existing blocks. 3 spark.storage.decommission.shuffleBlocks.maxThreads Maximum number of threads to use in migrating shuffle files. 8 <p>This feature can currently be enabled through a temporary workaround on EMR 6.3.0+ releases. To enable it, Spark\u2019s decom.sh file permission must be modified using a custom image. Once the code is fixed, the page will be updated.</p> <p>Dockerfile for custom image:</p> <pre><code>FROM &lt;release account id&gt;.dkr.ecr.&lt;aws region&gt;.amazonaws.com/spark/&lt;release&gt;\nUSER root\nWORKDIR /home/hadoop\nRUN chown hadoop:hadoop /usr/bin/decom.sh\n</code></pre> <p>Setting decommission timeout:</p> <p>Each executor has to be decommissioned within a certain time limit controlled by the pod\u2019s terminationGracePeriodSeconds configuration.  The default value is 30 secs but can be modified using a custom pod template. The pod template for this modification would look like </p> <pre><code>apiVersion: v1\nkind: Pod\nspec:\nterminationGracePeriodSeconds: &lt;seconds&gt;\n</code></pre> <p>Note: terminationGracePeriodSeconds timeout should be lesser than spot instance timeout with around 5 seconds buffer kept aside for triggering the node termination</p> <p>Request:</p> <pre><code>cat &gt;spark-python-with-node-decommissioning.json &lt;&lt; EOF\n{\n\"name\": \"my-job-run-with-node-decommissioning\",\n\"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\",\n\"executionRoleArn\": \"&lt;execution-role-arn&gt;\",\n\"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\",\n\"properties\": {\n\"spark.kubernetes.container.image\": \"&lt;account_id&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/&lt;custom_image_repo&gt;\",\n\"spark.executor.instances\": \"5\",\n\"spark.decommission.enabled\": \"true\",\n\"spark.storage.decommission.rddBlocks.enabled\": \"true\",\n\"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\",\n\"spark.storage.decommission.enabled\": \"true\"\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"&lt;log group&gt;\", \"logStreamNamePrefix\": \"&lt;log-group-prefix&gt;\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"&lt;S3 URI&gt;\"\n}\n}\n} }\nEOF\n</code></pre> <p>Observed Behavior:</p> <p>When executors begin decommissioning, its shuffle data gets migrated to peer executors instead of recalculating the shuffle blocks again. If sending shuffle blocks to an executor fails, <code>spark.storage.decommission.maxReplicationFailuresPerBlock</code> will give the number of retries for migration. The driver log\u2019s stderr will see log lines <code>Updating map output for &lt;shuffle_id&gt; to BlockManagerId(&lt;executor_id&gt;, &lt;ip_address&gt;, &lt;port&gt;, &lt;topology_info&gt;)</code> denoting details about shuffle block \u2018s migration. This feature does not emit any other metrics for validation yet."},{"location":"debugging/docs/change-log-level/","title":"Change Log level for Spark application on EMR on EKS","text":"<p>To obtain more detail about their application or job submission, Spark application developers can change the log level of their job to different levels depending on their requirements. Spark uses apache log4j for logging.</p>"},{"location":"debugging/docs/change-log-level/#change-log-level-to-debug","title":"Change log level to DEBUG","text":""},{"location":"debugging/docs/change-log-level/#using-emr-classification","title":"Using EMR classification","text":"<p>Log level of spark applications can be changed using the EMR spark-log4j configuration classification.</p> <p>Request The <code>pi.py</code> application script is from the spark examples. EMR on EKS has included the example located at<code>/usr/lib/spark/examples/src/main</code> for you to try.</p> <p><code>spark-log4j</code> classification can be used to configure values in log4j.properties for EMR releases 6.7.0 or lower , and log4j2.properties for EMR releases 6.8.0+ .</p> <pre><code>cat &gt; Spark-Python-in-s3-debug-log.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-debug-log-classification\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"local:///usr/lib/spark/examples/src/main/python/pi.py\",\n      \"entryPointArguments\": [ \"200\" ],\n       \"sparkSubmitParameters\": \"--conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.memory=2G --conf spark.executor.instances=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      },\n      {\n        \"classification\": \"spark-log4j\", \n        \"properties\": {\n          \"log4j.rootCategory\":\"DEBUG, console\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json\n</code></pre> <p>The above request will print DEBUG logs in the spark driver and executor containers. The generated logs will be pushed to S3 and AWS Cloudwatch logs as configured in the request.</p> <p>Starting from the version 3.3.0, Spark has been migrated from log4j1 to log4j2. EMR on EKS allows you still write the log4j properties to the same <code>\"classification\": \"spark-log4j\"</code>, however it now needs to be log4j2.properties, such as </p> <pre><code>      {\n        \"classification\": \"spark-log4j\",\n        \"properties\": {\n          \"rootLogger.level\" : \"DEBUG\"\n          }\n      }\n</code></pre>"},{"location":"debugging/docs/change-log-level/#custom-log4j-properties","title":"Custom log4j properties","text":"<p>Download log4j properties from here. Edit log4j.properties with log level as required. Save the edited log4j.properties in a mounted volume. In this example log4j.properties is placed in a s3 bucket that is mapped to a FSx for Lustre filesystem. </p> <p>Request pi.py used in the below request payload is from spark examples</p> <pre><code>cat &gt; Spark-Python-in-s3-debug-log.json &lt;&lt; EOF\n{\n\"name\": \"spark-python-in-s3-debug-log\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/pi.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.driver.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n\"spark.executor.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json\n</code></pre> <p>Configurations of interest:  Below configuration enables spark driver and executor to pick up the log4j configuration file from <code>/var/data/</code> folder mounted to the driver and executor containers. For guide to mount FSx for Lustre to driver and executor containers - refer to EMR Containers integration with FSx for Lustre</p> <pre><code>\"spark.driver.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n\"spark.executor.extraJavaOptions\":\"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\",\n</code></pre>"},{"location":"debugging/docs/connect-spark-ui/","title":"Connect to Spark UI running on the Driver Pod","text":"<p>To obtain more detail about their application or monitor their job execution, Spark application developers can connect to Spark-UI running on the Driver Pod.</p> <p>Spark UI (Spark history server) is packaged with EMR on EKS out of the box. Alternatively, if you want to see Spark UI immediately after the driver is spun up, you can use the instructions in this page to connect.</p> <p>This page shows how to use <code>kubectl port-forward</code> to connect to the Job's Driver Pod running in a Kubernetes cluster. This type of connection is useful for debugging purposes.</p> <p>Pre-Requisites</p> <ul> <li>AWS cli should be installed</li> <li>\"kubectl\" should be installed</li> <li>If this is the first time you are connecting to your EKS cluster from your machine, you should run <code>aws eks update-kubeconfig --name --region</code> to download kubeconfig file and use correct context to talk to API server.</li> </ul>"},{"location":"debugging/docs/connect-spark-ui/#submitting-the-job-to-a-virtual-cluster","title":"Submitting the job to a virtual cluster","text":"<p>Request </p> <pre><code>cat &gt;spark-python.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=4  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python.json\n</code></pre> <p>Once the job is submitted successfully, run <code>kubectl get pods -n &lt;virtual-cluster-k8s-namespace&gt; -w</code> command to watch all the pods, until you observe the driver pod is in the \"Running\" state. The Driver pod's name usually is in <code>spark-&lt;job-id&gt;-driver</code> format.</p>"},{"location":"debugging/docs/connect-spark-ui/#connecting-to-the-driver-pod","title":"Connecting to the Driver Pod","text":"<p>Spark Driver Pod hosts Spark-UI on port <code>4040</code>. However the pod runs within the internal Kubernetes network. To get access to the internal Kubernetes resources, <code>kubectl</code> provides a tool (\"Port Forwarding\") that allows access from your localhost. To get access to the driver pod in your cluster:</p> <p>1- Run <code>kubectl port-forward &lt;driver-pod-name&gt; 4040:4040</code></p> <p>The result should be the following:</p> <pre><code>Forwarding from 127.0.0.1:28015 -&gt; 27017\nForwarding from [::1]:28015 -&gt; 27017\n</code></pre> <p>2- Open a browser and type <code>http://localhost:4040</code> in the Address bar.</p> <p>You should be able to connect to the Spark UI:</p> <p></p>"},{"location":"debugging/docs/self-hosted-shs/","title":"Self Hosted Spark History Server","text":"<p>In this section, you will learn how to self host Spark History Server instead of using the Persistent App UI on the AWS Console.</p> <ol> <li> <p>In your StartJobRun call for EMR on EKS, set the following conf. to point to an S3 bucket where you would like your event logs to go : <code>spark.eventLog.dir</code> and <code>spark.eventLog.enabled</code> as such:</p> <pre><code>\"configurationOverrides\": {\n  \"applicationConfiguration\": [{\n    \"classification\": \"spark-defaults\",\n    \"properties\": {\n      \"spark.eventLog.enabled\": \"true\",\n      \"spark.eventLog.dir\": \"s3://your-bucket-here/some-directory\"\n...\n</code></pre> </li> <li> <p>Take note of the S3 bucket specified in #1, and use it in the instructions on step #3 wherever you are asked for <code>path_to_eventlog</code> and make sure it is prepended with <code>s3a://</code>, not <code>s3://</code>. An example is <code>-Dspark.history.fs.logDirectory=s3a://path_to_eventlog</code>.</p> </li> <li> <p>Follow instructions here to launch Spark History Server using a Docker image.</p> </li> <li> <p>After following the above steps, event logs should flow to the specified S3 bucket and the docker container should spin up Spark History Server (which will be available at <code>127.0.0.1:18080</code>). This instance of Spark History Server will pick up and parse event logs from the S3 bucket specified.</p> </li> </ol>"},{"location":"metastore-integrations/docs/aws-glue/","title":"EMR Containers integration with AWS Glue","text":""},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-same-account-as-eks","title":"AWS Glue catalog in same account as EKS","text":"<p>In the below example a Spark application will be configured to use AWS Glue data catalog as the hive metastore.  </p> <p>gluequery.py</p> <pre><code>cat &gt; gluequery.py &lt;&lt;EOF\nfrom os.path import expanduser, join, abspath\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Row\n# warehouse_location points to the default location for managed databases and tables\nwarehouse_location = abspath('spark-warehouse')\nspark = SparkSession \\\n    .builder \\\n    .appName(\"Python Spark SQL Hive integration example\") \\\n    .config(\"spark.sql.warehouse.dir\", warehouse_location) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\nspark.sql(\"CREATE EXTERNAL TABLE `sparkemrnyc`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://&lt;s3 prefix&gt;/trip-data.parquet/'\")\nspark.sql(\"SELECT count(*) FROM sparkemrnyc\").show()\nspark.stop()\nEOF\n</code></pre> <pre><code>LOCATION 's3://&lt;s3 prefix&gt;/trip-data.parquet/'\n</code></pre> <p>Configure the above property to point to the S3 location containing the data. </p> <p>Request</p> <pre><code>cat &gt; Spark-Python-in-s3-awsglue-log.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-awsglue-log\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/gluequery.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-log.json\n</code></pre> <p>Output from driver logs - Displays the number of rows.</p> <pre><code>+----------+\n|  count(1)|\n+----------+\n|2716504499|\n+----------+\n</code></pre>"},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-different-account","title":"AWS Glue catalog in different account","text":"<p>The Spark application is submitted to EMR Virtual cluster in Account A and is configured to connect to AWS Glue catalog in Account B. The IAM policy attached to the job execution role <code>(\"executionRoleArn\": \"&lt;execution-role-arn&gt;\")</code>is in Account A</p> <pre><code>{\n\"Version\": \"2012-10-17\",\n\"Statement\": [\n{\n\"Effect\": \"Allow\",\n\"Action\": [\n\"glue:*\"\n],\n\"Resource\": [\n\"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:catalog\",\n\"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:database/default\",\n\"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:table/default/sparkemrnyc\"\n]\n}\n]\n}\n</code></pre> <p>IAM policy attached to the AWS Glue catalog in Account B</p> <pre><code>{\n\"Version\" : \"2012-10-17\",\n\"Statement\" : [ {\n\"Effect\" : \"Allow\",\n\"Principal\" : {\n\"AWS\" : \"&lt;execution-role-arn&gt;\"\n},\n\"Action\" : \"glue:*\",\n\"Resource\" : [ \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:catalog\", \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:database/default\", \"arn:aws:glue:&lt;region&gt;:&lt;account&gt;:table/default/sparkemrnyc\" ]\n} ]\n}\n</code></pre> <p>Request</p> <pre><code>cat &gt; Spark-Python-in-s3-awsglue-crossaccount.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-awsglue-crossaccount\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/gluequery.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n          \"spark.hadoop.hive.metastore.glue.catalogid\":\"&lt;account B&gt;\",\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-crossaccount.json\n</code></pre> <p>Configuration of interest  To specify the accountID where the AWS Glue catalog is defined reference the following: </p> <p>Spark-Glue integration</p> <pre><code>\"spark.hadoop.hive.metastore.glue.catalogid\":\"&lt;account B&gt;\",\n</code></pre> <p>Output from driver logs - displays the number of rows.</p> <pre><code>+----------+\n|  count(1)|\n+----------+\n|2716504499|\n+----------+\n</code></pre>"},{"location":"metastore-integrations/docs/aws-glue/#sync-hudi-table-with-aws-glue-catalog","title":"Sync Hudi table with AWS Glue catalog","text":"<p>In this example, a Spark application will be configured to use AWS Glue data catalog as the hive metastore. </p> <p>Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Glue catalog via the Hive Metastore Service (HMS) in hive sync mode. This example runs a Hudi ETL job with EMR on EKS, and interact with AWS Glue metaStore to create a Hudi table. It provides you the native and serverless capabilities to manage your technical metadata. Also you can query Hudi tables in Athena straigt away after the ETL job, which provides your end user an easy data access and shortens the time to insight.</p> <p>HudiEMRonEKS.py</p> <pre><code>cat &gt; HudiEMRonEKS.py &lt;&lt;EOF\nimport sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", sys.argv[1]+\"/warehouse/\" ) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\n# Create a DataFrame\ninputDF = spark.createDataFrame(\n    [\n        (\"100\", \"2015-01-01\", \"2015-01-01T13:51:39.340396Z\"),\n        (\"101\", \"2015-01-01\", \"2015-01-01T12:14:58.597216Z\"),\n        (\"102\", \"2015-01-01\", \"2015-01-01T13:51:40.417052Z\"),\n        (\"103\", \"2015-01-01\", \"2015-01-01T13:51:40.519832Z\"),\n        (\"104\", \"2015-01-02\", \"2015-01-01T12:15:00.512679Z\"),\n        (\"105\", \"2015-01-02\", \"2015-01-01T13:51:42.248818Z\"),\n    ],\n    [\"id\", \"creation_date\", \"last_update_time\"]\n)\n\n# Specify common DataSourceWriteOptions in the single hudiOptions variable\ntest_tableName = \"hudi_tbl\"\nhudiOptions = {\n'hoodie.table.name': test_tableName,\n'hoodie.datasource.write.recordkey.field': 'id',\n'hoodie.datasource.write.partitionpath.field': 'creation_date',\n'hoodie.datasource.write.precombine.field': 'last_update_time',\n'hoodie.datasource.hive_sync.enable': 'true',\n'hoodie.datasource.hive_sync.table': test_tableName,\n'hoodie.datasource.hive_sync.database': 'default',\n'hoodie.datasource.write.hive_style_partitioning': 'true',\n'hoodie.datasource.hive_sync.partition_fields': 'creation_date',\n'hoodie.datasource.hive_sync.partition_extractor_class': 'org.apache.hudi.hive.MultiPartKeysValueExtractor',\n'hoodie.datasource.hive_sync.mode': 'hms'\n}\n\n\n# Write a DataFrame as a Hudi dataset\ninputDF.write \\\n.format('org.apache.hudi') \\\n.option('hoodie.datasource.write.operation', 'bulk_insert') \\\n.options(**hudiOptions) \\\n.mode('overwrite') \\\n.save(sys.argv[1]+\"/hudi_hive_insert\")\nEOF\n</code></pre> <p>NOTE: configure the <code>warehouse dir</code> property to point to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environament vairable.</p> <pre><code>.config(\"spark.sql.warehouse.dir\", sys.argv[1]+\"/warehouse/\" )\n</code></pre> <p>Request</p> <pre><code>export S3BUCKET=YOUR_S3_BUCKET_NAME\n\naws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name hudi-test1 \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.3.0-latest \\\n--job-driver '{\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\",\n\"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n\"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\\n--configuration-overrides '{\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\",\n\"spark.sql.hive.convertMetastoreParquet\": \"false\",\n\"spark.hadoop.hive.metastore.client.factory.class\": \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\"\n}}\n], \"monitoringConfiguration\": {\n\"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre> <p>NOTE: To get a correct verison of hudi library, we directly download the jar from the maven repository with the synctax of <code>\"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar</code>. Starting from EMR 6.5, the Hudi-spark3-bundle library will be included in EMR docker images.</p>"},{"location":"metastore-integrations/docs/hive-metastore/","title":"EMR Containers integration with Hive Metastore","text":"<p>For more details, check out the github repository, which includes CDK/CFN templates that help you to get started quickly.</p>"},{"location":"metastore-integrations/docs/hive-metastore/#1-hive-metastore-database-through-jdbc","title":"1-Hive metastore Database through JDBC","text":"<p>In this example, a Spark application is configured to connect to a Hive Metastore database provisioned with Amazon RDS Aurora MySql via a JDBC connection. The Amazon RDS and EKS cluster should be in same VPC or else the Spark job will not be able to connect to RDS. </p> <p>You directly pass in the JDBC credentials at the job/application level, which is a simple and quick solution to make a connection to the HMS. However, it is not recommended in a production environment. From the security perspective, the password management could be a risk since the JDBC credentials will appear in all of your job logs. Also engineers may be required to hold the password when it is not necessary.</p> <p>Request: </p> <pre><code>cat &gt; Spark-Python-in-s3-hms-jdbc.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-hms-jdbc\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/hivejdbc.py\", \n       \"sparkSubmitParameters\": \"--jars s3://&lt;s3 prefix&gt;/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=&lt;connection-user-name&gt; --conf spark.hadoop.javax.jdo.option.ConnectionPassword=&lt;connection-password&gt; --conf spark.hadoop.javax.jdo.option.ConnectionURL=&lt;JDBC-Connection-string&gt; --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-jdbc.json\n</code></pre> <p>In this example we are connecting to mysql db, so <code>mariadb-connector-java.jar</code> needs to be passed with <code>--jars</code> option. If you are using postgres, Oracle or any other database, the appropriate connector jar needs to be included.  </p> <p>Configuration of interest:</p> <pre><code>--jars s3://&lt;s3 prefix&gt;/mariadb-connector-java.jar\n--conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver \n--conf spark.hadoop.javax.jdo.option.ConnectionUserName=&lt;connection-user-name&gt;  \n--conf spark.hadoop.javax.jdo.option.ConnectionPassword=&lt;connection-password&gt;\n--conf spark.hadoop.javax.jdo.option.ConnectionURL**=&lt;JDBC-Connection-string&gt;\n</code></pre> <p>hivejdbc.py</p> <pre><code>from os.path import expanduser, join, abspath\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Row\n# warehouse_location points to the default location for managed databases and tables\nwarehouse_location = abspath('spark-warehouse')\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", warehouse_location) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE EXTERNAL TABLE `ehmsdb`.`sparkemrnyc5`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://&lt;s3 prefix&gt;/nyctaxi_parquet/'\")\nspark.sql(\"SELECT count(*) FROM ehmsdb.sparkemrnyc5 \").show()\nspark.stop()\n</code></pre> <p>The above job lists databases from a remote RDS Hive Metastore, creates a new table and then queries it.</p>"},{"location":"metastore-integrations/docs/hive-metastore/#2-hive-metastore-thrift-service-through-thrift-protocol","title":"2-Hive metastore thrift service through thrift:// protocol","text":"<p>In this example, the spark application is configured to connect to an external Hive metastore thrift server. The thrift server is running on <code>EMR on EC2's master node</code> and AWS RDS Aurora is used as database for the Hive metastore. </p> <p>Running an EMR on EC2 cluster as a thrift server, simplify the application configuration and setup. You can start quickly with reduced engineering effort. However, your maintenance overhead may increase, since you will be monitoring two types of clusters, i.e. EMR on EC2 and EMR on EKS.</p> <p>thriftscript.py: <code>hive.metastore.uris</code> config needs to be set to read from external Hive metastore. The URI format looks like this: <code>thrift://EMR_ON_EC2_MASTER_NODE_DNS_NAME:9083</code></p> <pre><code>from os.path import expanduser, join, abspath\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql import Row\n# warehouse_location points to the default location for managed databases and tables\nwarehouse_location = abspath('spark-warehouse')\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", warehouse_location) \\\n    .config(\"hive.metastore.uris\",\"&lt;hive metastore thrift uri&gt;\") \\\n    .enableHiveSupport() \\\n    .getOrCreate()\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE EXTERNAL TABLE ehmsdb.`sparkemrnyc2`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://&lt;s3 prefix&gt;/nyctaxi_parquet/'\")\nspark.sql(\"SELECT * FROM ehmsdb.sparkemrnyc2\").show()\nspark.stop()\n</code></pre> <p>Request:</p> <p>The below job lists databases from remote Hive Metastore, creates a new table and then queries it.</p> <pre><code>cat &gt; Spark-Python-in-s3-hms-thrift.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-hms-thrift\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/thriftscript.py\", \n       \"sparkSubmitParameters\": \"--jars s3://&lt;s3 prefix&gt;/mariadb-connector-java.jar --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-thrift.json\n</code></pre>"},{"location":"metastore-integrations/docs/hive-metastore/#3-connect-hive-metastore-via-thrift-service-hosted-on-eks","title":"3-Connect Hive metastore via thrift service hosted on EKS","text":"<p>In this example, our Spark application connects to a standalone Hive metastore service (HMS) running in EKS.</p> <p>Running the standalone HMS in EKS unifies your analytics applications with other business critical apps in a single platform. It simplifies your solution architecture and infrastructure design. The helm chart solution includes autoscaling feature, so your EKS cluster can automatically expand or shrink when the HMS request volume changes. Also it follows the security best practice to manage JDBC credentials via AWS Secrets Manager. However, you will need a combination of analytics and k8s skills to maintain this solution.</p> <p>To install the HMS helm chart, simply replace the environment variables in values.yaml, then manually <code>helm install</code> via the command below. Otherwise, deploy the HMS via a CDK/CFN template with a security best practice. Check out the CDK project for more details.</p> <pre><code>cd hive-emr-on-eks/hive-metastore-chart\n\nsed -i '' -e 's/{RDS_JDBC_URL}/\"jdbc:mysql:\\/\\/'$YOUR_HOST_NAME':3306\\/'$YOUR_DB_NAME'?createDatabaseIfNotExist=true\"/g' values.yaml \nsed -i '' -e 's/{RDS_USERNAME}/'$YOUR_USER_NAME'/g' values.yaml \nsed -i '' -e 's/{RDS_PASSWORD}/'$YOUR_PASSWORD'/g' values.yaml\nsed -i '' -e 's/{S3BUCKET}/s3:\\/\\/'$YOUR_S3BUCKET'/g' values.yaml\n\nhelm repo add hive-metastore https://aws-samples.github.io/hive-metastore-chart \nhelm install hive hive-metastore/hive-metastore -f values.yaml --namespace=emr --debug\n</code></pre> <p>hivethrift_eks.py</p> <pre><code>from os import environ\nimport sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\",environ['warehouse_location']) \\\n    .config(\"hive.metastore.uris\",\"thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\") \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE DATABASE IF NOT EXISTS `demo`\")\nspark.sql(\"DROP TABLE IF EXISTS demo.amazonreview3\")\nspark.sql(\"CREATE EXTERNAL TABLE IF NOT EXISTS `demo`.`amazonreview3`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\"+sys.argv[1]+\"/app_code/data/toy/'\")\nspark.sql(\"SELECT coount(*) FROM demo.amazonreview3\").show()\nspark.stop()\n</code></pre> <p>An environment variable <code>HIVE_METASTORE_SERVICE_HOST</code> appears in your Spark application pods automatically, once the standalone HMS is up running in EKS. You can directly set the <code>hive.metastore.uris</code> to <code>thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\"</code>.</p> <p>Can set the <code>spark.sql.warehouse.dir</code> property to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environment variable.</p> <p>Request:</p> <pre><code>#!/bin/bash\naws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name spark-hive-via-thrift \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.2.0-latest \\\n--job-driver '{\n  \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/hivethrift_eks.py\",\n      \"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n      \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\\n--configuration-overrides '{\n    \"monitoringConfiguration\": {\n      \"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre>"},{"location":"metastore-integrations/docs/hive-metastore/#4-run-thrift-service-as-a-sidecar-in-spark-drivers-pod","title":"4-Run thrift service as a sidecar in Spark Driver's pod","text":"<p>This advanced solution runs the standalone HMS thrift service inside a Spark driver as a sidecar. It means each Spark job will have its dedicated thrift server. The benefit of the design is HMS is no long a single point of failure, since each Spark application has its own HMS. Also it is no long a long running service, i.e. it spins up when your Spark job starts, then terminates when your job is done. The sidecar follows the security best practice via leveraging Secrets Manager to extract JDBC crednetials. However, the maintenance of the sidecar increases because you now need to manage the hms sidecar, custom configmaps and sidecar pod templates. Also this solution requires combination skills of analytics and k8s. </p> <p>The CDK/CFN template is available to simplify the installation against a new EKS cluster. If you have an existing EKS cluster, the prerequisite details can be found in the github repository</p> <p>sidecar_hivethrift_eks.py:</p> <pre><code>import sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\",environ['warehouse_location']) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\nspark.sql(\"SHOW DATABASES\").show()\nspark.sql(\"CREATE DATABASE IF NOT EXISTS `demo`\")\nspark.sql(\"DROP TABLE IF EXISTS demo.amazonreview4\")\nspark.sql(\"CREATE EXTERNAL TABLE `demo`.`amazonreview4`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\"+sys.argv[1]+\"/app_code/data/toy/'\")\nspark.sql(\"SELECT coount(*) FROM demo.amazonreview4\").show()\nspark.stop()\n</code></pre> <p>Request:</p> <p>Now that the HMS is running inside your Spark driver, it shares common attributes such as the network config, the <code>spark.hive.metastore.uris</code> can set to \"thrift://localhost:9083\". Don't forget to assign the sidecar pod template to the Spark Driver like this <code>\"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\"</code> </p> <p>For more details, check out the github repo</p> <pre><code>#!/bin/bash\n# test HMS sidecar on EKS\naws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name sidecar-hms \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.3.0-latest \\\n--job-driver '{\n  \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hivethrift_eks.py\",\n      \"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n      \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\\n--configuration-overrides '{\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\",\n          \"spark.hive.metastore.uris\": \"thrift://localhost:9083\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre>"},{"location":"metastore-integrations/docs/hive-metastore/#5-hudi-remote-hive-metastore-integration","title":"5-Hudi + Remote Hive metastore integration","text":"<p>Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Hive metastore in HMS sync mode, with this setting <code>'hoodie.datasource.hive_sync.mode': 'hms'</code>. </p> <p>This example runs a Hudi job with EMR on EKS, and interact with a remote RDS hive metastore to create a Hudi table. As a serverless option, it can interact with AWS Glue catalog. check out the AWS Glue section for more details.</p> <p>HudiEMRonEKS.py</p> <pre><code>from os import environ\nimport sys\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession \\\n    .builder \\\n    .config(\"spark.sql.warehouse.dir\", sys.argv[1]+\"/warehouse/\" ) \\\n    .enableHiveSupport() \\\n    .getOrCreate()\n\n# Create a DataFrame\ninputDF = spark.createDataFrame(\n    [\n        (\"100\", \"2015-01-01\", \"2015-01-01T13:51:39.340396Z\"),\n        (\"101\", \"2015-01-01\", \"2015-01-01T12:14:58.597216Z\"),\n        (\"102\", \"2015-01-01\", \"2015-01-01T13:51:40.417052Z\"),\n        (\"103\", \"2015-01-01\", \"2015-01-01T13:51:40.519832Z\"),\n        (\"104\", \"2015-01-02\", \"2015-01-01T12:15:00.512679Z\"),\n        (\"105\", \"2015-01-02\", \"2015-01-01T13:51:42.248818Z\"),\n    ],\n    [\"id\", \"creation_date\", \"last_update_time\"]\n)\n\n# Specify common DataSourceWriteOptions in the single hudiOptions variable\ntest_tableName = \"hudi_tbl\"\nhudiOptions = {\n'hoodie.table.name': test_tableName,\n'hoodie.datasource.write.recordkey.field': 'id',\n'hoodie.datasource.write.partitionpath.field': 'creation_date',\n'hoodie.datasource.write.precombine.field': 'last_update_time',\n'hoodie.datasource.hive_sync.enable': 'true',\n'hoodie.datasource.hive_sync.table': test_tableName,\n'hoodie.datasource.hive_sync.database': 'default',\n'hoodie.datasource.write.hive_style_partitioning': 'true',\n'hoodie.datasource.hive_sync.partition_fields': 'creation_date',\n'hoodie.datasource.hive_sync.partition_extractor_class': 'org.apache.hudi.hive.MultiPartKeysValueExtractor',\n'hoodie.datasource.hive_sync.mode': 'hms'\n}\n\n\n# Write a DataFrame as a Hudi dataset\ninputDF.write \\\n.format('org.apache.hudi') \\\n.option('hoodie.datasource.write.operation', 'bulk_insert') \\\n.options(**hudiOptions) \\\n.mode('overwrite') \\\n.save(sys.argv[1]+\"/hudi_hive_insert\")\n\nprint(\"After {}\".format(spark.catalog.listTables()))\n</code></pre> <p>Request:</p> <p>The latest Hudi-spark3-bundle library is needed to support the new HMS hive sync functionality. In the following sample script, it is downloaded from maven repository when submitting a job with EMR 6.3. Starting from EMR 6.5, you don't need the <code>--jars</code> setting anymore, because EMR 6.5+ includes the Hudi-spark3-bundle library. </p> <pre><code>aws emr-containers start-job-run \\\n--virtual-cluster-id $VIRTUAL_CLUSTER_ID \\\n--name hudi-test1 \\\n--execution-role-arn $EMR_ROLE_ARN \\\n--release-label emr-6.3.0-latest \\\n--job-driver '{\n  \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\",\n      \"entryPointArguments\":[\"s3://'$S3BUCKET'\"],\n      \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\\n--configuration-overrides '{\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\",\n          \"spark.sql.hive.convertMetastoreParquet\": \"false\",\n          \"spark.hive.metastore.uris\": \"thrift://localhost:9083\",\n          \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\"\n        }}\n    ], \n    \"monitoringConfiguration\": {\n      \"s3MonitoringConfiguration\": {\"logUri\": \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\"}}}'\n</code></pre>"},{"location":"node-placement/docs/eks-node-placement/","title":"EKS Node Placement","text":""},{"location":"node-placement/docs/eks-node-placement/#single-az-placement","title":"Single AZ placement","text":"<p>AWS EKS clusters can span multiple AZs in a VPC. A Spark application whose driver and executor pods are distributed across multiple AZs can incur inter-AZ data transfer costs. To minimize or eliminate inter-AZ data transfer costs, you can configure the application to only run on the nodes within a single AZ.  In this example, we use the kubernetes node selector to specify which AZ should the job run on.</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.kubernetes.node.selector.topology.kubernetes.io/zone='&lt;availability zone&gt;' --conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: When the job starts the driver pod and executor pods are scheduled only on those EKS worker nodes with the label <code>topology.kubernetes.io/zone: &lt;availability zone&gt;</code>. This ensures the spark job is run within a single AZ. If there are not enough resources within the specified AZ, the pods will be in the <code>pending</code> state until the Autoscaler(if configured) kicks in or more resources become available.</p> <p>Spark on kubernetes Node selector configuration Kubernetes Node selector reference</p> <p>Configuration of interest - </p> <pre><code>--conf spark.kubernetes.node.selector.zone='&lt;availability zone&gt;'\n</code></pre> <p><code>zone</code> is a built-in label that EKS assigns to every EKS worker Node. The above config will ensure to schedule the driver and executor pod on those EKS worker nodes labeled - <code>topology.kubernetes.io/zone: &lt;availability zone&gt;</code>. However, user defined labels can also be assigned to EKS worker nodes and used as node selector.</p> <p>Other common use cases are using node labels to force the job to run on on demand/spot, machine type, etc.  </p>"},{"location":"node-placement/docs/eks-node-placement/#single-az-and-ec2-instance-type-placement","title":"Single AZ and ec2 instance type placement","text":"<p>Multiple key value pairs for spark.kubernetes.node.selector.[labelKey] can be passed to add filter conditions for selecting the EKS worker node. If you want to schedule on EKS worker nodes in <code>&lt;availability zone&gt;</code> and instance-type as m5.4xlarge - it is done as below  </p> <p>Request:</p> <pre><code>{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\",\n          \"spark.kubernetes.node.selector.topology.kubernetes.io/zone\":\"&lt;availability zone&gt;\",\n          \"spark.kubernetes.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n      }\n      }\n    }\n  }\n}\n</code></pre> <p>Configuration of interest </p> <p><code>spark.kubernetes.node.selector.[labelKey] - Adds to the node selector of the driver pod and executor pods, with key labelKey and the value as the configuration's value. For example, setting spark.kubernetes.node.selector.identifier to myIdentifier will result in the driver pod and executors having a node selector with key identifier and value myIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.</code></p>"},{"location":"node-placement/docs/eks-node-placement/#job-submitter-pod-placement","title":"Job submitter pod placement","text":"<p>Similar to driver and executor pods, you can configure the job submitter pod's node selectors as well using the <code>emr-job-submitter</code> classification.  It is recommended for job submitter pods to have node placement on <code>ON_DEMAND</code> nodes and not <code>SPOT</code> nodes as the job will fail if the job submitter pod gets Spot instance interruptions. You can also place the job submitter pod in a single AZ or use any Kubernetes labels that are applied to the nodes.</p> <p>Note: The job submitter pod is also referred as the job-runner pod</p> <p>StartJobRun request with ON_DEMAND node placement for job submitter pod</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector-job-submitter.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      },\n      {\n        \"classification\": \"emr-job-submitter\",\n        \"properties\": {\n            \"jobsubmitter.node.selector.eks.amazonaws.com/capacityType\": \"ON_DEMAND\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector-job-submitter.json\n</code></pre> <p>StartJobRun request with Single AZ node placement for job submitter pod:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector-job-submitter-az.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      },\n      {\n        \"classification\": \"emr-job-submitter\",\n        \"properties\": {\n            \"jobsubmitter.node.selector.topology.kubernetes.io/zone\": \"&lt;availability zone&gt;\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector-job-submitter-az.json\n</code></pre> <p>StartJobRun request with single AZ and ec2 instance type placement for job submitter pod:</p> <pre><code>{\n  \"name\": \"spark-python-in-s3-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\",\n         }\n      },\n      {\n        \"classification\": \"emr-job-submitter\",\n        \"properties\": {\n            \"jobsubmitter.node.selector.topology.kubernetes.io/zone\": \"&lt;availability zone&gt;\",\n            \"jobsubmitter.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\"\n        }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n      }\n      }\n    }\n  }\n}\n</code></pre> <p>Configurations of interest:</p> <p><code>jobsubmitter.node.selector.[labelKey]</code>: Adds to the node selector of the job submitter pod, with key <code>labelKey</code> and the value as the configuration's value. For example, setting <code>jobsubmitter.node.selector.identifier</code> to <code>myIdentifier</code> will result in the job-runner pod having a node selector with key identifier and value <code>myIdentifier</code>. Multiple node selector keys can be added by setting multiple configurations with this prefix.</p>"},{"location":"node-placement/docs/fargate-node-placement/","title":"EKS Fargate Node Placement","text":""},{"location":"node-placement/docs/fargate-node-placement/#fargate-node-placement","title":"Fargate Node Placement","text":"<p>AWS Fargate is a technology that provides on-demand, right-sized compute capacity for containers. With AWS Fargate, you don't have to provision, configure, or scale groups of EC2 instances on your own to run containers. You also don't need to choose server types, decide when to scale your node groups, or optimize cluster packing. Instead you can control which pods start on Fargate and how they run with Fargate profiles.</p>"},{"location":"node-placement/docs/fargate-node-placement/#aws-fargate-profile","title":"AWS Fargate profile","text":"<p>Before you can schedule pods on Fargate in your cluster, you must define at least one Fargate profile that specifies which pods use Fargate when launched.  You must define a namespace for every selector. The Fargate profile allows an administrator to declare which pods run on Fargate. This declaration is done through the profile\u2019s selectors. If a namespace selector is defined without any labels, Amazon EKS attempts to schedule all pods that run in that namespace onto Fargate using the profile.</p> <p>Create Fargate Profile Create your Fargate profile with the following eksctl command, replacing the <code>&lt;variable text&gt;</code> (including &lt;&gt;) with your own values. You're required to specify a namespace. The <code>--labels</code> option is not required to create your Fargate profile, but will be required if you want to only run Spark executors on Fargate.</p> <pre><code>eksctl create fargateprofile \\\n    --cluster &lt;cluster_name&gt; \\\n    --name &lt;fargate_profile_name&gt; \\\n    --namespace &lt;virtual_cluster_mapped_namespace&gt; \\\n    --labels spark-node-placement=fargate\n</code></pre>"},{"location":"node-placement/docs/fargate-node-placement/#1-place-entire-job-including-driver-pod-on-fargate","title":"1- Place entire job including driver pod on Fargate","text":"<p>When both Driver and Executors use the same labels as the Fargate Selector, the entire job including the driver pod will run on Fargate.</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-fargate-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=4  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n            \"spark.kubernetes.driver.label.spark-node-placement\": \"fargate\",\n            \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: When the job starts, the driver pod and executor pods are scheduled only on Fargate since both are labeled with the <code>spark-node-placement: fargate</code>. This is useful when we want to run the entire job on Fargate nodes. The maximum vCPU available for the driver pod is 4vCPU. </p>"},{"location":"node-placement/docs/fargate-node-placement/#2-place-driver-pod-on-ec2-and-executor-pod-on-fargate","title":"2- Place driver pod on EC2 and executor pod on Fargate","text":"<p>Remove the label from the driver pod to schedule the driver pod on EC2 instances. This is especially helpful when driver pod needs more resources (i.e. &gt; 4 vCPU).</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-fargate-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=6 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n            \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: When the job starts, the driver pod schedules on an EC2 instance. EKS picks an instance from the first Node Group that has the matching resources available to the driver pod.</p>"},{"location":"node-placement/docs/fargate-node-placement/#3-define-a-nodeselector-in-pod-templates","title":"3- Define a NodeSelector in Pod Templates","text":"<p>Beginning with Amazon EMR versions 5.33.0 or 6.3.0, Amazon EMR on EKS supports Spark\u2019s pod template feature. Pod templates are specifications that determine how to run each pod. You can use pod template files to define the driver or executor pod\u2019s configurations that Spark configurations do not support. For example Spark configurations do not support defining individual node selectors for the driver pod and the executor pods. Define a node selector only for the driver pod when you want to choose on which pool of EC2 instance it should schedule. Let the Fargate Profile schedule the executor pods.</p> <p>Driver Pod Template</p> <pre><code>apiVersion: v1\nkind: Pod\nspec:\nvolumes:\n- name: source-data-volume\nemptyDir: {}\n- name: metrics-files-volume\nemptyDir: {}\nnodeSelector:\n&lt;ec2-instance-node-label-key&gt;: &lt;ec2-instance-node-label-value&gt;\ncontainers:\n- name: spark-kubernetes-driver # This will be interpreted as Spark driver container\n</code></pre> <p>Store the pod template file onto a S3 location:</p> <p><code>aws s3 cp /driver-pod-template.yaml s3://&lt;your-bucket-name&gt;/driver-pod-template.yaml</code></p> <p>Request</p> <pre><code>cat &gt;spark-python-in-s3-nodeselector.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-fargate-nodeselector\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.3.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n            \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\",\n            \"spark.kubernetes.driver.podTemplateFile\": \"s3://&lt;your-bucket-name&gt;/driver-pod-template.yaml\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json\n</code></pre> <p>Observed Behavior: The driver pod schedules on an EC2 instance with enough capacity and matching label key / value with the node selector.</p>"},{"location":"outposts/emr-containers-on-outposts/","title":"Running EMR Containers on AWS Outposts","text":""},{"location":"outposts/emr-containers-on-outposts/#background","title":"Background","text":"<p>You can now run Amazon EMR container jobs on EKS clusters that are running on AWS Outposts. AWS Outposts enables native AWS services, infrastructure, and operating models in on-premises facilities. In AWS Outposts environments, you can use the same AWS APIs, tools, and infrastructure that you use in the AWS Cloud. Amazon EKS nodes on AWS Outposts is ideal for low-latency workloads that need to be run in close proximity to on-premises data and applications. For more information, see the Amazon EKS on Outposts documentation page.</p> <p>This document provides the steps to set up EMR containers on AWS Outposts.</p> <p></p>"},{"location":"outposts/emr-containers-on-outposts/#key-considerations-and-recommendations","title":"Key Considerations and Recommendations","text":"<ul> <li>The EKS cluster on an Outpost must be created with self-managed node groups.</li> <li>Use the AWS Management Console and AWS CloudFormation to create a self-managed node group in Outposts.</li> <li>For EMR workloads, we recommend creating EKS clusters where all the worker nodes reside in the self-managed node group of Outposts.</li> <li>The Kubernetes client in the Spark driver pod creates and monitor executor pods by communicating with the EKS managed Kubernetes API server residing in the parent AWS Region. For reliable monitoring of executor pods during a job run, we also recommend having a reliable low latency link between the Outpost and the parent Region.</li> <li>AWS Fargate is not available on Outposts.</li> <li>For more information about the supported Regions, prerequisites and considerations for Amazon EKS on AWS Outposts, see the EKS on Outposts documentation page.</li> </ul>"},{"location":"outposts/emr-containers-on-outposts/#infrastructure-setup","title":"Infrastructure Setup","text":""},{"location":"outposts/emr-containers-on-outposts/#setup-eks-on-outposts","title":"Setup EKS on Outposts","text":"<p>Network Setup </p> <ul> <li>Setup a VPC</li> </ul> <pre><code>aws ec2 create-vpc \\\n--region &lt;us-west-2&gt; \\\n--cidr-block '&lt;10.0.0.0/16&gt;'\n</code></pre> <p>In the output, take note of the VPC ID. </p> <pre><code>{\n    \"Vpc\": {\n        \"VpcId\": \"vpc-123vpc\", \n        ...\n    }\n}\n</code></pre> <ul> <li>Create two subnets in the parent Region.</li> </ul> <pre><code>aws ec2 create-subnet \\\n--region '&lt;us-west-2&gt;' \\\n--availability-zone-id '&lt;usw2-az1&gt;' \\\n--vpc-id '&lt;vpc-123vpc&gt;' \\\n--cidr-block '&lt;10.0.1.0/24&gt;'\n\naws ec2 create-subnet \\\n--region '&lt;us-west-2&gt;' \\\n--availability-zone-id '&lt;usw2-az2&gt;' \\\n--vpc-id '&lt;vpc-123vpc&gt;' \\\n--cidr-block '&lt;10.0.2.0/24&gt;'\n</code></pre> <p>In the output, take note of the Subnet ID.</p> <pre><code>{\n    \"Subnet\": {\n        \"SubnetId\": \"subnet-111\",\n        ...\n    }\n}\n{\n    \"Subnet\": {\n        \"SubnetId\": \"subnet-222\",\n        ...\n    }\n}\n</code></pre> <ul> <li>Create a subnet in the Outpost Availability Zone. (This step is different for Outposts)</li> </ul> <pre><code>aws ec2 create-subnet \\\n--region '&lt;us-west-2&gt;' \\\n--availability-zone-id '&lt;usw2-az1&gt;' \\\n--outpost-arn 'arn:aws:outposts:&lt;us-west-2&gt;:&lt;123456789&gt;:outpost/&lt;op-123op&gt;' \\\n--vpc-id '&lt;vpc-123vpc&gt;' \\\n--cidr-block '&lt;10.0.3.0/24&gt;'\n</code></pre> <p>In the output, take note of the Subnet ID.</p> <pre><code>{\n    \"Subnet\": {\n        \"SubnetId\": \"subnet-333outpost\",\n        \"OutpostArn\": \"...\"\n        ...\n    }\n}\n</code></pre> <p>EKS Cluster Creation </p> <ul> <li>Create an EKS cluster using the three subnet Ids created earlier.</li> </ul> <pre><code>aws eks create-cluster \\\n--region '&lt;us-west-2&gt;' \\\n--name '&lt;outposts-eks-cluster&gt;' \\\n--role-arn 'arn:aws:iam::&lt;123456789&gt;:role/&lt;cluster-service-role&gt;' \\\n--resources-vpc-config  subnetIds='&lt;subnet-111&gt;,&lt;subnet-222&gt;,&lt;subnet-333outpost&gt;'\n</code></pre> <ul> <li>Check until the cluster status becomes active.</li> </ul> <pre><code>aws eks describe-cluster \\\n--region '&lt;us-west-2&gt;' \\\n--name '&lt;outposts-eks-cluster&gt;'\n</code></pre> <p>Note the values of resourcesVpcConfig.clusterSecurityGroupId and identity.oidc.issuer.</p> <pre><code>{\n    \"cluster\": {\n        \"name\": \"outposts-eks-cluster\",\n        ...\n        \"resourcesVpcConfig\": {\n            \"clusterSecurityGroupId\": \"sg-123clustersg\",\n        },\n        \"identity\": {\n            \"oidc\": {\n                \"issuer\": \"https://oidc.eks.us-west-2.amazonaws.com/id/oidcid\"\n            }\n        },\n        \"status\": \"ACTIVE\",\n    }\n}\n</code></pre> <ul> <li>Add the Outposts nodes to the EKS Cluster.</li> </ul> <p>At this point, eksctl cannot be used to launch self-managed node groups in Outposts. Please follow the steps listed in the self-managed nodes documentation page. In order to use the cloudformation script lised in the AWS Management Console tab, make note of the following values created in the earlier steps: * ClusterName: <code>&lt;outposts-eks-cluster&gt;</code> * ClusterControlPlaneSecurityGroup: <code>&lt;sg-123clustersg&gt;</code> * Subnets: <code>&lt;subnet-333outpost&gt;</code></p> <p>Apply the aws-auth-cm config map listed on the documentation page to allow the nodes to join the cluster.</p>"},{"location":"outposts/emr-containers-on-outposts/#register-cluster-with-emr-containers","title":"Register cluster with EMR Containers","text":"<p>Once the EKS cluster has been created and the nodes have been registered with the EKS control plane, take the following steps:</p> <ul> <li>Enable cluster access for Amazon EMR on EKS.</li> <li>Enable IAM Roles for Service Accounts (IRSA) on the EKS cluster.</li> <li>Create a job execution role.</li> <li>Update the trust policy of the job execution role.</li> <li>Grant users access to Amazon EMR on EKS.</li> <li>Register the Amazon EKS cluster with Amazon EMR.</li> </ul>"},{"location":"outposts/emr-containers-on-outposts/#conclusion","title":"Conclusion","text":"<p>EMR-EKS on Outposts allows users to run their big data jobs in close proximity to on-premises data and applications.</p>"},{"location":"performance/docs/dra/","title":"Dynamic Resource Allocation","text":"<p>DRA is available in Spark 3 (EMR 6.x) without the need for an external shuffle service. Spark on Kubernetes doesn't support external shuffle service as of spark 3.1, but DRA can be achieved by enabling shuffle tracking.</p> <p>Spark DRA without external shuffle service: With DRA, the spark driver spawns the initial number of executors and then scales up the number until the specified maximum number of executors is met to process the pending tasks. Idle executors are terminated when there are no pending tasks, the executor idle time exceeds the idle timeout(<code>spark.dynamicAllocation.executorIdleTimeout)</code>and it doesn't have any cached or shuffle data.</p> <p>If the executor idle threshold is reached and it has cached data, then it has to exceed the cache data idle timeout(<code>spark.dynamicAllocation.cachedExecutorIdleTimeout)</code> and if the executor doesn't have shuffle data, then the idle executor is terminated.</p> <p>If the executor idle threshold is reached and it has shuffle data, then without external shuffle service the executor will never be terminated. These executors will be terminated when the job is completed. This behavior is enforced by <code>\"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\" and \"spark.dynamicAllocation.enabled\":\"true\"</code></p> <p>If <code>\"spark.dynamicAllocation.shuffleTracking.enabled\":\"false\"and \"spark.dynamicAllocation.enabled\":\"true\"</code> then the spark application will error out since external shuffle service is not available.</p> <p>Request:</p> <pre><code>cat &gt;spark-python-in-s3-dra.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-dra\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count.py\", \n       \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"true\",\n          \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\",\n          \"spark.dynamicAllocation.minExecutors\":\"5\",\n          \"spark.dynamicAllocation.maxExecutors\":\"100\",\n          \"spark.dynamicAllocation.initialExecutors\":\"10\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n</code></pre> <pre><code>aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dra.json\n</code></pre> <p>Observed Behavior: When the job gets started, the driver pod gets created and 10 executors are initially created. (<code>\"spark.dynamicAllocation.initialExecutors\":\"10\"</code>) Then the number of executors can scale up to a maximum of 100 (<code>\"spark.dynamicAllocation.maxExecutors\":\"100\"</code>).  Configurations to note: </p> <p><code>spark.dynamicAllocation.shuffleTracking.enabled</code> - <code>**</code>Experimental<code>**</code>. Enables shuffle file tracking for executors, which allows dynamic allocation without the need for an external shuffle service. This option will try to keep alive executors that are storing shuffle data for active jobs.</p> <p><code>spark.dynamicAllocation.shuffleTracking.timeout</code> - When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle data. The default value means that Spark will rely on the shuffles being garbage collected to be able to release executors. If for some reason garbage collection is not cleaning up shuffles quickly enough, this option can be used to control when to time out executors even when they are storing shuffle data.</p>"},{"location":"security/docs/spark/data-encryption/","title":"EMR Containers Spark - In transit and At Rest data encryption","text":""},{"location":"security/docs/spark/data-encryption/#encryption-at-rest","title":"Encryption at Rest","text":""},{"location":"security/docs/spark/data-encryption/#amazon-s3-client-side-encryption","title":"Amazon S3 Client-Side Encryption","text":"<p>To utilize S3 Client side encryption, you will need to create a KMS Key to be used to encrypt and decrypt data. If you do not have an KMS key, please follow this guide - AWS KMS create keys. Also please note the job execution role needs access to this key, please see Add to Key policy for instructions on how to add these permissions.</p> <p>trip-count-encrypt-write.py:</p> <pre><code>cat&gt; trip-count-encrypt-write.py&lt;&lt;EOF\nimport sys\n\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"trip-count-join-fsx\")\\\n        .getOrCreate()\n\n    df = spark.read.parquet('s3://&lt;s3 prefix&gt;/trip-data.parquet')\n    print(\"Total trips: \" + str(df.count()))\n\n    df.write.parquet('s3://&lt;s3 prefix&gt;/write-encrypt-trip-data.parquet')\n    print(\"Encrypt - KMS- CSE writew to s3 compeleted\")\n    spark.stop()\n    EOF\n</code></pre> <p>Request: </p> <pre><code>cat &gt; spark-python-in-s3-encrypt-cse-kms-write.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;trip-count-encrypt-write.py\", \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n       },\n       {\n         \"classification\": \"emrfs-site\", \n         \"properties\": {\n          \"fs.s3.cse.enabled\":\"true\",\n          \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\",\n          \"fs.s3.cse.kms.keyId\":\"&lt;KMS Key Id&gt;\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\", \n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json\n</code></pre> <p>In the above request, EMRFS encrypts the parquet file with the specified KMS key and the encrypted object is persisted to the specified s3 location.</p> <p>To verify the encryption - use the same KMS key to decrypt - the KMS key used is a symmetric key ( the same key can be used to both encrypt and decrypt)</p> <p>trip-count-encrypt-read.py </p> <pre><code>cat &gt; trip-count-encrypt-read.py&lt;&lt;EOF\nimport sys\n\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"trip-count-join-fsx\")\\\n        .getOrCreate()\n\n    df = spark.read.parquet('s3://&lt;s3 prefix&gt;/trip-data.parquet')\n    print(\"Total trips: \" + str(df.count()))\n\n    df_encrypt = spark.read.parquet('s3://&lt;s3 prefix&gt;/write-encrypt-trip-data.parquet')\n    print(\"Encrypt data - Total trips: \" + str(df_encrypt.count()))\n    spark.stop()\n   EOF\n</code></pre> <p>Request</p> <pre><code>cat &gt; spark-python-in-s3-encrypt-cse-kms-read.json&lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-encrypt-cse-kms-read\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;trip-count-encrypt-write.py\", \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n       },\n       {\n         \"classification\": \"emrfs-site\", \n         \"properties\": {\n          \"fs.s3.cse.enabled\":\"true\",\n          \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\",\n          \"fs.s3.cse.kms.keyId\":\"&lt;KMS Key Id&gt;\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\", \n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-read.json\n</code></pre> <p>Validate encryption: Try to read the encrypted data without specifying <code>\"fs.s3.cse.enabled\":\"true\"</code> - will get an error message in the driver and executor logs because the content is encrypted and cannot be read without decryption.</p>"},{"location":"security/docs/spark/encryption/","title":"EMR on EKS - Encryption Best Practices","text":"<p>This document will describe how to think about security and its best practices when applying to EMR on EKS service. We will cover topics related to encryption at rest and in-transit when you run EMR on EKS jobs on EKS cluster.</p> <p>It's important to understand the shared responsibility model when using managed services such as EMR on EKS in order to improve the overall security posture of your environment. Generally speaking AWS is responsible for security \"of\" the cloud whereas you, the customer, are responsible for security \"in\" the cloud. The diagram below depicts this high level definition. </p>"},{"location":"security/docs/spark/encryption/#shared-responsibility-model","title":"Shared responsibility model","text":"<p>EMR on EKS provides simple way to run spark jobs on top of EKS clusters. The architecture itself is loosely coupled and is abstracted from customers so that they can run secure environment for running spark applications. Because EMR on EKS uses combination of two services (EMR and EKS) at a minimal, we will cover how EKS enables infrastructure components that are consumable by EMR spark workload and how to handle encryption for each service.</p> <p>AWS assumes different levels of responsibility depending on the features being consumed by EMR on EKS customers. At this time of writing, the features from EKS are managed node groups, self-managed workers, and Fargate. We won\u2019t go in-depth on these architectures as they are detailed in EKS best practices guide (https://aws.github.io/aws-eks-best-practices/security/docs/). Below diagrams depict how this responsibility changes between customer and AWS based on consumed features.</p> <p> </p>"},{"location":"security/docs/spark/encryption/#encryption-for-data-in-transit","title":"Encryption for data in-transit","text":"<p>In this section, we will cover encryption for data in-transit. We will highlight AWS platform capabilities from the physical layer and then review how AWS handles encryption in the EMR on EKS architecture layer. Lastly, we will cover how customers can enable encryption between spark drivers and executors.</p>"},{"location":"security/docs/spark/encryption/#aws-infrastructure-physical-layer","title":"AWS Infrastructure - Physical layer","text":"<p>AWS provides secure and private connectivity between EC2 instances of all types. All data flowing across AWS Regions over the AWS global network is automatically encrypted at the physical layer before it leaves AWS secured facilities. All traffic between AZs is encrypted. All cross-Region traffic that uses Amazon VPC and Transit Gateway peering is automatically bulk-encrypted when it exits a Region. In addition, if you use Nitro family of instances, all traffic between instances is encrypted in-transit using AEAD algorithms with 256-bit encryption. We highly recommend reviewing EC2 documentation for more information.</p>"},{"location":"security/docs/spark/encryption/#amazon-emr-on-eks","title":"Amazon EMR on EKS","text":"<p>Below diagram depicts high-level architecture implementation of EMR on EKS. In this section, we will cover encryption in-transit for communication between managed services such as EMR &amp; EKS. All traffic with AWS API\u2019s that support EMR and EKS are encrypted by default. EKS enables Kubernetes API server using https endpoint. Both the kubelet that runs on EKS worker nodes and Kubernetes client such as kubectl interacts with EKS cluster API using TLS. Amazon EMR on EKS uses the same secure channel to interact with EKS cluster API to run spark jobs on worker nodes. In addition, EMR on EKS provides an encrypted endpoint for accessing spark history server.  </p> <p></p> <p>Spark offers AES-based encryption for RPC connections. EMR on EKS customers may choose to encrypt the traffic between spark drivers and executors using this encryption mechanism. In order to enable encryption, RPC authentication must also be enabled in your spark configuration.</p> <pre><code>--conf spark.authenticate=true \\\n--conf spark.network.crypto.enabled=true \\\n</code></pre> <p>The encryption key is generated by the driver and distributed to executors via environment variables. Because these environment variables can be accessed by users who have access to Kubernetes API (kubectl), we recommend securing access so that only authorized users have access to your environment. You should also configure proper Kubernetes RBAC permissions so that only authorized service accounts can use these variables.</p>"},{"location":"security/docs/spark/encryption/#encryption-for-data-at-rest","title":"Encryption for data at-rest","text":"<p>In this section, we will cover encryption for data at-rest. We will review how to enable storage-level encryption so that it is transparent for spark application to use this data securely. We will also see how to enable encryption from spark application while using AWS native storage options.</p>"},{"location":"security/docs/spark/encryption/#amazon-s3","title":"Amazon S3","text":"<p>Amazon S3 offers server-side encryption for encrypting all data that is stored in an S3 bucket. You can enable default encryption using either S3 managed keys (SSE-S3) or KMS managed keys (SSE-KMS). Amazon S3 will encrypt all data before storing it on disks based on the keys specified. We recommend using server-side encryption at a minimum so that your data at-rest is encrypted. Please review Amazon S3 documentation and use the mechanisms that apply to your encryption standards and acceptable performance.</p> <p>Amazon S3 supports client-side encryption as well. Using this approach, you can let spark application to encrypt all data with desired KMS keys and upload this data to S3 buckets. Below examples shows spark application reading and writing parquet data in S3. During job submission, we use EMRFS encryption mechanism to encrypt all data with KMS key into the desired S3 location.</p> <pre><code>import sys\n\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"trip-count-join-fsx\")\\\n        .getOrCreate()\n\n    df = spark.read.parquet('s3://&lt;s3 prefix&gt;/trip-data.parquet')\n    print(\"Total trips: \" + str(df.count()))\n\n    df.write.parquet('s3://&lt;s3 prefix&gt;/write-encrypt-trip-data.parquet')\n    print(\"Encrypt - KMS- CSE writew to s3 compeleted\")\n    spark.stop()\n</code></pre> <p>Below is the job submission request that depicts KMS specification needed for EMRFS to perform this encryption. For complete end-to-end example, please see EMR on EKS best practices documentation</p> <pre><code>cat &gt; spark-python-in-s3-encrypt-cse-kms-write.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\",\n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\",\n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\",\n  \"releaseLabel\": \"emr-6.2.0-latest\",\n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;trip-count-encrypt-write.py\",\n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2  --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\"\n    }\n  },\n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\",\n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n       },\n       {\n         \"classification\": \"emrfs-site\",\n         \"properties\": {\n          \"fs.s3.cse.enabled\":\"true\",\n          \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\",\n          \"fs.s3.cse.kms.keyId\":\"&lt;KMS Key Id&gt;\"\n         }\n      }\n    ],\n    \"monitoringConfiguration\": {\n      \"persistentAppUI\": \"ENABLED\",\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\",\n        \"logStreamNamePrefix\": \"demo\"\n      },\n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json\n</code></pre> <p>Amazon EKS offers three different storage offerings (EBS, EFS, FSx) that can be directly consumed by pods. Each storage offering provides encryption mechanism that can be enabled at the storage level.</p>"},{"location":"security/docs/spark/encryption/#amazon-ebs","title":"Amazon EBS","text":"<p>Amazon EBS supports default encryption that can be turned on a per-region basis. Once it's turned on, you can have newly created EBS volumes and snapshots encrypted using AWS managed KMS keys. Please review EBS documentation to learn more on how to enable this feature</p> <p>You can use Kubernetes (k8s) in-tree storage driver or choose to use EBS CSI driver to consume EBS volumes within your pods. Both choices offer options to enable encryption. In the below example, we use k8s in-tree storage driver to create storage class and persistent volume claim. You can create similar resources using EBS CSI driver as well.  </p> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\nname: encrypted-sc\nprovisioner: kubernetes.io/aws-ebs\nvolumeBindingMode: WaitForFirstConsumer\nparameters:\ntype: gp2\nfsType: ext4\nencrypted: \"true\"\n\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\nname: spark-driver-pvc\nspec:\nstorageClassName: encrypted-sc\naccessModes:\n- ReadWriteOnce\nresources:\nrequests:\nstorage: 10Gi\n</code></pre> <p>Once these resources are created, you can specify them in your drivers and executors. You can see an example of this specification below. Keep in mind, you can only attach an EBS volume to single EC2 instance or a Kubernetes pod. Therefore, if you have multiple executor pods, you need to create multiple PVCs to fulfill this request </p> <pre><code>--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data\n...\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=spark-executor-pvc\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data\n</code></pre> <p>Another approach is to let k8s create EBS volumes dynamically based on your spark workload. You can do so by specifying just the storageClass  and sizeLimit  options and specify OnDemand for the persistent volume claim (PVC). This is useful in case of Dynamic Resource Allocation. Please be sure to use EMR 6.3.0 release and above to use this feature because dynamic PVC support was added in Spark 3.1. Below is an example for dynamically creating volumes for executors within your job</p> <pre><code>--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=OnDemand\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.storageClass=encrypted-sc\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.sizeLimit=10Gi\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName=OnDemand\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.storageClass=encrypted-sc\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.sizeLimit=10Gi\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path=/var/data/spill\n--conf spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly=false\n</code></pre> <p>For a complete list of available options, please refer to the Spark Documentation</p>"},{"location":"security/docs/spark/encryption/#amazon-efs","title":"Amazon EFS","text":"<p>Similar to EBS, you can consume EFS volumes via EFS CSI driver and FSx for Lustre volumes via FSx CSI driver. There are two provisioning methods before these storage volumes are consumed by workloads, namely static provisioning and dynamic provisioning. For static provisioning, you have to pre-create volumes using AWS API\u2019s, CLI or AWS console. For dynamic provisioning, volume is created dynamically by the CSI drivers as workloads are deployed onto Kubernetes cluster. Currently, EFS CSI driver doesn\u2019t support dynamic volume provisioning. However, you can create the volume using EFS API or AWS console before creating a persistent volume (PV) that can be used within your spark application. If you plan to encrypt the data stored in EFS, you need to specify encryption during volume creation. For further information about EFS file encryption, please refer to Encrypting Data at Rest. One of the advantages of using EFS is that it provides encryption in transit support using TLS and it's enabled by default by the CSI driver. You can see the example below if you need to enforce TLS encryption during PV creation</p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: efs-pv\nspec:\ncapacity:\nstorage: 5Gi\nvolumeMode: Filesystem\naccessModes:\n- ReadWriteOnce\npersistentVolumeReclaimPolicy: Retain\nstorageClassName: efs-sc\ncsi:\ndriver: efs.csi.aws.com\nvolumeHandle: fs-4af69aab\nvolumeAttributes:\nencryptInTransit: \"true\"\n</code></pre>"},{"location":"security/docs/spark/encryption/#amazon-fsx-for-lustre","title":"Amazon FSx for Lustre","text":"<p>Amazon FSx CSI driversupports both static and dynamic provisioning. Encryption for data in-transit is automatically enabled from Amazon EC2 instances that support encryption in transit. To learn which EC2 instances support encryption in transit, see Encryption in Transit in the Amazon EC2 User Guide for Linux Instances. Encryption for data at rest is automatically enabled when you create the FSx filesystem. Amazon FSx for Lustre supports two types of filesystems, namely persistent and scratch. You can use the default encryption method where encryption keys are managed by Amazon FSx. However, if you prefer to manage your own KMS keys, you can do so for persistent filesystem. The example below shows how to create storage class using FSx for Lustre for persistent filesystem using your own KMS managed keys.</p> <pre><code>kind: StorageClass\napiVersion: storage.k8s.io/v1\nmetadata:\nname: fsx-sc\nprovisioner: fsx.csi.aws.com\nparameters:\nsubnetId: subnet-056da83524edbe641\nsecurityGroupIds: sg-086f61ea73388fb6b\ndeploymentType: PERSISTENT_1\nkmsKeyId: &lt;kms_arn&gt;\n</code></pre> <p>You can then create persistent volume claim (see an example in FSx repo) and use within your spark application as below</p> <pre><code>--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=fsx-claim\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false\n--conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data\n</code></pre>"},{"location":"security/docs/spark/encryption/#using-spark-to-encrypt-data","title":"Using Spark to encrypt data","text":"<p>Apache Spark supports encrypting temporary data that is stored on storage volumes. These volumes can be instance storage such as NVMe SSD volumes, EBS, EFS or FSx volumes. Temporary data can be shuffle files, shuffle spills and data blocks stored on disk (for both caching and broadcast variables). It's important to note that the data on NVMe instance storage is encrypted using an XTS-AES-256 block cipher implemented in a hardware module on the instance. Even though, instance storage is available, you need to format and mount them while you bootstrap EC2 instances. Below is an example to show how to use instance storage using eksctl</p> <pre><code>managedNodeGroups:\n- name: nvme\n  minSize: 2\n  desiredCapacity: 2\n  maxSize: 10\n  instanceType: r5d.4xlarge\n  ssh:\n    enableSsm: true\n  preBootstrapCommands:\n    - IDX=1\n    - for DEV in /dev/disk/by-id/nvme-Amazon_EC2_NVMe_Instance_Storage_*-ns-1; do  mkfs.xfs ${DEV};mkdir -p /local${IDX};echo ${DEV} /local${IDX} xfs defaults,noatime 1 2 &gt;&gt; /etc/fstab; IDX=$((${IDX} + 1)); done\n    - mount -a\n</code></pre> <p>If you use non-NVMe SSD volumes, you can follow the best practice to encrypt shuffle data before you write them to disks. You can see an example below that shows this example. For more information about the type of instance store volume supported by each instance type, see Instance store volumes.</p> <pre><code>--conf spark.io.encryption.enabled=true\n</code></pre>"},{"location":"security/docs/spark/encryption/#conclusion","title":"Conclusion","text":"<p>In this document, we covered shared responsibility model for running EMR on EKS workload. We then reviewed platform capabilities available through AWS infrastructure and how to enable encryption for both storage-level and via spark application. To quote Werner Vogels, AWS CTO \u201cSecurity is everyone\u2019s job now, not just the security team\u2019s\u201d. We hope this document provides prescriptive guidance into how to enable encryption for running secure EMR on EKS workload.   </p>"},{"location":"security/docs/spark/network-security/","title":"Managing VPC for EMR on EKS","text":"<p>This section address network security at VPC level. If you want to read more on network security for Spark in EMR on EKS please refer to this section.</p>"},{"location":"security/docs/spark/network-security/#security-group","title":"Security Group","text":"<p>The applications running on your EMR on EKS cluster often would need access to services that are running outside the cluster,  for example, these can Amazon Redshift, Amazon Relational Database Service, a service self hosted on an EC2 instance. To access these resource you need to allow network traffic at the security group level. The default mechanism in EKS is using security groups at the node level,  this means all the pods running on the node will inherit the rules on the security group.  For security conscious customers, this is not a desired behavior and you would want to use security groups at the pod level.</p> <p>This section address how you can use Security Groups with EMR on EKS.</p>"},{"location":"security/docs/spark/network-security/#configure-eks-cluster-to-use-security-groups-for-pods","title":"Configure EKS Cluster to use Security Groups for Pods","text":"<p>In order to use Security Groups at the pod level, you need to configure the VPC CNI for EKS. The following link guide through the prerequisites as well as configuring the EKS Cluster.</p>"},{"location":"security/docs/spark/network-security/#define-securitygrouppolicy","title":"Define SecurityGroupPolicy","text":"<p>Once you have configured the VPC CNI, you need to create a SecurityGroupPolicy object.  This object define which security group (up to 5) to use, podselector to define which pod to apply the security group to and  the namespace in which the Security Group should be evaluated. Below you find an example of <code>SecurityGroupPolicy</code>.</p> <pre><code>apiVersion: vpcresources.k8s.aws/v1beta1\nkind: SecurityGroupPolicy\nmetadata:\nname: &lt;&gt;\nnamespace: &lt;NAMESPACE FOR VC&gt;\nspec:\npodSelector: matchLabels:\nrole: spark\nsecurityGroups:\ngroupIds:\n- sg-xxxxx\n</code></pre>"},{"location":"security/docs/spark/network-security/#define-pod-template-to-use-security-group-for-pod","title":"Define pod template to use Security Group for pod","text":"<p>In order for the security group to be applied to the Spark driver and executors, you need to provide a podtemplate which add label(s) to the pods. The labels should match the one defined above in the <code>podSelector</code> in our example it is <code>role: spark</code>.  The snippet below define the pod template that you can upload in S3 and then reference when launching your job.</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\nlabels:\nrole: spark\n</code></pre>"},{"location":"security/docs/spark/network-security/#launch-a-job","title":"Launch a job","text":"<p>The command below can be used to run a job.</p> <pre><code>    aws emr-containers start-job-run --virtual-cluster-id &lt;EMR-VIRTUAL-CLUSTER-ID&gt; --name spark-jdbc --execution-role-arn &lt;EXECUTION-ROLE-ARN&gt; --release-label emr-6.7.0-latest --job-driver '{\n    \"sparkSubmitJobDriver\": {\n    \"entryPoint\": \"&lt;S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE&gt;\",\n    \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1\"\n    }\n}' --configuration-overrides '{\n    \"applicationConfiguration\": [\n    {\n    \"classification\": \"spark-defaults\", \"properties\": {\n    \"spark.hadoop.hive.metastore.client.factory.class\": \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n    \"spark.sql.catalogImplementation\": \"hive\",\n    \"spark.dynamicAllocation.enabled\":\"true\",\n    \"spark.dynamicAllocation.minExecutors\": \"8\",\n    \"spark.dynamicAllocation.maxExecutors\": \"40\",\n    \"spark.kubernetes.allocation.batch.size\": \"8\",\n    \"spark.dynamicAllocation.executorAllocationRatio\": \"1\",\n    \"spark.dynamicAllocation.shuffleTracking.enabled\": \"true\",\n    \"spark.dynamicAllocation.shuffleTracking.timeout\": \"300s\",\n    \"spark.kubernetes.driver.podTemplateFile\":&lt;S3-URI-TO-DRIVER-POD-TEMPLATE&gt;,\n    \"spark.kubernetes.executor.podTemplateFile\":&lt;S3-URI-TO-EXECUTOR-POD-TEMPLATE&gt;\n}\n    }\n    ],\n    \"monitoringConfiguration\": {\n        \"persistentAppUI\": \"ENABLED\",\n        \"cloudWatchMonitoringConfiguration\": {\n            \"logGroupName\": \"/aws/emr-containers/\",\n            \"logStreamNamePrefix\": \"default\"\n}\n    }\n    }'\n</code></pre>"},{"location":"security/docs/spark/network-security/#verify-a-security-group-attached-to-the-pod-eni","title":"Verify a security group attached to the Pod ENI","text":"<p>To verify that spark driver and executor driver have the security group attached to, apply the first command to get the podname then the second one to see the annotation in pod with the ENI associated to the pod which has the secuity group defined in the SecurityGroupPolicy.</p> <pre><code>export POD_NAME=$(kubectl -n &lt;NAMESPACE&gt; get pods -l role=spark -o jsonpath='{.items[].metadata.name}')\n\nkubectl -n &lt;NAMESPACE&gt;  describe pod $POD_NAME | head -11\n</code></pre> <pre><code>Annotations:  kubernetes.io/psp: eks.privileged\nvpc.amazonaws.com/pod-eni:\n[{\"eniId\":\"eni-xxxxxxx\",\"ifAddress\":\"xx:xx:xx:xx:xx:xx\",\"privateIp\":\"x.x.x.x\",\"vlanId\":1,\"subnetCidr\":\"x.x.x.x/x\"}]\n</code></pre>"},{"location":"security/docs/spark/secrets/","title":"Using Secrets in EMR on EKS","text":"<p>Secrets can be credentials to APIs, Databases or other resources. There are various ways these secrets can be passed to your containers, some of them are pod environment variable or Kubernetes Secrets. These methods are not secure, as for environment variable, secrets are stored in clear text and any authorized user who has access to Kubernetes cluster with admin privileges can read those secrets. Storing secrets using Kubernetes secrets is also not secure because they are not encrypted and only base36 encoded.</p> <p>There is a secure method to expose these secrets in EKS through the Secrets Store CSI Driver. </p> <p>The Secrets Store CSI Driver integrate with a secret store like AWS Secrets manager and mount the secrets as volume that can be accessed through your application code. This document describes how to set and use AWS Secrets Manager with EMR on EKS through the Secrets Store CSI Driver.</p>"},{"location":"security/docs/spark/secrets/#deploy-secrets-store-csi-drivers-and-aws-secrets-and-configuration-provider","title":"Deploy Secrets Store CSI Drivers and AWS Secrets and Configuration Provider","text":""},{"location":"security/docs/spark/secrets/#secrets-store-csi-drivers","title":"Secrets Store CSI Drivers","text":"<p>Configure EKS Cluster with <code>Secrets Store CSI Driver</code>. </p> <p>To learn more about AWS Secrets Manager CSI Driver you can refer to this link</p> <pre><code>helm repo add secrets-store-csi-driver \\\n  https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts\n\nhelm install -n kube-system csi-secrets-store \\\n  --set syncSecret.enabled=true \\\n  --set enableSecretRotation=true \\\n  secrets-store-csi-driver/secrets-store-csi-driver\n</code></pre> <p>Deploy the <code>AWS Secrets and Configuration Provider</code> to use AWS Secrets Manager</p>"},{"location":"security/docs/spark/secrets/#aws-secrets-and-configuration-provider","title":"AWS Secrets and Configuration Provider","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/aws/secrets-store-csi-driver-provider-aws/main/deployment/aws-provider-installer.yaml\n</code></pre>"},{"location":"security/docs/spark/secrets/#define-the-secretproviderclass","title":"Define the <code>SecretProviderClass</code>","text":"<p>The <code>SecretProviderClass</code> is how you present your secret in Kubernetes, below you find a definition of a <code>SecretProviderClass</code>.  There are few parameters that are important:</p> <ul> <li>The <code>provider</code> must be set to <code>aws</code>.</li> <li>The <code>objectName</code> must be the name of the secret you want to use as defined in AWS.  Here the secret is called <code>db-creds</code>.</li> <li>The <code>objectType</code> must be set to <code>secretsmanager</code>.</li> </ul> <pre><code>cat &gt; db-cred.yaml &lt;&lt; EOF\n\napiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: mysql-spark-secret\nspec:\n  provider: aws\n  parameters:\n    objects: |\n        - objectName: \"db-creds\"\n          objectType: \"secretsmanager\"\nEOF\n</code></pre> <pre><code>kubectl apply -f db-cred.yaml -n &lt;NAMESPACE&gt;\n</code></pre> <p>In the terminal apply the above command to create <code>SecretProviderClass</code>,  The <code>kubectl</code> command must include the namespace where your job will be executed. </p>"},{"location":"security/docs/spark/secrets/#pod-template","title":"Pod Template","text":"<p>In the executor podtemplate you should define it as follows to mount the secret. The example below show how you can define it. There are few points that are important to mount the secret:</p> <ul> <li><code>secretProviderClass</code>: this should have the same name as the one define above. In this case it is <code>mysql-spark-secret</code>.</li> <li><code>mountPath</code>: Is where the secret is going to be available to the pod. In this example it will be in <code>/var/secrets</code> When defining the <code>mountPath</code> make sure you do not specify the ones reserved by EMR on EKS as defined here. </li> </ul> <pre><code>apiVersion: v1\nkind: Pod\n\nspec:\ncontainers:\n- name: spark-kubernetes-executors\nvolumeMounts:\n- mountPath: \"/var/secrets\"\nname: mysql-cred\nreadOnly: true\nvolumes:\n- name: mysql-cred\ncsi:\ndriver: secrets-store.csi.k8s.io\nreadOnly: true\nvolumeAttributes:\nsecretProviderClass: mysql-spark-secret\n</code></pre> <p>This podtemplate must be uploaded to S3 and referenced in the job submit command as shown below.</p> <p>Note You must make sure that the RDS instance or your Database allow traffic from the instances where your driver and executors pods are running.  </p>"},{"location":"security/docs/spark/secrets/#pyspark-code","title":"PySpark code","text":"<p>The example below shows pyspark code for connecting with a MySQL DB. The example assume the secret is stored in AWS secrets manager as defined above. The <code>username</code> is the <code>key</code> to retrieve the database <code>user</code> as stored in AWS Secrets Manager, and <code>password</code> is the <code>key</code> to retrieve the database password.</p> <p>It shows how you can retrieve the credentials from the mount point <code>/var/secrets/</code>.  The secret is stored in a file with the same name as it is defined in AWS in this case it is <code>db-creds</code>. This has been set in the podTemplate above.</p> <pre><code>from pyspark.sql import SparkSession\nimport json\n\nsecret_path = \"/var/secrets/db-creds\"\n\nf = open(secret_path, \"r\")\nmySecretDict = json.loads(f.read())\n\nspark = SparkSession.builder.getOrCreate()\n\nstr_jdbc_url=\"jdbc:&lt;DB endpoint&gt;\"\nstr_Query= &lt;QUERY&gt;\nstr_username=mySecretDict['username']\nstr_password=mySecretDict['password']\ndriver = \"com.mysql.jdbc.Driver\"\n\njdbcDF = spark.read \\\n    .format(\"jdbc\") \\\n    .option(\"url\", str_jdbc_url) \\\n    .option(\"driver\", driver)\\\n    .option(\"query\", str_Query) \\\n    .option(\"user\", str_username) \\\n    .option(\"password\", str_password) \\\n    .load()\n\njdbcDF.show()\n</code></pre>"},{"location":"security/docs/spark/secrets/#execute-the-job","title":"Execute the job","text":"<p>The command below can be used to run a job.</p> <p>Note: The supplied execution role MUST have access an IAM policy that allow it to access to the secret defined in <code>SecretProviderClass</code> above.  The IAM policy below shows the IAM actions that are needed.</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [ {\n        \"Effect\": \"Allow\",\n        \"Action\": [\"secretsmanager:GetSecretValue\", \"secretsmanager:DescribeSecret\"],\n        \"Resource\": [&lt;SECRET-ARN&gt;]\n    }]\n}\n</code></pre> <pre><code>    aws emr-containers start-job-run --virtual-cluster-id &lt;EMR-VIRTUAL-CLUSTER-ID&gt; --name spark-jdbc --execution-role-arn &lt;EXECUTION-ROLE-ARN&gt; --release-label emr-6.7.0-latest --job-driver '{\n    \"sparkSubmitJobDriver\": {\n    \"entryPoint\": \"&lt;S3-URI-FOR-PYSPARK-JOB-DEFINED-ABOVE&gt;\",\n    \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.executor.cores=2 --conf spark.driver.cores=1 --conf spark.jars=&lt;S3-URI-TO-MYSQL-JDBC-JAR&gt;\"\n    }\n}' --configuration-overrides '{\n    \"applicationConfiguration\": [\n    {\n    \"classification\": \"spark-defaults\", \"properties\": {\n    \"spark.hadoop.hive.metastore.client.factory.class\": \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\",\n    \"spark.sql.catalogImplementation\": \"hive\",\n    \"spark.dynamicAllocation.enabled\":\"true\",\n    \"spark.dynamicAllocation.minExecutors\": \"8\",\n    \"spark.dynamicAllocation.maxExecutors\": \"40\",\n    \"spark.kubernetes.allocation.batch.size\": \"8\",\n    \"spark.dynamicAllocation.executorAllocationRatio\": \"1\",\n    \"spark.dynamicAllocation.shuffleTracking.enabled\": \"true\",\n    \"spark.dynamicAllocation.shuffleTracking.timeout\": \"300s\",\n    \"spark.kubernetes.driver.podTemplateFile\":&lt;S3-URI-TO-DRIVER-POD-TEMPLATE&gt;,\n    \"spark.kubernetes.executor.podTemplateFile\":&lt;S3-URI-TO-EXECUTOR-POD-TEMPLATE&gt;\n}\n    }\n    ],\n    \"monitoringConfiguration\": {\n        \"persistentAppUI\": \"ENABLED\",\n        \"cloudWatchMonitoringConfiguration\": {\n            \"logGroupName\": \"/aws/emr-containers/\",\n            \"logStreamNamePrefix\": \"default\"\n}\n    }\n    }'\n</code></pre>"},{"location":"storage/docs/spark/ebs/","title":"Mount EBS Volume to spark driver and executor pods","text":"<p>Amazon EBS volumes can be mounted on Spark driver and executor pods through static and dynamic provisioning.</p> <p>EKS support for EBS CSI driver </p> <p>Documentation for EBS CSI driver</p>"},{"location":"storage/docs/spark/ebs/#static-provisioning","title":"Static Provisioning","text":""},{"location":"storage/docs/spark/ebs/#eks-admin-tasks","title":"EKS Admin Tasks","text":"<p>First, create your EBS volumes:</p> <pre><code>aws ec2 --region &lt;region&gt; create-volume --availability-zone &lt;availability zone&gt; --size 50\n{\n\"AvailabilityZone\": \"&lt;availability zone&gt;\", \"MultiAttachEnabled\": false, \"Tags\": [], \"Encrypted\": false, \"VolumeType\": \"gp2\", \"VolumeId\": \"&lt;vol -id&gt;\", \"State\": \"creating\", \"Iops\": 150, \"SnapshotId\": \"\", \"CreateTime\": \"2020-11-03T18:36:21.000Z\", \"Size\": 50\n}\n</code></pre> <p>Create Persistent Volume(PV) that has the EBS volume created above hardcoded:</p> <pre><code>cat &gt; ebs-static-pv.yaml &lt;&lt; EOF\napiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: ebs-static-pv\nspec:\n  capacity:\n    storage: 5Gi\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: gp2\n  awsElasticBlockStore:\n    fsType: ext4\n    volumeID: &lt;vol -id&gt;\nEOF\n\nkubectl apply -f ebs-static-pv.yaml -n &lt;namespace&gt;\n</code></pre> <p>Create Persistent Volume Claim(PVC) for the Persistent Volume created above:</p> <pre><code>cat &gt; ebs-static-pvc.yaml &lt;&lt; EOF\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: ebs-static-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  volumeName: ebs-static-pv\nEOF\n\nkubectl apply -f ebs-static-pvc.yaml -n &lt;namespace&gt;\n</code></pre> <p>PVC - <code>ebs-static-pvc</code> can be used by spark developer to mount to the spark pod  </p> <p>NOTE: Pods running in EKS worker nodes can only attach to the EBS volume provisioned in the same AZ as the EKS worker node. Use node selectors to schedule pods on EKS worker nodes the specified AZ.</p>"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks","title":"Spark Developer Tasks","text":"<p>Request</p> <pre><code>cat &gt;spark-python-in-s3-ebs-static-localdir.json &lt;&lt; EOF\n{\n\"name\": \"spark-python-in-s3-ebs-static-localdir\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-fsx.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\":\"ebs-static-pvc\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\":\"/var/spark/spill/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\":\"false\",\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-ebs-static-localdir.json\n</code></pre> <p>Observed Behavior: When the job gets started, the pre-provisioned EBS volume is mounted to driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also you can verify the mount from the driver pod's spec.</p> <pre><code>kubectl get pod &lt;driver pod name&gt; -n &lt;namespace&gt; -o yaml --export\n</code></pre>"},{"location":"storage/docs/spark/ebs/#dynamic-provisioning","title":"Dynamic Provisioning","text":"<p>Dynamic Provisioning of volumes is supported for both, driver and executors for EMR versions &gt;= 6.3.0</p>"},{"location":"storage/docs/spark/ebs/#eks-admin-tasks_1","title":"EKS Admin Tasks","text":"<p>Create EBS Storage Class</p> <pre><code>cat &gt;demo-gp2-sc.yaml &lt;&lt; EOF\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: demo-gp2-sc\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\nreclaimPolicy: Retain\nallowVolumeExpansion: true\nmountOptions:\n  - debug\nvolumeBindingMode: Immediate\nEOF\n\nkubectl apply -f demo-gp2-sc.yaml\n</code></pre> <p>create Persistent Volume for the EBS storage class - <code>demo-gp2-sc</code></p> <pre><code>cat &gt;ebs-demo-gp2-claim.yaml &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: ebs-demo-gp2-claim\n  labels:\n    app: chicago\nspec:\n  storageClassName: demo-gp2-sc\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 100Gi\nEOF\n\nkubectl apply -f ebs-demo-gp2-claim.yaml -n &lt;namespace&gt;\n</code></pre>"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks_1","title":"Spark Developer Tasks","text":"<p>Request</p> <pre><code>cat &gt;spark-python-in-s3-ebs-dynamic-localdir.json &lt;&lt; EOF\n{\n\"name\": \"spark-python-in-s3-ebs-dynamic-localdir\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-fsx.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\":\"ebs-demo-gp2-claim\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\":\"/var/spark/spill/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\":\"false\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\":\"ebs-demo-gp2-claim\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\":\"/var/spark/spillexec/\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\":\"false\"\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\nEOF\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-ebs-dynamic-localdir.json\n</code></pre> <p>Observed Behavior: When the job gets started an EBS volume is provisioned dynamically by the EBS CSI driver and mounted to the driver and executor pods. You can exec into the driver / executor container to verify that the EBS volume is mounted. Also, you can verify the mount from driver / executor pod spec.  </p> <pre><code>kubectl get pod &lt;driver pod name&gt; -n &lt;namespace&gt; -o yaml --export\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/","title":"EMR Containers integration with FSx for Lustre","text":"<p>Amazon EKS clusters provide the compute and ephemeral storage for Spark workloads. Ephemeral storage provided by EKS is allocated from the EKS worker node's disk storage and the lifecycle of the storage is bound by the lifecycle of the driver and executor pod.</p> <p>Need for durable storage: When multiple spark applications are executed as part of a data pipeline, there are scenarios where data from one spark application is passed to subsequent spark applications - in this case data can be persisted in S3. Alternatively, this data can also be persisted in FSx for Lustre. FSx for Lustre provides a fully managed, scalable, POSIX compliant native filesystem interface for the data in s3. With FSx, your torage is decoupled from your compute and has its own lifecycle. </p> <p>FSx for Lustre Volumes can be mounted on spark driver and executor pods through static and dynamic provisioning.</p> <p>Data used in the below example is from AWS Open data Registry</p>"},{"location":"storage/docs/spark/fsx-lustre/#fsx-for-lustre-posix-permissions","title":"FSx for Lustre POSIX permissions","text":"<p>When a Lustre filesystem is mounted to driver and executor pods, and if the S3 objects does not have required metadata, the mounted volume defaults  ownership of the file system to <code>root</code>. EMR on EKS executes the driver and executor pods with UID(999), GID (1000) and groups(1000 and 65534). In this scenario, the spark application has read only access to the mounted Lustre file system. Below are a few approaches that can be considered:</p>"},{"location":"storage/docs/spark/fsx-lustre/#tag-metadata-to-s3-object","title":"Tag Metadata to S3 object","text":"<p>Applications writing to S3 can tag the S3 objects with the metadata that FSx for Lustre requires.  </p> <p>Walkthrough: Attaching POSIX permissions when uploading objects into an S3 bucket provides a guided tutorial. FSx for Lustre will convert this tagged metadata to corresponding POSIX permissions when mounting Lustre file system to the driver and executor pods.       </p> <p>EMR on EKS spawns the driver and executor pods as non-root user(<code>UID -999, GID - 1000, groups - 1000, 65534</code>). To enable the spark application to write to the mounted file system, (UID - <code>999</code>) can be made as the <code>file-owner</code> and supplemental group <code>65534</code> be made as the <code>file-group</code>.</p> <p>For S3 objects that already exists with no metadata tagging, there can be a process that recursively tags all the S3 objects with the required metadata. Below is an example:   1. Create FSx for Lustre file system to the S3 prefix.   2. Create Persistent Volume and Persistent Volume claim for the created FSx for Lustre file system  3. Run a pod as root user with FSx for Lustre mounted with the PVC created in Step 2.    </p> <pre><code>```\napiVersion: v1\nkind: Pod\nmetadata:\n  name: chmod-fsx-pod\n  namespace: test-demo\nspec:\n  containers:\n  - name: ownership-change\n    image: amazonlinux:2\n    command: [\"sh\", \"-c\", \"chown -hR +999:+65534 /data\"]\n    volumeMounts:\n    - name: persistent-storage\n      mountPath: /data\n  volumes:\n  - name: persistent-storage\n    persistentVolumeClaim:\n      claimName: fsx-static-root-claim\n```\n</code></pre> <p>Run a data repository task with import path and export path pointing to the same S3 prefix. This will export the POSIX permission from FSx for Lustre file system as metadata, that is tagged on S3 objects.</p> <p>Now that the S3 objects are tagged with metadata, the spark application with FSx for Lustre filesystem mounted will have write access.</p>"},{"location":"storage/docs/spark/fsx-lustre/#static-provisioning","title":"Static Provisioning","text":""},{"location":"storage/docs/spark/fsx-lustre/#provision-a-fsx-for-lustre-cluster","title":"Provision a FSx for Lustre cluster","text":"<p>FSx for Luster can also be provisioned through aws cli</p> <p>How to decide what type of FSx for Lustre file system you need ? Create a Security Group to attach to FSx for Lustre file system as below Points to Note: Security group attached to the EKS worker nodes is given access on port number 988, 1021-1023 in inbound rules. Security group specified when creating the FSx for Lustre filesystem is given access on port number 988, 1021-1023 in inbound rules.</p> <p>Fsx for Lustre Provisioning through aws cli </p> <pre><code>cat fsxLustreConfig.json &lt;&lt; EOF \n{\n    \"ClientRequestToken\": \"EMRContainers-fsxLustre-demo\", \n    \"FileSystemType\": \"LUSTRE\",\n    \"StorageCapacity\": 1200, \n    \"StorageType\": \"SSD\", \n    \"SubnetIds\": [\n        \"&lt;subnet-id&gt;\"\n    ], \n    \"SecurityGroupIds\": [\n        \"&lt;securitygroup-id&gt;\"\n    ], \n    \"LustreConfiguration\": {\n        \"ImportPath\": \"s3://&lt;s3 prefix&gt;/\", \n        \"ExportPath\": \"s3://&lt;s3 prefix&gt;/\", \n        \"DeploymentType\": \"PERSISTENT_1\", \n        \"AutoImportPolicy\": \"NEW_CHANGED\",\n        \"PerUnitStorageThroughput\": 200\n    }\n}\nEOF\n</code></pre> <p>Run the aws-cli command to create the FSx for Lustre filesystem as below.</p> <pre><code>aws fsx create-file-system --cli-input-json file:///fsxLustreConfig.json\n</code></pre> <p>Response is as below</p> <pre><code>{\n\"FileSystem\": {\n\"VpcId\": \"&lt;vpc id&gt;\", \"Tags\": [], \"StorageType\": \"SSD\", \"SubnetIds\": [\n\"&lt;subnet-id&gt;\"\n], \"FileSystemType\": \"LUSTRE\", \"CreationTime\": 1603752401.183, \"ResourceARN\": \"&lt;fsx resource arn&gt;\", \"StorageCapacity\": 1200, \"LustreConfiguration\": {\n\"CopyTagsToBackups\": false, \"WeeklyMaintenanceStartTime\": \"7:11:30\", \"DataRepositoryConfiguration\": {\n\"ImportPath\": \"s3://&lt;s3 prefix&gt;\", \"AutoImportPolicy\": \"NEW_CHANGED\", \"ImportedFileChunkSize\": 1024, \"Lifecycle\": \"CREATING\", \"ExportPath\": \"s3://&lt;s3 prefix&gt;/\"\n}, \"DeploymentType\": \"PERSISTENT_1\", \"PerUnitStorageThroughput\": 200, \"MountName\": \"mvmxtbmv\"\n}, \"FileSystemId\": \"&lt;filesystem id&gt;\", \"DNSName\": \"&lt;filesystem id&gt;.fsx.&lt;region&gt;.amazonaws.com\", \"KmsKeyId\": \"arn:aws:kms:&lt;region&gt;:&lt;account&gt;:key/&lt;key id&gt;\", \"OwnerId\": \"&lt;account&gt;\", \"Lifecycle\": \"CREATING\"\n}\n}\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks","title":"EKS admin tasks","text":"<ol> <li>Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre</li> <li>Install the FSx CSI Driver in EKS </li> <li>Configure Storage Class for FSx for Lustre</li> <li>Configure Persistent Volume and Persistent Volume Claim for FSx for Lustre</li> </ol> <p>FSx for Lustre file system is created as described above -Provision a FSx for Lustre cluster Once provisioned, a persistent volume - as specified below is created with a direct (hard-coded) reference to the created lustre file system. A Persistent Volume claim for this persistent volume will always use the same file system.</p> <pre><code>cat &gt;fsxLustre-static-pv.yaml &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: fsx-pv\nspec:\ncapacity:\nstorage: 1200Gi\nvolumeMode: Filesystem\naccessModes:\n- ReadWriteMany\nmountOptions:\n- flock\npersistentVolumeReclaimPolicy: Recycle\ncsi:\ndriver: fsx.csi.aws.com\nvolumeHandle: &lt;filesystem id&gt;\nvolumeAttributes:\ndnsname: &lt;filesystem id&gt;.fsx.&lt;region&gt;.amazonaws.com\nmountname: mvmxtbmv\nEOF\n</code></pre> <pre><code>kubectl apply -f fsxLustre-static-pv.yaml\n</code></pre> <p>Now, a Persistent Volume Claim (PVC) needs to be created that references PV created above.</p> <pre><code>cat &gt;fsxLustre-static-pvc.yaml &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: fsx-claim\n  namespace: ns1\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: \"\"\n  resources:\n    requests:\n      storage: 1200Gi\n  volumeName: fsx-pv\nEOF\n</code></pre> <pre><code>kubectl apply -f fsxLustre-static-pvc.yaml -n &lt;namespace registered with EMR on EKS Virtual Cluster&gt;\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks","title":"Spark Developer Tasks","text":"<p>Now spark applications can use <code>fsx-claim</code> in their spark application config to mount the FSx for Lustre filesystem to driver and executor container volumes. </p> <pre><code>cat &gt;spark-python-in-s3-fsx.json &lt;&lt;EOF\n{\n\"name\": \"spark-python-in-s3-fsx\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-repartition-fsx.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\nEOF\n</code></pre> <pre><code>aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx.json\n</code></pre> <p>Expected Behavior: All spark jobs that are run with persistent volume claims as <code>fsx-claim</code> will mount to the statically created FSx for Lustre file system. </p> <p>Use case:</p> <ol> <li>A data pipeline consisting of 10 spark applications can all be mounted to the statically created FSx for Lustre file system and can write the intermediate output to a particular folder. The next spark job in the data pipeline that is dependent on this data can read from FSx for Lustre. Data that needs to be persisted beyond the scope of the data pipeline can be exported to S3 by creating data repository tasks</li> <li>Data that is used often by multiple spark applications can also be stored in FSx for Lustre for improved performance.</li> </ol>"},{"location":"storage/docs/spark/fsx-lustre/#dynamic-provisioning","title":"Dynamic Provisioning","text":"<p>A FSx for Lustre file system can be provisioned on-demand. A Storage-class resource is created and that provisions FSx for Lustre file system dynamically. A PVC is created and refers to the storage class resource that was created. Whenever a pod refers to the PVC, the storage class invokes the FSx for Lustre Container Storage Interface (CSI) to provision a Lustre file system on the fly dynamically. In this model,  FSx for Lustre of type <code>Scratch File Systems</code> is  provisioned.  </p>"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks_1","title":"EKS Admin Tasks","text":"<ol> <li>Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre</li> <li>Install the FSx CSI Driver in EKS</li> <li>Configure Storage Class for FSx for Lustre</li> <li>Configure Persistent Volume Claim(<code>fsx-dynamic-claim</code>) for FSx for Lustre.</li> </ol> <p>Create PVC for dynamic provisioning with <code>fsx-sc</code> storage class.  </p> <pre><code>cat &gt;fsx-dynamic-claim.yaml &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: fsx-dynamic-claim\nspec:\n  accessModes:\n    - ReadWriteMany\n  storageClassName: fsx-sc\n  resources:\n    requests:\n      storage: 3600Gi\nEOF \n</code></pre> <pre><code>kubectl apply -f fsx-dynamic-pvc.yaml -n &lt;namespace registered with EMR on EKS Virtual Cluster&gt;\n</code></pre>"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks_1","title":"Spark Developer Tasks","text":"<pre><code>cat &gt;spark-python-in-s3-fsx-dynamic.json &lt;&lt; EOF\n{\n\"name\": \"spark-python-in-s3-fsx-dynamic\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/trip-count-repartition-fsx.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5  --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.local.dir\":\"/var/spark/spill/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName\":\"fsx-dynamic-claim\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path\":\"/var/spark/spill/\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly\":\"false\"\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\nEOF\n</code></pre> <pre><code>aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx-dynamic.json\n</code></pre> <p>Expected Result: Statically provisioned FSx for Lustre is mounted to <code>/var/data/</code> as before for the driver pod. For all the executors a <code>SCRATCH 1</code> deployment type FSx for Lustre is provisioned on the fly dynamically by the Storage class that was created. There will be a latency before the first executor can start running - because the Lustre has to be created. Once it is created the same Lustre file system is mounted to all the executors. Also note - <code>\"spark.local.dir\":\"/var/spark/spill/\"</code> is used to force executor to use this folder mounted to Lustre for all spill and shuffle data. Once the spark job is completed, the Lustre file system is deleted or retained based on the PVC configuration. This dynamically created Lustre file system is mapped to a S3 path like the statically created filesystem. FSx-csi user guide</p>"},{"location":"storage/docs/spark/instance-store/","title":"Instance Store Volumes","text":"<p>When working with Spark workloads, it might be useful to use instances powered by SSD instance store volumes to improve the performance of your jobs. This storage is located on disks that are physically attached to the host computer and can provide better performance compared to traditional EBS volumes. In the context of Spark, this might be beneficial for wide transformations (e.g. JOIN, GROUP BY) that generate a significant amount of shuffle data that Spark persists on the local filesystem of the instances where the executors are running.</p> <p>In this document, we highlight two approaches to leverage NVMe disks in your workloads when using EMR on EKS. For a list of instances supporting NVMe disks, see Instance store volumes in the Amazon EC2 documentation.</p>"},{"location":"storage/docs/spark/instance-store/#mount-kubelet-pod-directory-on-nvme-disks","title":"Mount kubelet pod directory on NVMe disks","text":"<p>The kublet service manages the lifecycle of pod containers that are created using Kubernetes. When a pod is launched on an instance, an ephemeral volume is automatically created for the pod, and this volume is mapped in a subdirectory within the path <code>/var/lib/kubelet</code> of the host node. This volume folder exists for the lifetime of K8s pod, and it will be automatically deleted once the pod ceases to exist.</p> <p>In order to leverage NVMe disk attached to an EC2 node in our Spark application, we should perform the following actions during node bootstrap:</p> <ul> <li>Prepare the NVMe disks attached to the instance (format disks and create a partition)</li> <li>Mount the <code>/var/lib/kubelet/pods</code> path on the NVMe</li> </ul> <p>By doing this, all local files generated by your Spark job (blockmanager data, shuffle data, etc.) will be automatically written to NVMe disks. This way, you don't have to configure Spark volume path when launching the pod (driver or executor). This approach is easier to adopt because it doesn\u2019t require any additional configuration in your job. Besides, once the job is completed, all the data stored in ephemeral volumes will be automatically deleted when the EC2 instance is deleted.</p> <p>However, if you have multiple NVMe disks attached to the instance, you need to create RAID0 configuration of all the disks before mounting the <code>/var/lib/kubelet/pods</code> directory on the RAID partition. Without a RAID setup, it will not be possible to leverage all the disks capacity available on the node.</p> <p>The following example shows how to create a node group in your cluster using this approach. In order to prepare our NVMe disks, we can use the eksctl preBootstrapCommands definition while creating the node group. The script will perform the following actions:</p> <ul> <li>For instances with a single NVMe disk, format the filesystem, create a Linux partition (e.g. ext4, xfs, etc.)</li> <li>For instances with multiple NVMe disks, create a RAID 0 configuration across all available volumes</li> </ul> <p>Once the disks are formatted and ready to use, we will mount the folder /var/lib/kubelet/pods using the filesystem and setup correct permissions. Below, you can find an example of an eksctl configuration to create a managed node group using this approach.</p> <p>Example</p> <pre><code>apiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\n\nmetadata:\nname: YOUR_CLUSTER_NAME\nregion: YOUR_REGION\n\nmanagedNodeGroups:\n- name: ng-c5d-9xlarge\ninstanceType: c5d.9xlarge\ndesiredCapacity: 1\nprivateNetworking: true\nsubnets:\n- YOUR_NG_SUBNET\npreBootstrapCommands: # commands executed as root\n- yum install -y mdadm nvme-cli\n- nvme_disks=($(nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk -F'[[:space:]][[:space:]]+' '{print $1}')) &amp;&amp; [[ ${#nvme_disks[@]} -eq 1 ]] &amp;&amp; mkfs.ext4 -F ${nvme_disks[*]} &amp;&amp; systemctl stop docker &amp;&amp; mkdir -p /var/lib/kubelet/pods &amp;&amp; mount ${nvme_disks[*]} /var/lib/kubelet/pods &amp;&amp; chmod 750 /var/lib/docker &amp;&amp; systemctl start docker\n- nvme_disks=($(nvme list | grep \"Amazon EC2 NVMe Instance Storage\" | awk -F'[[:space:]][[:space:]]+' '{print $1}')) &amp;&amp; [[ ${#nvme_disks[@]} -ge 2 ]] &amp;&amp; mdadm --create --verbose /dev/md0 --level=0 --raid-devices=${#nvme_disks[@]} ${nvme_disks[*]} &amp;&amp; mkfs.ext4 -F /dev/md0 &amp;&amp; systemctl stop docker &amp;&amp; mkdir -p /var/lib/kubelet/pods &amp;&amp; mount /dev/md0 /var/lib/kubelet/pods &amp;&amp; chmod 750 /var/lib/docker &amp;&amp; systemctl start docker\n</code></pre> <p>Benefits</p> <ul> <li>No need to mount the disk using Spark configurations or pod templates</li> <li>Data generated by the application, will immediately be deleted at the pod termination. Data will be also purged in case of pod failures.</li> <li>One time configuration for the node group</li> </ul> <p>Cons</p> <ul> <li>If multiple jobs are allocated on the same EC2 instance, contention of disk resources will occur because it is not possible to allocate instance store volume resources across jobs</li> </ul>"},{"location":"storage/docs/spark/instance-store/#mount-nvme-disks-as-data-volumes","title":"Mount NVMe disks as data volumes","text":"<p>In this section, we\u2019re going to explicitly mount instance store volumes as the mount path in Spark configuration for drivers and executors</p> <p>As in the previous example, this script will automatically format the instance store volumes and create an xfs partition. The disks are then mounted in local folders called /spark_data_IDX where IDX is an integer that corresponds to the disk mounted.</p> <p>Example</p> <pre><code>apiVersion: eksctl.io/v1alpha5\nkind: ClusterConfig\n\nmetadata:\nname: YOUR_CLUSTER_NAME\nregion: YOUR_REGION\n\nmanagedNodeGroups:\n- name: ng-m5d-4xlarge\ninstanceType: m5d.4xlarge\ndesiredCapacity: 1\nprivateNetworking: true\nsubnets:\n- YOUR_NG_SUBNET\npreBootstrapCommands: # commands executed as root\n- \"IDX=1;for DEV in /dev/nvme[1-9]n1;do mkfs.xfs ${DEV}; mkdir -p /spark_data_${IDX}; echo ${DEV} /spark_data_${IDX} xfs defaults,noatime 1 2 &gt;&gt; /etc/fstab; IDX=$((${IDX} + 1)); done\"\n- \"mount -a\"\n- \"chown 999:1000 /spark_data_*\"\n</code></pre> <p>In order to successfully use ephemeral volumes within Spark, you need to specify additional configurations. In addition to spark configuration, the mounted volume name should start with <code>spark-local-dir-</code>.</p> <p>Below an example configuration provided during the EMR on EKS job submission, that shows how to configure Spark to use 2 volumes as local storage for the job.</p> <p>Spark Configurations</p> <pre><code>{\n  \"name\": ....,\n  \"virtualClusterId\": ....,\n  \"executionRoleArn\": ....,\n  \"releaseLabel\": ....,\n  \"jobDriver\": ....,\n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\",\n        \"properties\": {\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.path\": \"/spark_data_1\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.mount.readOnly\": \"false\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-1.options.path\": \"/spark_data_1\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.path\": \"/spark_data_2\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.mount.readOnly\": \"false\",\n          \"spark.kubernetes.executor.volumes.hostPath.spark-local-dir-2.options.path\": \"/spark_data_2\"\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>Please note that for this approach it is required to specify the following configurations for each volume that you want to use. (IDX is a label to identify the volume mounted)</p> <pre><code># Mount path on the host node\nspark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.options.path\n\n# Mount path on the k8s pod\nspark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.path\n\n# (boolean) Should be defined as false to allow Spark to write in the path\nspark.kubernetes.executor.volumes.hostPath.spark-local-dir-IDX.mount.readOnly\n</code></pre> <p>Benefits</p> <ul> <li>You can allocate dedicated resources of instance store volumes across your Spark jobs (For example, lets take a scenario where an EC2 instance has two instance store volumes. If you run two spark jobs on this node, you can dedicate one volume per Spark job)</li> </ul> <p>Cons</p> <ul> <li>Additional configurations are required for Spark jobs to use instance store volumes. This approach can be error-prone if you don\u2019t control the instance types being used (for example, multiple node groups with different instance types). You can mitigate this issue by using k8s node selectors and specify instance type in your spark configuraiton: spark.kubernetes.node.selector.node.kubernetes.io/instance-type</li> <li>Data created on the volumes is automatically deleted once the job is completed and instance is terminated. However, you need to extra measures to delete the data on instance store volumes if EC2 instance is re-used or is not terminated.</li> </ul>"},{"location":"submit-applications/docs/spark/pyspark/","title":"Pyspark Job submission","text":"<p>Python interpreter is bundled in the EMR containers spark image that is used to run the spark job.Python code and dependencies can be provided with the below options.</p>"},{"location":"submit-applications/docs/spark/pyspark/#python-code-self-contained-in-a-single-py-file","title":"Python code self contained in a single .py file","text":"<p>To start with, in the simplest scenario - the example below shows how to submit a pi.py file that is self-contained and doesn't need any other dependencies.    </p>"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-s3","title":"Python file from S3","text":"<p>Request  pi.py used in the below request payload is from spark examples</p> <pre><code>cat &gt; spark-python-in-s3.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-image\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/pi.py\", \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-mounted-volume","title":"Python file from mounted volume","text":"<p>In the below example - pi.py is placed in a mounted volume. FSx for Lustre filesystem is mounted as a Persistent Volume on the driver pod under <code>/var/data/</code> and will be referenced by <code>local://</code> file prefix. For more information on how to mount FSx for lustre - EMR-Containers-integration-with-FSx-for-Lustre</p> <p>This approach can be used to provide spark application code and dependencies for execution. Persistent Volume mounted  to the driver and executor pods lets you access the application code and dependencies with <code>local://</code> prefix. </p> <pre><code>cat &gt; spark-python-in-FSx.json &lt;&lt;EOF\n{\n\"name\": \"spark-python-in-FSx\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"local:///var/data/FSxLustre-pi.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.dynamicAllocation.enabled\":\"false\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-Fsx.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#python-code-with-python-dependencies","title":"Python code with python dependencies","text":"<p>Info</p> <p>boto3 will only work with 'Bundled as a .pex file'  or with 'Custom docker image'</p>"},{"location":"submit-applications/docs/spark/pyspark/#list-of-py-files","title":"List of .py files","text":"<p>This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all the transitive dependencies.  </p> <pre><code>cat &gt; py-files-pi.py &lt;&lt;EOF\nfrom __future__ import print_function\n\nimport sys\nfrom random import random\nfrom operator import add\n\nfrom pyspark.sql import SparkSession\nfrom pyspark import SparkContext\n\nimport dependentFunc\n\nif __name__ == \"__main__\":\n\"\"\"\n        Usage: pi [partitions]\n    \"\"\"\n    spark = SparkSession.builder.getOrCreate()\n    sc = spark.sparkContext\n    partitions = int(sys.argv[1]) if len(sys.argv) &gt; 1 else 2\n    n = 100000 * partitions\n\n    def f(_):\n        x = random() * 2 - 1\n        y = random() * 2 - 1\n        return 1 if x ** 2 + y ** 2 &lt;= 1 else 0\n\n    count = spark.sparkContext.parallelize(range(1, n + 1), partitions).map(f).reduce(add)\n    dependentFunc.message()\n    print(\"Pi is roughly %f\" % (4.0 * count / n))\n\n    spark.stop()\n\n  EOF\n</code></pre> <pre><code>cat &gt; dependentFunc.py &lt;&lt;EOF\ndef message():\n  print(\"Printing from inside the dependent python file\")\n\nEOF\n</code></pre> <p>Upload dependentFunc.py and py-files-pi.py to s3  </p> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-files &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-files\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/dependentFunc.py --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-files.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-zip-file","title":"Bundled as a zip file","text":"<p>In this approach all the dependent python files are bundled as a zip file. Each folder should have <code>__init__.py</code> file as documented in  zip python dependencies. Zip should be done at the top folder level and using the -r option.</p> <pre><code>zip -r pyspark-packaged-dependency-src.zip . \n  adding: dependent/ (stored 0%)\n  adding: dependent/__init__.py (stored 0%)\n  adding: dependent/dependentFunc.py (deflated 7%)\n</code></pre> <p>dependentFunc.py from earlier example has been bundled as  pyspark-packaged-dependency-src.zip. Upload this file to a S3 location</p> <pre><code>cat &gt; py-files-zip-pi.py &lt;&lt;EOF\nfrom __future__ import print_function\n\nimport sys\nfrom random import random\nfrom operator import add\n\nfrom pyspark.sql import SparkSession\nfrom pyspark import SparkContext\n\n**from dependent import dependentFunc**\n\nif __name__ == \"__main__\":\n\"\"\"\n        Usage: pi [partitions]\n    \"\"\"\n    spark = SparkSession.builder.getOrCreate()\n    sc = spark.sparkContext\n    partitions = int(sys.argv[1]) if len(sys.argv) &gt; 1 else 2\n    n = 100000 * partitions\n\n    def f(_):\n        x = random() * 2 - 1\n        y = random() * 2 - 1\n        return 1 if x ** 2 + y ** 2 &lt;= 1 else 0\n\n    count = spark.sparkContext.parallelize(range(1, n + 1), partitions).map(f).reduce(add)\n    dependentFunc.message()\n    print(\"Pi is roughly %f\" % (4.0 * count / n))\n\n    spark.stop()\n  EOF\n</code></pre> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-zip.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-zip\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-zip-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/pyspark-packaged-dependency-src.zip --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n          }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-zip.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-egg-file","title":"Bundled as a .egg file","text":"<p>Create a folder structure as in the below screenshot with the code from the previous example - <code>py-files-zip-pi.py, dependentFunc.py</code> </p> <p>Steps to create .egg file</p> <pre><code>cd /pyspark-packaged-example\npip install setuptools\npython setup.py bdist_egg\n</code></pre> <p>Upload <code>dist/pyspark_packaged_example-0.0.3-py3.8.egg</code> to a S3 location  </p> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-egg.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-egg\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-zip-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/pyspark_packaged_example-0.0.3-py3.8.egg --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-egg.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-whl-file","title":"Bundled as a .whl file","text":"<p>Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py  </p> <p>Steps to create .whl file</p> <pre><code>cd /pyspark-packaged-example\n`pip install wheel`\npython setup.py bdist_wheel\n</code></pre> <p>Upload <code>dist/pyspark_packaged_example-0.0.3-py3-none-any.whl</code> to a s3 location</p> <p>Request:</p> <pre><code>cat &gt; spark-python-in-s3-dependency-wheel.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-dependency-wheel\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py-files-zip-pi.py\", \n       \"sparkSubmitParameters\": \"--py-files s3://&lt;s3 prefix&gt;/pyspark_packaged_example-0.0.3-py3-none-any.whl --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-wheel.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-pex-file","title":"Bundled as a .pex file","text":"<p>pex is a library for generating .pex (Python EXecutable) files which are executable Python environments.PEX files can be created as below</p> <pre><code>docker run -it -v $(pwd):/workdir python:3.7.9-buster /bin/bash #python 3.7.9 is installed in EMR 6.1.0\npip3 install pex\npex --python=python3 --inherit-path=prefer -v numpy -o numpy_dep.pex\n</code></pre> <p>To read more about PEX: PEX PEX documentation Tips on PEX pex packaging for pyspark </p> <p>Approach 1: Using Persistent Volume - FSx for Lustre cluster</p> <p>Upload <code>numpy_dep.pex</code> to a s3 location that is mapped to a FSx for Lustre cluster. <code>numpy_dep.pex</code> can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod. Request: <code>kmeans.py</code> used in the below request is from spark examples</p> <pre><code>cat &gt; spark-python-in-s3-pex-fsx.json &lt;&lt; EOF\n{\n\"name\": \"spark-python-in-s3-pex-fsx\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/kmeans.py\",\n\"entryPointArguments\": [\n\"s3://&lt;s3 prefix&gt;/kmeans_data.txt\",\n\"2\",\n\"3\"\n], \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.kubernetes.pyspark.pythonVersion\":\"3\",\n\"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\",\n\"spark.executorEnv.PEX_ROOT\":\"./tmp\",\n\"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\",\n\"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\",\n\"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\",\n\"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\",\n\"spark.executorEnv.PEX_PYTHON\":\"python3\",\n\"spark.pyspark.driver.python\":\"/var/data/numpy_dep.pex\",\n\"spark.pyspark.python\":\"/var/data/numpy_dep.pex\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n}\n}\n], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\n\naws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-fsx.json\n</code></pre> <p>Approach 2: Using Custom Pod Templates</p> <p>Upload <code>numpy_dep.pex</code> to a s3 location. Create custom pod templates for driver and executor pods. Custom pod templates allows running a command through initContainers before the main application container is created. In this case, the command will download the <code>numpy_dep.pex</code> file to the <code>/tmp/numpy_dep.pex</code> path of the driver and executor pods.</p> <p>Note: This approach is only supported for release image 5.33.0 and later or 6.3.0 and later.</p> <p>Sample driver pod template YAML file:</p> <pre><code>cat &gt; driver_pod_tenplate.yaml &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nspec:\n containers:\n   - name: spark-kubernetes-driver\n initContainers: \n   - name: my-init-container\n     image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla\n     volumeMounts:\n       - name: temp-data-dir\n         mountPath: /tmp\n     command:\n       - sh\n       - -c\n       - aws s3api get-object --bucket &lt;s3-bucket&gt; --key &lt;s3-key-prefix&gt;/numpy_dep.pex /tmp/numpy_dep.pex &amp;&amp; chmod u+x /tmp/numpy_dep.pex\nEOF\n</code></pre> <p>Sample executor pod template YAML file:</p> <pre><code>cat &gt; executor_pod_tenplate.yaml &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: spark-kubernetes-executor\n  initContainers: \n    - name: my-init-container\n      image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla\n      volumeMounts:\n        - name: temp-data-dir\n          mountPath: /tmp\n      command:\n        - sh\n        - -c\n        - aws s3api get-object --bucket &lt;s3-bucket&gt; --key &lt;s3-key-prefix&gt;/numpy_dep.pex /tmp/numpy_dep.pex &amp;&amp; chmod u+x /tmp/numpy_dep.pex\nEOF\n</code></pre> <p>Replace initContainer's <code>image</code> with the respective release label's container image. In this case we are using the image of release <code>emr-5.33.0-latest</code>. Upload the driver and executor custom pod templates to S3</p> <p>Request: <code>kmeans.py</code> used in the below request is from spark examples</p> <pre><code>cat &gt; spark-python-in-s3-pex-pod-templates.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-in-s3-pex-pod-templates\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-5.33.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/kmeans.py\",\n      \"entryPointArguments\": [\n        \"s3://&lt;s3 prefix&gt;/kmeans_data.txt\",\n        \"2\",\n        \"3\"\n       ], \n       \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.kubernetes.pyspark.pythonVersion\":\"3\",\n          \"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\",\n          \"spark.executorEnv.PEX_ROOT\":\"./tmp\",\n          \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\",\n          \"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\",\n          \"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\",\n          \"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\",\n          \"spark.executorEnv.PEX_PYTHON\":\"python3\",\n          \"spark.pyspark.driver.python\":\"/tmp/numpy_dep.pex\",\n          \"spark.pyspark.python\":\"/tmp/numpy_dep.pex\",\n          \"spark.kubernetes.driver.podTemplateFile\": \"s3://&lt;s3-prefix&gt;/driver_pod_template.yaml\",\n          \"spark.kubernetes.executor.podTemplateFile\": \"s3://&lt;s3-prefix&gt;/executor_pod_template.yaml\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": { \n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\n\naws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-pod-templates.json\n</code></pre> <p>Point to Note: PEX files don\u2019t have the python interpreter bundled with it. Using the PEX env variables, we pass in the python interpreter installed in the spark driver and executor docker image.</p> <p>pex vs conda-pack A pex file contain only dependent Python packages but not a Python interpreter in it while a conda-pack environment has a Python interpreter as well, so with the same Python packages a conda-pack environment is much larger than a pex file. A conda-pack environment is a tar.gz file and need to be decompressed before being used while a pex file can be used directly. If a Python interpreter exists, pex is a better option than conda-pack. However, conda-pack is the ONLY CHOICE if you need a specific version of Python interpreter which does not exist and you do not have permission to install one (e.g., when you need to use a specific version of Python interpreter with an enterprise PySpark cluster). If the pex file or conda-pack environment needs to be distributed to machines on demand, there are some overhead before running your application. With the same Python packages, a conda-pack environment has large overhead/latency than the pex file as the conda-pack environment is usually much larger and need to be decompressed before being used.</p> <p>For more information - Tips on PEX </p>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-targz-file-with-conda-pack","title":"Bundled as a tar.gz file with conda-pack","text":"<p>conda-pack for spark Install conda through Miniconda Open a new terminal and execute the below commands</p> <pre><code>conda create -y -n example python=3.5 numpy\nconda activate example\npip install conda-pack\nconda pack -f -o numpy_environment.tar.gz\n</code></pre> <p>Upload <code>numpy_environment.tar.gz</code> to a s3 location that is mapped to a FSx for Lustre cluster. <code>numpy_environment.tar.gz</code> can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod.Alternatively, S3 path for <code>numpy_environment.tar.gz</code> can also be passed using --py-files </p> <p>Request:</p> <pre><code>{\n\"name\": \"spark-python-in-s3-conda-fsx\", \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": {\n\"sparkSubmitJobDriver\": {\n\"entryPoint\": \"s3://&lt;s3 prefix&gt;/kmeans.py\",\n\"entryPointArguments\": [\n\"s3://&lt;s3 prefix&gt;/kmeans_data.txt\",\n\"2\",\n\"3\"\n], \"sparkSubmitParameters\": \"--verbose --archives /var/data/numpy_environment.tar.gz#environment --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\"\n}\n}, \"configurationOverrides\": {\n\"applicationConfiguration\": [\n{\n\"classification\": \"spark-defaults\", \"properties\": {\n\"spark.executor.instances\": \"3\",\n\"spark.dynamicAllocation.enabled\":\"false\",\n\"spark.files\":\"/var/data/numpy_environment.tar.gz#environment\",\n\"spark.kubernetes.pyspark.pythonVersion\":\"3\",\n\"spark.pyspark.driver.python\":\"./environment/bin/python\",\n\"spark.pyspark.python\":\"./environment/bin/python\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\":\"fsx-claim\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\":\"/var/data/\",\n\"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\":\"false\"\n}\n}\n], \"monitoringConfiguration\": {\n\"cloudWatchMonitoringConfiguration\": {\n\"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\"\n}, \"s3MonitoringConfiguration\": {\n\"logUri\": \"s3://joblogs\"\n}\n}\n}\n}\n</code></pre> <p>The above request doesn't work with spark on kubernetes</p>"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-virtual-env","title":"Bundled as virtual env","text":"<p>Warning</p> <p>This will not work with spark on kubernetes</p> <p>This feature only works with YARN - cluster mode In this implementation for YARN - the dependencies will be installed from the repository for every driver and executor. This might not be a more scalable model as per SPARK-25433. Recommended solution is to pass in the dependencies as PEX file.</p>"},{"location":"submit-applications/docs/spark/pyspark/#custom-docker-image","title":"Custom docker image","text":"<p>See the details in the official documentation.  </p> <p>Dockerfile</p> <pre><code>FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0\nUSER root\nRUN pip3 install boto3\nUSER hadoop:hadoop\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#python-code-with-java-dependencies","title":"Python code with java dependencies","text":""},{"location":"submit-applications/docs/spark/pyspark/#list-of-packages","title":"List of packages","text":"<p>Warning</p> <p>This will not work with spark on kubernetes</p> <p>This feature only works with YARN - cluster mode</p> <p>kafka integration example</p> <pre><code>./bin/spark-submit --packages org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#list-of-jar-files","title":"List of .jar files","text":"<p>This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all the transitive dependencies.</p> <p>How to find all the .jar files which belongs to given package?</p> <ol> <li>Go to Maven Repository</li> <li>Search for the package name</li> <li>Select the matching Spark and Scala version</li> <li>Copy the URL of the jar file</li> <li>Copy the URL of the jar file of all compile dependencies</li> </ol> <p>Request:</p> <pre><code>cat &gt; Spark-Python-with-jars.json &lt;&lt; EOF\n{\n  \"name\": \"spark-python-with-jars\",\n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\",\n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\",\n  \"releaseLabel\": \"emr-6.2.0-latest\",\n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/pi.py\",\n      \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar,https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar,https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar --conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\"\n    }\n  },\n  \"configurationOverrides\": {\n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\",\n        \"logStreamNamePrefix\": \"demo\"\n      },\n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///Spark-Python-with-jars.json\n</code></pre>"},{"location":"submit-applications/docs/spark/pyspark/#custom-docker-image_1","title":"Custom docker image","text":"<p>See the basics in the official documentation.  </p> <p>Approach 1: List of .jar files </p> <p>This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all the transitive dependencies.</p> <p>How to find all the .jar files which belongs to given package?</p> <ol> <li>Go to Maven Repository</li> <li>Search for the package name</li> <li>Select the matching Spark and Scala version</li> <li>Copy the URL of the jar file</li> <li>Copy the URL of the jar file of all compile dependencies</li> </ol> <p>Dockerfile</p> <pre><code>FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0\n\nUSER root\n\nARG JAR_HOME=/usr/lib/spark/jars/\n\n# Kafka\nADD https://repo1.maven.org/maven2/org/apache/spark/spark-sql-kafka-0-10_2.12/3.1.1/spark-sql-kafka-0-10_2.12-3.1.1.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/commons/commons-pool2/2.6.2/commons-pool2-2.6.2.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/kafka/kafka-clients/2.6.0/kafka-clients-2.6.0.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/spark/spark-token-provider-kafka-0-10_2.12/3.1.1/spark-token-provider-kafka-0-10_2.12-3.1.1.jar $JAR_HOME\nADD https://repo1.maven.org/maven2/org/apache/spark/spark-tags_2.12/3.1.1/spark-tags_2.12-3.1.1.jar $JAR_HOME\n\nRUN chmod -R +r  /usr/lib/spark/jars\n\nUSER hadoop:hadoop\n</code></pre> <p>Observed Behavior: Spark automatically installs all the .jar files from <code>/usr/lib/spark/jars/</code> directory. In Dockerfile we are adding these  file as root user and these file will get <code>-rw-------</code> permission while the original files have <code>-rw-r--r--</code> permission.  EMR on EKS uses hadoop:hadoop to run spark jobs and files with <code>-rw-------</code> permission are hidden from this user and can  not be imported. To make these file readable for all the users run the following command <code>chmod -R +r /usr/lib/spark/jars</code> and the files will have <code>-rw-r--r--</code> permission.</p> <p> Approach 2: List of packages </p> <p>This approach is a resource intensive (min 1vCPU, 2GB RAM) solution, because it will run a dummy spark job. Scale your local or CI/CD resources according to it. </p> <p>Dockerfile</p> <pre><code>FROM 107292555468.dkr.ecr.eu-central-1.amazonaws.com/spark/emr-6.3.0\n\nUSER root\n\nARG KAFKA_PKG=\"org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2\"\n\nRUN spark-submit run-example --packages $KAFKA_PKG --deploy-mode=client --master=local[1] SparkPi\nRUN mv /root/.ivy2/jars/* /usr/lib/spark/jars/\n\nUSER hadoop:hadoop\n</code></pre> <p>Observed Behavior:  Spark runs ivy to get all of its dependencies (packages) when <code>--packages</code> are defined in the submit command. We can run a \"dummy\" spark job to make spark downloads its packages. These .jars are saved in <code>/root/.ivy2/jars/</code> which  we can move to <code>/usr/lib/spark/jars/</code> for further use. These jars having <code>-rw-r--r--</code> permission and does not require further modifications. The advantage of this method is ivy download the dependencies of the package as well, and we needed to specify only  <code>org.apache.spark:spark-sql-kafka-0-10_2.12:3.1.2</code> instead of 5 jars files above.</p>"},{"location":"submit-applications/docs/spark/pyspark/#import-of-dynamic-modules-pyd-so","title":"Import of Dynamic Modules (.pyd, .so)","text":"<p>Import of dynamic modules(.pyd, .so) is disallowed when bundled as a zip </p> <p>Steps to create a .so file example.c</p> <pre><code>/* File : example.c */\n\n#include \"example.h\"\nunsigned int add(unsigned int a, unsigned int b)\n{\nprintf(\"\\n Inside add function in C library \\n\");\nreturn (a+b);\n}\n</code></pre> <p>example.h</p> <pre><code>/* File : example.h */\n#include&lt;stdio.h&gt;\nextern unsigned int add(unsigned int a, unsigned int b);\n</code></pre> <pre><code>gcc  -fPIC -Wall -g -c example.c\ngcc -shared -fPIC -o libexample.so example.o\n</code></pre> <p>Upload <code>libexample.so</code> to a S3 location.</p> <p>pyspark code to be executed - py_c_call.py</p> <pre><code>import sys\nimport os\n\nfrom ctypes import CDLL\nfrom pyspark.sql import SparkSession\n\n\nif __name__ == \"__main__\":\n\n    spark = SparkSession\\\n        .builder\\\n        .appName(\"py-c-so-example\")\\\n        .getOrCreate()\n\n    basedir = os.path.abspath(os.path.dirname(__file__))\n    libpath = os.path.join(basedir, 'libexample.so')\n    sum_list = CDLL(libpath)\n    data = [(1,2),(2,3),(5,6)]\n    columns=[\"a\",\"b\"]\n    df = spark.sparkContext.parallelize(data).toDF(columns)\n    df.withColumn('total', sum_list.add(df.a,df.b)).collect()\n    spark.stop()\n</code></pre> <p>Request: </p> <pre><code>cat &gt; spark-python-in-s3-Clib.json &lt;&lt;EOF\n{\n  \"name\": \"spark-python-in-s3-Clib\", \n  \"virtualClusterId\": \"&lt;virtual-cluster-id&gt;\", \n  \"executionRoleArn\": \"&lt;execution-role-arn&gt;\", \n  \"releaseLabel\": \"emr-6.2.0-latest\", \n  \"jobDriver\": {\n    \"sparkSubmitJobDriver\": {\n      \"entryPoint\": \"s3://&lt;s3 prefix&gt;/py_c_call.py\", \n       \"sparkSubmitParameters\": \"--files s3://&lt;s3 prefix&gt;/libexample.so --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\"\n    }\n  }, \n  \"configurationOverrides\": {\n    \"applicationConfiguration\": [\n      {\n        \"classification\": \"spark-defaults\", \n        \"properties\": {\n          \"spark.dynamicAllocation.enabled\":\"false\"\n         }\n      }\n    ], \n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      }, \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://joblogs\"\n      }\n    }\n  }\n}\nEOF\n\naws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-Clib.json\n</code></pre> <p>Configuration of interest: <code>--files s3://&lt;s3 prefix&gt;/libexample.so</code> distributes the <code>libexample.so</code> to the working directory of all executors. Dynamic modules(.pyd, .so) can also be imported by bundling within  .egg (SPARK-6764), .whl and .pex files.</p>"},{"location":"troubleshoot/docs/troubleshooting/","title":"Troubleshooting EMR on EKS issues","text":"<p>In this section, you will find several scenarios for troubleshooting described with errors and solutions. You can find these errors using one of these methods</p> <ol> <li>using EMR on EKS describe API call</li> <li>using CloudWatch Logs. In the job submission example below, you can find logs in <code>/emr-containers/jobs</code> location</li> <li>using logs shipped to s3. In the job submission example below, you can find logs in <code>s3://'$S3BUCKET'/emr-containers-log</code> path. For driver logs, you need traverse few folders to find the logs. For example, <code>s3://S3BUCKET_NAME/emr-containers-log/CLUSTER_ID/jobs/JOB_ID/containers/spark-JOB_ID/spark-JOB_ID-driver/stderr.gz</code></li> </ol> <pre><code>--configuration-overrides '{\n    \"monitoringConfiguration\": {\n      \"cloudWatchMonitoringConfiguration\": {\n        \"logGroupName\": \"/emr-containers/jobs\", \n        \"logStreamNamePrefix\": \"demo\"\n      },               \n      \"s3MonitoringConfiguration\": {\n        \"logUri\": \"s3://'$S3BUCKET'/emr-containers-log\"\n        }\n      }\n    }'\n</code></pre>"},{"location":"troubleshoot/docs/troubleshooting/#error-persistentvolumeclaims-is-forbidden","title":"Error - \"PersistentVolumeClaims is forbidden\"","text":"<p>Occassionally, there is a drift in RBAC permission required for EMR on EKS and Managed endpoint (EMR Studio) installation to work with EKS clusters. This can happen due to upstream changes in Kubernetes RBAC policies. Here is an example of one such change in Kubernetes v1.22. Previously, EMR needed permissions for <code>ingresses.extensions</code> to create managed endpoint. But for Kubernetes v1.22 or higher versions, EMR needs <code>ingresses.networking.k8s.io</code> permissions as well. </p> <p>In addition, EMR adds newer features that require newer set of RBAC permissions. For example, Spark jobs that require creation, listing or deletion of Persistent Volume Claims (PVC) was not supported before EMR6.8. Jobs that require these permissions will fail with the exception \u201cpersistentvolumeclaims is forbidden\". Looking into driver logs, you may see an error like this: </p> <pre><code>persistentvolumeclaims is forbidden. User \"system:serviceaccount:emr:emr-containers-sa-spark-client-93ztm12rnjz163mt3rgdb3bjqxqfz1cgvqh1e9be6yr81\" cannot create resource \"persistentvolumeclaims\" in API group \"\" in namesapce \"emr\".\n</code></pre> <p>You may encounter this error because the default Kubernetes role <code>emr-containers</code> is missing the required RBAC permissions. As a result, the <code>emr-containers</code> primary role can\u2019t dynamically create necessary permissions for additional roles such as Spark driver, Spark executor or Spark client when you submit a job. Because EMR on EKS and Managed endpoint can be installed using different tooling (AWS CLI, SDK, eksctl, terraform, cdk), there can be slight delay in adding most current RBAC permissions into the tooling </p>"},{"location":"troubleshoot/docs/troubleshooting/#solution","title":"Solution:","text":"<p>Add the required permissions to <code>emr-containers</code>. </p> <p>Here are the complete RBAC permissions for EMR on EKS: </p> <ul> <li>emr-containers.yaml</li> </ul> <p>You can compare whether you have complete RBAC permissions using the steps below, </p> <pre><code>export NAMESPACE=YOUR_VALUE\nkubectl describe role emr-containers -n ${NAMESPACE}\n</code></pre> <p>If the permissions don't match, proceed to apply latest permissions</p> <pre><code>export NAMESPACE=YOUR_VALUE\nkubectl apply -f https://github.com/aws/aws-emr-containers-best-practices/blob/main/tools/k8s-rbac-policies/emr-containers.yaml -n ${NAMESPACE}\n</code></pre> <p>You can delete other two spark driver/client roles bcoz they will be dynamically created when you run next job. </p>"}]}